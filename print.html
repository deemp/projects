<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>notes</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">Outline</li><li class="chapter-item expanded "><a href="outline.html"><strong aria-hidden="true">1.</strong> Outline</a></li><li class="chapter-item expanded affix "><li class="part-title">Developers' Roadmap</li><li class="chapter-item expanded "><a href="haskell/developers-roadmap/index.html"><strong aria-hidden="true">2.</strong> README</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Aeson</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="haskell/developers-roadmap/Aeson/HKD.html"><strong aria-hidden="true">3.1.</strong> HKD</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Data</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="haskell/developers-roadmap/Data/LargeAnon.html"><strong aria-hidden="true">4.1.</strong> LargeAnon</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Debug</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="haskell/developers-roadmap/Debug/Breakpoint.html"><strong aria-hidden="true">5.1.</strong> Breakpoint</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Effectful</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="haskell/developers-roadmap/Effectful/Dynamic.html"><strong aria-hidden="true">6.1.</strong> Dynamic</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Exceptions</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="haskell/developers-roadmap/Exceptions/Exceptions.html"><strong aria-hidden="true">7.1.</strong> Exceptions</a></li><li class="chapter-item expanded "><a href="haskell/developers-roadmap/Exceptions/Theory.html"><strong aria-hidden="true">7.2.</strong> Theory</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Functions</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="haskell/developers-roadmap/Functions/Composition.html"><strong aria-hidden="true">8.1.</strong> Composition</a></li><li class="chapter-item expanded "><a href="haskell/developers-roadmap/Functions/Folds.html"><strong aria-hidden="true">8.2.</strong> Folds</a></li><li class="chapter-item expanded "><a href="haskell/developers-roadmap/Functions/General.html"><strong aria-hidden="true">8.3.</strong> General</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> FusedEffects</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="haskell/developers-roadmap/FusedEffects/ReinterpretingEffects.html"><strong aria-hidden="true">9.1.</strong> ReinterpretingEffects</a></li><li class="chapter-item expanded "><a href="haskell/developers-roadmap/FusedEffects/UndoIO.html"><strong aria-hidden="true">9.2.</strong> UndoIO</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> GADT</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="haskell/developers-roadmap/GADT/GADT.html"><strong aria-hidden="true">10.1.</strong> GADT</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> Generics</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="haskell/developers-roadmap/Generics/Generics.html"><strong aria-hidden="true">11.1.</strong> Generics</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> IO</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="haskell/developers-roadmap/IO/RandomNumbers.html"><strong aria-hidden="true">12.1.</strong> RandomNumbers</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> ImplicitParams</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="haskell/developers-roadmap/ImplicitParams/ImplicitParams.html"><strong aria-hidden="true">13.1.</strong> ImplicitParams</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> Lens</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="haskell/developers-roadmap/Lens/MissingKey.html"><strong aria-hidden="true">14.1.</strong> MissingKey</a></li><li class="chapter-item expanded "><a href="haskell/developers-roadmap/Lens/Node.html"><strong aria-hidden="true">14.2.</strong> Node</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> Misc</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="haskell/developers-roadmap/Misc/Determinant.html"><strong aria-hidden="true">15.1.</strong> Determinant</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> Monads</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="haskell/developers-roadmap/Monads/FunctionalDependencies.html"><strong aria-hidden="true">16.1.</strong> FunctionalDependencies</a></li><li class="chapter-item expanded "><a href="haskell/developers-roadmap/Monads/MonadBaseControl.html"><strong aria-hidden="true">16.2.</strong> MonadBaseControl</a></li><li class="chapter-item expanded "><a href="haskell/developers-roadmap/Monads/Monads.html"><strong aria-hidden="true">16.3.</strong> Monads</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.</strong> Monoids</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="haskell/developers-roadmap/Monoids/FizzBuzz.html"><strong aria-hidden="true">17.1.</strong> FizzBuzz</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">18.</strong> ParallelAndConcurrentHaskell</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="haskell/developers-roadmap/ParallelAndConcurrentHaskell/Exceptions.html"><strong aria-hidden="true">18.1.</strong> Exceptions</a></li><li class="chapter-item expanded "><a href="haskell/developers-roadmap/ParallelAndConcurrentHaskell/MVar.html"><strong aria-hidden="true">18.2.</strong> MVar</a></li><li class="chapter-item expanded "><a href="haskell/developers-roadmap/ParallelAndConcurrentHaskell/STM.html"><strong aria-hidden="true">18.3.</strong> STM</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">19.</strong> TemplateHaskell</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">19.1.</strong> ConstructorTags</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="haskell/developers-roadmap/TemplateHaskell/ConstructorTags/Declare.html"><strong aria-hidden="true">19.1.1.</strong> Declare</a></li><li class="chapter-item expanded "><a href="haskell/developers-roadmap/TemplateHaskell/ConstructorTags/Use.html"><strong aria-hidden="true">19.1.2.</strong> Use</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">19.2.</strong> Typed</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="haskell/developers-roadmap/TemplateHaskell/Typed/Declare.html"><strong aria-hidden="true">19.2.1.</strong> Declare</a></li><li class="chapter-item expanded "><a href="haskell/developers-roadmap/TemplateHaskell/Typed/Use.html"><strong aria-hidden="true">19.2.2.</strong> Use</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">20.</strong> Test</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="haskell/developers-roadmap/Test/Theory.html"><strong aria-hidden="true">20.1.</strong> Theory</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">21.</strong> TypeClasses</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="haskell/developers-roadmap/TypeClasses/Monoid.html"><strong aria-hidden="true">21.1.</strong> Monoid</a></li><li class="chapter-item expanded "><a href="haskell/developers-roadmap/TypeClasses/Theory.html"><strong aria-hidden="true">21.2.</strong> Theory</a></li><li class="chapter-item expanded "><a href="haskell/developers-roadmap/TypeClasses/TypeClasses.html"><strong aria-hidden="true">21.3.</strong> TypeClasses</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">22.</strong> TypeFamilies</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="haskell/developers-roadmap/TypeFamilies/StringInterpolate.html"><strong aria-hidden="true">22.1.</strong> StringInterpolate</a></li><li class="chapter-item expanded "><a href="haskell/developers-roadmap/TypeFamilies/TaggedClasses.html"><strong aria-hidden="true">22.2.</strong> TaggedClasses</a></li><li class="chapter-item expanded "><a href="haskell/developers-roadmap/TypeFamilies/Theory.html"><strong aria-hidden="true">22.3.</strong> Theory</a></li><li class="chapter-item expanded "><a href="haskell/developers-roadmap/TypeFamilies/TypeFamilies.html"><strong aria-hidden="true">22.4.</strong> TypeFamilies</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Optics By Example</li><li class="chapter-item expanded "><a href="haskell/optics-by-example/Book.html"><strong aria-hidden="true">23.</strong> Book</a></li><li class="chapter-item expanded "><a href="haskell/optics-by-example/Extra.html"><strong aria-hidden="true">24.</strong> Extra</a></li><li class="chapter-item expanded affix "><li class="part-title">Thinking with Types</li><li class="chapter-item expanded "><a href="haskell/thinking-with-types/Chapter02.html"><strong aria-hidden="true">25.</strong> Chapter02</a></li><li class="chapter-item expanded "><a href="haskell/thinking-with-types/Chapter03.html"><strong aria-hidden="true">26.</strong> Chapter03</a></li><li class="chapter-item expanded "><a href="haskell/thinking-with-types/Chapter04.html"><strong aria-hidden="true">27.</strong> Chapter04</a></li><li class="chapter-item expanded "><a href="haskell/thinking-with-types/Chapter05.html"><strong aria-hidden="true">28.</strong> Chapter05</a></li><li class="chapter-item expanded "><a href="haskell/thinking-with-types/Chapter05_1.html"><strong aria-hidden="true">29.</strong> Chapter05_1</a></li><li class="chapter-item expanded "><a href="haskell/thinking-with-types/Chapter06.html"><strong aria-hidden="true">30.</strong> Chapter06</a></li><li class="chapter-item expanded "><a href="haskell/thinking-with-types/Chapter13.html"><strong aria-hidden="true">31.</strong> Chapter13</a></li><li class="chapter-item expanded affix "><li class="part-title">Sockets and Pipes</li><li class="chapter-item expanded "><a href="haskell/sockets-and-pipes-notes/C_01_Handles.html"><strong aria-hidden="true">32.</strong> C_01_Handles</a></li><li class="chapter-item expanded "><a href="haskell/sockets-and-pipes-notes/C_02_Chunks.html"><strong aria-hidden="true">33.</strong> C_02_Chunks</a></li><li class="chapter-item expanded "><a href="haskell/sockets-and-pipes-notes/C_03_Bytes.html"><strong aria-hidden="true">34.</strong> C_03_Bytes</a></li><li class="chapter-item expanded "><a href="haskell/sockets-and-pipes-notes/C_04_Sockets.html"><strong aria-hidden="true">35.</strong> C_04_Sockets</a></li><li class="chapter-item expanded "><a href="haskell/sockets-and-pipes-notes/C_05_HTTP.html"><strong aria-hidden="true">36.</strong> C_05_HTTP</a></li><li class="chapter-item expanded "><a href="haskell/sockets-and-pipes-notes/C_06_HTTP_types.html"><strong aria-hidden="true">37.</strong> C_06_HTTP_types</a></li><li class="chapter-item expanded "><a href="haskell/sockets-and-pipes-notes/C_07_Encoding.html"><strong aria-hidden="true">38.</strong> C_07_Encoding</a></li><li class="chapter-item expanded "><a href="haskell/sockets-and-pipes-notes/C_08_Responding.html"><strong aria-hidden="true">39.</strong> C_08_Responding</a></li><li class="chapter-item expanded "><a href="haskell/sockets-and-pipes-notes/C_09_Content_types.html"><strong aria-hidden="true">40.</strong> C_09_Content_types</a></li><li class="chapter-item expanded "><a href="haskell/sockets-and-pipes-notes/C_10_Change.html"><strong aria-hidden="true">41.</strong> C_10_Change</a></li><li class="chapter-item expanded "><a href="haskell/sockets-and-pipes-notes/C_11_Streaming.html"><strong aria-hidden="true">42.</strong> C_11_Streaming</a></li><li class="chapter-item expanded affix "><li class="part-title">Miscellaneous Notes</li><li class="chapter-item expanded "><a href="miscNotes/MiscNotes.html"><strong aria-hidden="true">43.</strong> Notes</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="projects-docs"><a class="header" href="#projects-docs">Projects docs</a></h1>
<p>This is a collection of docs generated for several <a href="https://github.com/deemp/projects#readme">projects</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="developers-roadmap"><a class="header" href="#developers-roadmap">Developers roadmap</a></h1>
<p>Inspired by <a href="https://github.com/fullstack-development/developers-roadmap">developers-roadmap</a>.</p>
<p>Extensions:</p>
<!-- FOURMOLU_DISABLE -->
<pre><code class="language-haskell">{-# LANGUAGE DataKinds #-}
{-# LANGUAGE StandaloneKindSignatures #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE TypeFamilyDependencies #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE NumericUnderscores #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE InstanceSigs #-}
{-# OPTIONS_GHC -Wno-unused-top-binds #-}
</code></pre>
<!-- FOURMOLU_ENABLE -->
<p>Imports</p>
<pre><code class="language-haskell">import Control.Monad.Fix (fix)
import Language.Haskell.TH.Syntax (Dec, Quasi, runQ)
</code></pre>
<!-- d -->
<pre><code class="language-haskell">main = undefined
</code></pre>
<!-- e -->
<h2 id="kinds"><a class="header" href="#kinds">Kinds</a></h2>
<ul>
<li>
<p><code>DataKinds</code> - <a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/type_data.html#type-level-data-declarations">src</a></p>
<ul>
<li>What is the data type promotion?
<ul>
<li>promote terms to type level like <code>'[1,2,3]</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>Are types with promoted kinds inhabited?</p>
<ul>
<li><strong>inhabited types</strong> (types that have at least 1 value) are of kind <strong>Type</strong></li>
</ul>
</li>
<li>
<p><code>ConstraintKinds</code> - <code>Constraint</code>s as first-class citizens</p>
<pre><code class="language-hs">type Stringy a = (Read a, Show a)
</code></pre>
</li>
<li>
<p><code>Symbol</code> - a compile-time string</p>
<ul>
<li><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-TypeLits.html#t:UnconsSymbol">UnconsSymbol</a></li>
<li><a href="https://github.com/dmjio/typed-interpolation">typed-interpolation</a> - a good parsing example.</li>
</ul>
</li>
</ul>
<h2 id="functional-dependencies"><a class="header" href="#functional-dependencies">Functional dependencies</a></h2>
<ul>
<li>
<p>Set a relation between types. Make one type correspond to another type</p>
<!-- i 4 -->
<pre><code class="language-haskell">class (Monad m) =&gt; MonadError e m | m -&gt; e where
  throwError :: e -&gt; m a
  catchError :: m a -&gt; (e -&gt; m a) -&gt; m a
</code></pre>
</li>
<li>
<p>Problem (<a href="https://www.fpcomplete.com/haskell/tutorial/fundeps/#exercises">src</a>):</p>
<blockquote>
<p>we want a MonadReader typeclass where there is only a single instance per m, and we know the env parameter that will be available from each m.</p>
</blockquote>
<ul>
<li>Approach 1:
<ul>
<li>
<p><code>MultiParamTypeClasses</code> let us specify explicitly what the <code>env</code> is</p>
</li>
<li>
<p><code>FunctionalDependencies</code> allow us to constrain ourselves to a single instance.</p>
<pre><code class="language-hs">newtype PersonReader a = PersonReader { runPersonReader :: Person -&gt; a } deriving Functor

class MonadReader env m | m -&gt; env where
  ask :: m env

instance MonadReader Person PersonReader where
  ask = PersonReader $ \env -&gt; env

instance MonadReader env (Reader env) where
  ask = Reader $ \env -&gt; env

greeting :: PersonReader String
greeting = do
  person &lt;- ask
  -- Here, derives that `person :: Person`
  -- from `instance MonadReader Person PersonReader`
  -- via fundep `m -&gt; env` and `ask :: m env`
  pure $ show person
</code></pre>
</li>
<li>
<p>Approach 2:</p>
<ul>
<li>
<p><code>TypeFamilies</code></p>
<!-- i 10 -->
<pre><code class="language-haskell">class MonadReader m where
  -- use an associated type
  type Env m
  ask :: m (Env m)

data Person
newtype PersonReader a = PersonReader (a -&gt; a)

-- `m (Env m)` calculates to `PersonReader Person`
instance MonadReader PersonReader where
  type Env PersonReader = Person
  ask :: PersonReader (Env PersonReader)
  ask = PersonReader id
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="laziness"><a class="header" href="#laziness">Laziness</a></h2>
<ul>
<li>
<p><code>Bang patterns</code></p>
<!-- i 2 -->
</li>
</ul>
<!-- FOURMOLU_DISABLE -->
<pre><code class="language-haskell">{-# LANGUAGE BangPatterns #-}
</code></pre>
<!-- FOURMOLU_ENABLE -->
<pre><code class="language-haskell">addBang :: Int -&gt; Int -&gt; Int
addBang !x !y = x + y

-- equivalent to
addSeq :: Int -&gt; Int -&gt; Int
addSeq x y = x `seq` y `seq` x + y
</code></pre>
<ul>
<li>
<p><code>$!</code> - strict application</p>
</li>
<li>
<p><code>Thunk</code> is an unevaluated expression - <a href="https://stackoverflow.com/a/13984345">src</a></p>
<ul>
<li><code>free variables</code> in an unevaluated expr</li>
<li>when evaluated, the pointers to it will point to the result</li>
<li>a <code>dead thunk</code> is <code>garbage collected</code></li>
</ul>
</li>
<li>
<p>Expression forms - <a href="https://stackoverflow.com/a/6889335">src</a></p>
<ul>
<li>
<p>Normal form</p>
<blockquote>
<p>An expression in normal form is fully evaluated, and no sub-expression could be evaluated any further (i.e. it contains no un-evaluated thunks).</p>
</blockquote>
</li>
<li>
<p>Weak head normal form</p>
<blockquote>
<p>An expression in weak head normal form has been evaluated to the outermost data constructor or lambda abstraction (the head).</p>
</blockquote>
<pre><code class="language-hs">(1 + 1, 2 + 2)       -- the outermost part is the data constructor (,)
\x -&gt; 2 + 2
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>a `seq` b</code> - eval <code>a</code> to <code>WHNF</code>, return <code>b</code></p>
</li>
<li>
<p><code>a `deepseq` b</code> - eval <code>a</code> to <code>NF</code>, return <code>b</code></p>
</li>
<li>
<p><code>force b = b `deepseq` b</code> - eval <code>b</code> to <code>NF</code> and return <code>b</code></p>
<ul>
<li>If we have <code>let a = force b</code>, <code>a</code> is not in <code>NF</code></li>
<li>To get <code>a</code> in <code>NF</code>, we need to <code>!a</code></li>
</ul>
</li>
<li>
<p><a href="https://youtu.be/I4lnCG18TaY">Thunks, Sharing, Laziness</a> via <code>ghc-viz</code> (available in <code>nixpkgs</code>)</p>
</li>
<li>
<p><a href="https://www.fpcomplete.com/haskell/tutorial/exceptions/">safe-exceptions</a></p>
<ul>
<li>force impure exceptions using <code>tryAnyDeep</code> and <code>NFData</code>.</li>
</ul>
</li>
</ul>
<h2 id="fix-combinator"><a class="header" href="#fix-combinator">Fix combinator</a></h2>
<pre><code class="language-haskell">ex13 :: [Int] -&gt; Int
ex13 =
  fix
    ( \t c -&gt;
        \case
          (a0 : a1 : as) -&gt; t (c + fromEnum (signum a0 /= signum a1)) (a1 : as)
          _ -&gt; c
    )
    0

-- &gt;&gt;&gt;ex13 [-3,0,2,0,5]
-- 4
</code></pre>
<h2 id="file-io"><a class="header" href="#file-io">File IO</a></h2>
<ul>
<li>There are several representations of text in <code>Haskell</code> - <code>ByteString</code>, <code>Text</code>, <code>String</code></li>
<li><code>ByteString</code> can contain both <code>human-readable</code> or <code>binary</code> data that mustn't be mixed</li>
<li>Also, there are many <code>file encodings</code>. Use <code>UTF-8</code> to be safe</li>
<li>One can encode standard data types into a <code>ByteString</code> using <a href="https://hackage.haskell.org/package/bytestring-0.11.4.0/docs/Data-ByteString-Builder.html">Data.ByteString.Builder</a></li>
<li><code>LBS</code> reads files in chunks. Can be used for streaming</li>
<li><code>hGet</code> reads a given number of bytes from a handle</li>
<li><code>stdout</code> and <code>stdin</code> are files</li>
<li>Can set buffering mode on a handle: <code>hSetBuffering stdout NoBuffering</code></li>
</ul>
<h2 id="debugging"><a class="header" href="#debugging">Debugging</a></h2>
<ul>
<li><code>Debug.Trace</code></li>
<li><code>breakpoint</code> - <a href="https://github.com/aaronallen8455/breakpoint">src</a>
<ul>
<li>put breakpoints into an app (see <a href="haskell/developers-roadmap/./app/TryBreakpoint.hs">TryBreakpoint</a>)</li>
<li>inspect variables visible at a breakpoint</li>
<li>freeze other threads (<code>GHC 9.2.x+</code>)</li>
</ul>
</li>
</ul>
<h2 id="monoid"><a class="header" href="#monoid">Monoid</a></h2>
<ul>
<li><a href="https://wiki.haskell.org/List_comprehension">List comprehension</a>
<ul>
<li>Skip elements
<ul>
<li>
<p>On a flag</p>
<!-- i 8 -->
<pre><code class="language-haskell">_deepClone :: Bool
_deepClone = True

s1 :: [String]
s1 = [&quot;--deepClone&quot; | _deepClone]
</code></pre>
</li>
<li>
<p>On a pattern fail</p>
<!-- i 8 -->
<pre><code class="language-haskell">catMaybes :: [Maybe a] -&gt; [a]
catMaybes ls = [x | Just x &lt;- ls]
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="template-haskell"><a class="header" href="#template-haskell">Template Haskell</a></h2>
<ul>
<li>
<p><a href="https://github.com/codedownio/aeson-typescript/blob/671347e3739b63bf04d5412330dc9a4748c7832e/src/Data/Aeson/TypeScript/Util.hs#L224">capture haddocks</a></p>
<ul>
<li><a href="https://hackage.haskell.org/package/template-haskell-2.19.0.0/docs/Language-Haskell-TH-Syntax.html#v:getDoc">getDoc</a></li>
</ul>
</li>
<li>
<p>print the structure of an expression</p>
<!-- i 2 -->
<pre><code class="language-haskell">ex2 :: (Quasi a) =&gt; a [Dec]
ex2 = runQ [d|decl :: Int; decl = 1 + 2|]

-- &gt;&gt;&gt;ex2
-- [SigD decl_0 (ConT GHC.Types.Int),ValD (VarP decl_0) (NormalB (InfixE (Just (LitE (IntegerL 1))) (VarE GHC.Num.+) (Just (LitE (IntegerL 2))))) []]
</code></pre>
</li>
</ul>
<h2 id="higher-kinded-data"><a class="header" href="#higher-kinded-data">Higher-Kinded Data</a></h2>
<ul>
<li>Defaulting fields in a record (via HKD) - <a href="https://gist.github.com/chrisdone/7dddadd089e6a5d2e3e9445c4692d2c2">GH</a></li>
<li><a href="https://reasonablypolymorphic.com/blog/higher-kinded-data/">Higher-Kinded Data</a>
<ul>
<li><a href="https://reasonablypolymorphic.com/blog/free-lenses/index.html">Free Lenses for Higher-Kinded Data</a></li>
<li><a href="https://reasonablypolymorphic.com/blog/hkd-not-terrible/index.html">HKD: Less Terrible than You Might Expect</a></li>
<li>and <a href="https://reasonablypolymorphic.com/">others</a></li>
</ul>
</li>
</ul>
<h2 id="generics"><a class="header" href="#generics">Generics</a></h2>
<ul>
<li><a href="https://reasonablypolymorphic.com/blog/higher-kinded-data/">Higher-Kinded Data</a></li>
<li><code>aeson</code> converts data to generic representation.
<ul>
<li>Its functions for parsing use selector names, modify them via options, then convert to or parse JSON.</li>
</ul>
</li>
</ul>
<h2 id="qualifieddo"><a class="header" href="#qualifieddo">QualifiedDo</a></h2>
<ul>
<li><a href="https://www.tweag.io/blog/2020-07-13-qualified-do-announcement/">Qualified do: rebind your do-notation the right way</a>
<ul>
<li>
<p>example</p>
<pre><code class="language-hs">{-# LANGUAGE QualifiedDo #-}

module Main where

import Data.Function((&amp;))

(&gt;&gt;=) = (&amp;)

foo :: Int
foo = Main.do
  z &lt;- (3, 4)
  (x, s) &lt;- z
  x

main = print foo
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="effects"><a class="header" href="#effects">Effects</a></h2>
<h3 id="effectful"><a class="header" href="#effectful">Effectful</a></h3>
<ul>
<li><a href="https://hackage.haskell.org/package/effectful">effectful</a>
<ul>
<li><a href="https://www.youtube.com/watch?v=BUoYKBLOOrE">Talk</a> at Lambda</li>
<li>Сервер с servant, esqueleto, effectful - <a href="https://youtube.com/playlist?list=PLDtVwbUDS3Wky1MaMPqFp0eaOGd_gzvZo">YT</a></li>
<li>News site back-end - <a href="https://github.com/breaking-news-org/back-end">GH</a></li>
<li>Effects may be pure - <code>runPureEff</code></li>
</ul>
</li>
</ul>
<h2 id="string-interpolation"><a class="header" href="#string-interpolation">String interpolation</a></h2>
<ul>
<li><a href="https://hackage.haskell.org/package/string-interpolate">string-interpolate</a></li>
<li><a href="https://hackage.haskell.org/package/nyan-interpolation">nyan-interpolation</a></li>
<li><a href="https://hackage.haskell.org/package/PyF">PyF</a></li>
<li><a href="https://github.com/dmjio/typed-interpolation">typed-interpolation</a></li>
</ul>
<h2 id="optics"><a class="header" href="#optics">Optics</a></h2>
<ul>
<li><a href="https://www.haskellforall.com/2021/09/optics-are-monoids.html">Optics are monoids</a></li>
<li><a href="haskell/developers-roadmap/../optics-by-example">Optics by example</a></li>
</ul>
<h2 id="monad-transformer-stack"><a class="header" href="#monad-transformer-stack">Monad transformer stack</a></h2>
<ul>
<li>Determine the type - <a href="https://stackoverflow.com/a/13724465">SO</a></li>
</ul>
<h2 id="unliftio"><a class="header" href="#unliftio">UnliftIO</a></h2>
<ul>
<li><a href="https://lexi-lambda.github.io/blog/2019/09/07/demystifying-monadbasecontrol/">Demystifying MonadBaseControl</a>
<ul>
<li>Capture the action’s input state and close over it.</li>
<li>Package up the action’s output state with its result and run it.</li>
<li>Restore the action’s output state into the enclosing transformer.</li>
<li>Return the action’s result.</li>
</ul>
</li>
</ul>
<h2 id="handle-pattern"><a class="header" href="#handle-pattern">Handle pattern</a></h2>
<ul>
<li>
<p><a href="https://www.metalamp.ru/articles/service-handle-pattern">src</a></p>
</li>
<li>
<p>Take functions from a <strong>given</strong> environment, e.g. from <code>ReaderT</code></p>
</li>
</ul>
<h2 id="data"><a class="header" href="#data">Data</a></h2>
<ul>
<li><a href="https://github.com/well-typed/large-records">large-records</a></li>
<li>Avoid quadratic Core size - <a href="https://well-typed.com/blog/2021/10/large-records-part-2/#tldr-advice">advice</a></li>
</ul>
<h2 id="ghcjs"><a class="header" href="#ghcjs">GHCJS</a></h2>
<ul>
<li><a href="https://github.com/rzk-lang/rzk">rzk-lang/rzk</a> - see <code>flake.nix</code></li>
</ul>
<h2 id="nix"><a class="header" href="#nix">Nix</a></h2>
<ul>
<li>To keep completions in <a href="https://github.com/NixOS/cabal2nix/issues/433#issuecomment-862557347">share</a>, need to modify <a href="https://github.com/NixOS/nixpkgs/blob/c032f4a16c1d09533c8af71002d5e7ad2d85af60/pkgs/development/haskell-modules/lib/compose.nix#L288C8-L288C8">justStaticExecutables</a> 
so that it doesn't remove <code>share</code>.</li>
</ul>
<h2 id="misc"><a class="header" href="#misc">Misc</a></h2>
<ul>
<li><a href="https://habr.com/ru/articles/496370/">Радости и горести побед над C: делаем конфетку из прототипа wc на хаскеле</a>
<ul>
<li><a href="https://github.com/0xd34df00d/hwc/tree/master">hwc</a></li>
</ul>
</li>
<li>Parsing with Haskell
<ul>
<li><a href="https://serokell.io/blog/lexing-with-alex">Part 1</a></li>
</ul>
</li>
<li>Haskell CI with caching - <a href="https://github.com/aaronallen8455/breakpoint/blob/main/.github/workflows/ci.yml">src</a></li>
<li><code>string-interpolate</code> - <a href="https://hackage.haskell.org/package/string-interpolate">src</a>
<ul>
<li>UTF-8 string interpolation</li>
</ul>
</li>
<li><a href="https://gitlab.haskell.org/ghc/ghc/-/wikis/view-patterns">ViewPatterns</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeFamilies #-}

module Try.Aeson.HKD where

import Control.Lens (Identity, non, (&amp;), (^.))
import Data.Aeson
import Data.Aeson.TH (deriveJSON)
import Data.Kind
import Data.List.NonEmpty (NonEmpty ((:|)))
import Data.List.NonEmpty qualified as NE
import Fcf (Eval, Exp)
import GHC.Generics

data ORBEParty f = ORBEParty
  { infants :: Eval (f Int)
  , children :: Eval (f Int)
  , adults :: Eval (f Int)
  }
  deriving (Generic)

data MyIdentity :: a -&gt; Exp a
data MyMaybe :: a -&gt; Exp a

type instance Eval (MyIdentity a) = a
type instance Eval (MyMaybe a) = Maybe (NonEmpty a)

instance FromJSON (ORBEParty MyMaybe)
deriving instance Show (ORBEParty MyIdentity)
deriving instance Show (ORBEParty MyMaybe)

t1 = &quot;{ \&quot;adults\&quot;: [3] }&quot; &amp; decode @(ORBEParty MyMaybe)

-- &gt;&gt;&gt; t1
-- Just (ORBEParty {infants = Nothing, children = Nothing, adults = Just (3 :| [])})

toDefault :: ORBEParty MyMaybe -&gt; ORBEParty MyIdentity
toDefault ORBEParty{..} =
  ORBEParty
    { infants = maybe 1 NE.head infants
    , children = maybe 1 NE.head children
    , adults = maybe 1 NE.head adults
    }

data Party = Party
  { adults :: Maybe Int
  , children :: Maybe (NonEmpty Int)
  , infants :: Maybe Int
  }
  deriving (Generic, Show)

deriveJSON defaultOptions ''Party

t = &quot;{ \&quot;adults\&quot;: 3, \&quot;children\&quot; : [] }&quot; &amp; decode @Party

-- &gt;&gt;&gt; t
-- Nothing
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="large-anon-practical-scalable-anonymous-records-for-haskell"><a class="header" href="#large-anon-practical-scalable-anonymous-records-for-haskell">large-anon: Practical scalable anonymous records for Haskell</a></h1>
<p><a href="https://well-typed.com/blog/2022/04/large-anon/">source</a></p>
<p>TODO: example with generic lens (<a href="https://github.com/well-typed/large-records/issues/150">issue</a>)</p>
<!-- FOURMOLU_DISABLE -->
<pre><code class="language-haskell">{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE OverloadedLabels #-}
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE OverloadedRecordUpdate #-}
{-# LANGUAGE RebindableSyntax #-}
{-# LANGUAGE TypeOperators #-}
{-# OPTIONS_GHC -Wno-unticked-promoted-constructors #-}
{-# OPTIONS_GHC -fplugin=Data.Record.Anon.Plugin #-}

module Try.Data.LargeAnon where

import Data.Record.Anon
import Data.Record.Anon.Overloading
import Data.Record.Anon.Simple

magenta :: Record [&quot;red&quot; := Double, &quot;green&quot; := Double, &quot;blue&quot; := Double]
magenta = ANON{red = 1, green = 0, blue = 1}

purple :: Record '[&quot;red&quot; ':= Double, &quot;green&quot; ':= Integer, &quot;blue&quot; ':= Double]
purple = insert #red 0.5 $ insert #green 0 $ insert #blue 0.5 empty

b :: Double
b = purple.blue

-- &gt;&gt;&gt; b
-- 0.5

reduceRed :: (RowHasField &quot;red&quot; r Double) =&gt; Record r -&gt; Record r
reduceRed c = c{red = c.red * 0.9}

ex1 :: Record '[&quot;red&quot; ':= Double, &quot;green&quot; ':= Double, &quot;blue&quot; ':= Double]
ex1 = reduceRed magenta


-- TODO how to show?

-- &gt;&gt;&gt; ex1
-- No instance for (AllFields
--                    '[ &quot;red&quot; ':= Double, &quot;green&quot; ':= Double, &quot;blue&quot; ':= Double] Show)
--   arising from a use of `evalPrint'
-- In a stmt of an interactive GHCi command: evalPrint it_a1SAw
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# OPTIONS_GHC -fplugin Debug.Breakpoint #-}

module Try.Debug.Breakpoint where

import Debug.Breakpoint (breakpointIO)

main :: IO ()
main = do
  putStrLn &quot;Type something!&quot;
  x &lt;- getLine
  let y = 2 :: Int
      z = id :: Bool -&gt; Bool
  breakpointIO
  pure ()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE InstanceSigs #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE UndecidableInstances #-}

module Try.Effectful.Dynamic where

import Control.Exception (IOException)
import Control.Monad (replicateM)
import Control.Monad.Catch (catch)
import Control.Monad.Cont (MonadIO (..))
import Data.Char (chr)
import Data.Map.Strict qualified as M
import Effectful (Dispatch (..), DispatchOf, Eff, Effect, IOE, runEff, runPureEff, type (:&gt;))
import Effectful.Dispatch.Dynamic (HasCallStack, interpret, localSeqUnlift, localSeqUnliftIO, reinterpret, send)
import Effectful.Error.Dynamic
import Effectful.State.Static.Local
import GHC.Clock (getMonotonicTime)
import System.IO qualified as IO
import Prelude hiding (readFile)

data FileSystem :: Effect where
  ReadFile :: FilePath -&gt; FileSystem m String
  WriteFile :: FilePath -&gt; String -&gt; FileSystem m ()

type instance DispatchOf FileSystem = Dynamic

readFile :: (HasCallStack, FileSystem :&gt; es) =&gt; FilePath -&gt; Eff es String
readFile path = send (ReadFile path)

writeFile :: (HasCallStack, FileSystem :&gt; es) =&gt; FilePath -&gt; String -&gt; Eff es ()
writeFile path content = send (WriteFile path content)

newtype FsError = FsError String deriving (Show)

runFileSystemIO :: (IOE :&gt; es, Error FsError :&gt; es) =&gt; Eff (FileSystem : es) a -&gt; Eff es a
runFileSystemIO = interpret $ \_ -&gt; \case
  ReadFile path -&gt; adapt $ IO.readFile path
  WriteFile path contents -&gt; adapt $ IO.writeFile path contents
 where
  adapt m = liftIO m `catch` \(e :: IOException) -&gt; throwError . FsError $ show e

runFileSystemPure :: Error FsError :&gt; es =&gt; M.Map FilePath String -&gt; Eff (FileSystem : es) a -&gt; Eff es a
runFileSystemPure fs0 = reinterpret (evalState fs0) $ \_ -&gt; \case
  ReadFile path -&gt;
    gets (M.lookup path) &gt;&gt;= \case
      Just contents -&gt; pure contents
      Nothing -&gt; throwError . FsError $ &quot;File not found: &quot; ++ show path
  WriteFile path contents -&gt; modify $ M.insert path contents

action :: (FileSystem :&gt; es) =&gt; Eff es Bool
action = do
  file &lt;- readFile &quot;nix-managed.cabal&quot;
  pure $ not (null file)

-- &gt;&gt;&gt;:t action
-- action :: (FileSystem :&gt; es) =&gt; Eff es Bool

-- &gt;&gt;&gt;runEff . runError @FsError . runFileSystemIO $ action
-- Right True

-- &gt;&gt;&gt;runPureEff . runErrorNoCallStack @FsError . runFileSystemPure M.empty $ action
-- Left (FsError &quot;File not found: \&quot;nix-managed.cabal\&quot;&quot;)

data Profiling :: Effect where
  Profile :: String -&gt; m a -&gt; Profiling m a

type instance DispatchOf Profiling = Dynamic

profile :: (HasCallStack, Profiling :&gt; es) =&gt; String -&gt; Eff es a -&gt; Eff es a
profile label action = send (Profile label action)

runProfiling :: IOE :&gt; es =&gt; Eff (Profiling : es) a -&gt; Eff es a
runProfiling = interpret $ \env -&gt; \case
  Profile label action -&gt; localSeqUnliftIO env $ \unlift -&gt; do
    t1 &lt;- getMonotonicTime
    r &lt;- unlift action
    t2 &lt;- getMonotonicTime
    putStrLn $ &quot;Action '&quot; ++ label ++ &quot;' took &quot; ++ show (t2 - t1) ++ &quot; seconds.&quot;
    pure r

runNoProfiling :: Eff (Profiling : es) a -&gt; Eff es a
runNoProfiling = interpret $ \env -&gt; \case
  Profile label action -&gt; localSeqUnlift env $ \unlift -&gt; unlift action

action1 :: (Profiling :&gt; es, IOE :&gt; es) =&gt; Eff es ()
action1 = profile &quot;greet&quot; . liftIO $ putStrLn &quot;Hello!&quot;

testProfiling :: IO ()
testProfiling = runEff . runProfiling $ action1

testNoProfiling :: IO ()
testNoProfiling = runEff . runNoProfiling $ action1

class Monad m =&gt; MonadRNG m where
  randomInt :: m Int

randomString :: MonadRNG m =&gt; Int -&gt; m String
randomString n = map chr &lt;$&gt; replicateM n randomInt

data RNG :: Effect where
  RandomInt :: RNG m Int

type instance DispatchOf RNG = Dynamic

instance RNG :&gt; es =&gt; MonadRNG (Eff es) where
  randomInt :: (RNG :&gt; es) =&gt; Eff es Int
  randomInt = send RandomInt

runDummyRNG :: Eff (RNG : es) a -&gt; Eff es a
runDummyRNG = interpret $ \_ -&gt; \case
  RandomInt -&gt; pure 55

testDummy :: IO String
testDummy = runEff . runDummyRNG $ randomString 3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# HLINT ignore &quot;Use tuple-section&quot; #-}
{-# LANGUAGE BlockArguments #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}

module Try.Exceptions.Exceptions where

import Control.Monad.Logger.CallStack
import Data.String.Interpolate
import GHC.Enum (Enum (..))
import UnliftIO (finally, timeout, tryAny)
import UnliftIO.Concurrent

oneSecond, fiveSeconds :: Int
oneSecond = 1000000
fiveSeconds = 5000000

main :: IO ()
main = runStdoutLoggingT do
  res &lt;- timeout oneSecond $ do
    logInfo [i|Inside the timeout|]
    res &lt;-
      tryAny $
        threadDelay fiveSeconds
          `finally` logInfo &quot;Inside the finally&quot;
    logInfo [i|Result: #{res}|]
  logInfo [i|After timeout: #{res}|]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">module Try.Exceptions.Theory where
</code></pre>
<h3 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h3>
<ul>
<li><a href="https://www.fpcomplete.com/haskell/tutorial/exceptions/">Safe exception handling</a>
<ul>
<li>Types of exceptions:
<ul>
<li><code>synchronous</code> - generated in <code>IO</code>, thrown inside a single thread. Allow <code>recovery</code> and <code>cleanup</code></li>
<li><code>asynchronous</code> - generated from outside a thread. Allow <code>cleanup</code>, but <code>no recovery</code></li>
<li><code>impure</code> - generated in a pure code, thrown when a thunk gets evaluated.
<ul>
<li>Example: <code>error</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>[Exceptions and concurrency] - <a href="https://www.youtube.com/watch?v=UKAGN8v2t2k">YT</a>
<ul>
<li>use [safe-exceptions]</li>
</ul>
</li>
</ul>
<p>From Haskell in Depth (Chapter 7)</p>
<ul>
<li>Avoid using exceptions when possible</li>
<li>Due to laziness, an exception in an expression doesn't happen until that expression gets evaluated.</li>
<li>A thread can be killed by other threads or the runtime system (due to memory exhaustion, etc.)</li>
<li>Types of exceptions:
<ul>
<li><code>programmable</code>
<ul>
<li>used in pure monad stacks (e.g., <code>ExceptT</code>)</li>
</ul>
</li>
<li><code>extensible</code>
<ul>
<li>Extensions thrown anywhere, caught only in <code>IO</code></li>
<li>Supported by the GHC runtime system</li>
<li><code>imprecise</code> exceptions - thrown in pure code, order unspecified by the runtime system</li>
<li>All exceptions have an instance of <code>Exception</code> and are values of the <code>SomeException</code> type</li>
</ul>
</li>
</ul>
</li>
<li>packages - <code>exceptions</code>, <code>safe-exceptions</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}

{-# HLINT ignore &quot;Avoid lambda&quot; #-}
{-# HLINT ignore &quot;Use section&quot; #-}
{-# HLINT ignore &quot;Redundant lambda&quot; #-}
{-# HLINT ignore &quot;Redundant bracket&quot; #-}

module Try.Functions.Composition where

import Control.Monad.Fix (fix)

-- Is
-- (. (+)) . (.) . (*)
-- equivalent to
-- \a b c -&gt; a * (b + c)
-- ?

-- (.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c

s = (. (+)) . (.) . (*)

-- infixr 9  .
-- f . g . h ~ f . (g . h)
s1 = (. (+)) . ((.) . (*))

-- (.) f g = \x -&gt; f (g x)
s2 = (. (+)) . (\x -&gt; (.) ((*) x))

-- f . g = \x -&gt; f (g x)
s3 = \y -&gt; (. (+)) ((\x -&gt; (.) ((*) x)) y)

-- a = \x -&gt; b ~ a x = b
s4 y = (. (+)) ((\x -&gt; (.) ((*) x)) y)

-- (\x -&gt; f) y ~ [y/x]f
s5 y = (. (+)) ((.) ((*) y))

-- (\a b -&gt; a `op` b) f = \b -&gt; f `op` b
-- (.) f = \g -&gt; f . g
s6 y = (. (+)) (\z -&gt; ((*) y) . z)

-- (.) f g = \x -&gt; f (g x)
s7 y = (. (+)) (\z i -&gt; ((*) y) (z i))

-- (\a b -&gt; a `op` b) f ~ \b -&gt; f `op` b
-- (*) f = \g -&gt; f * g
s8 y = (. (+)) (\z i -&gt; y * z i)

-- (`op` g) f ~ f `op` g
-- (. (+)) f ~ f . (+)
s9 y = (\z i -&gt; y * z i) . (+)

-- f . g ~ \x -&gt; f (g x)
s10 y = \p -&gt; (\z i -&gt; y * z i) ((+) p)

s11 y p = (\z i -&gt; y * z i) ((+) p)

-- (\x -&gt; f) y ~ [y/x]f
s12 y p = \i -&gt; y * ((+) p) i

-- a = \x -&gt; b ~ a x = b
s13 y p i = y * (p + i)

-- alpha reduction
s14 a b c = a * (b + c)

-- &gt;&gt;&gt; s1 3 5 6 == s12 3 5 6
-- True

-- &gt;&gt;&gt; s1 4 98 12 == s12 4 98 12
-- True
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# LANGUAGE LambdaCase #-}

module Try.Functions.Folds where

import Control.Monad.Fix (fix)
import Data.List (scanl')

calc l1 = reverse $ fix (\go s acc -&gt; \case (x : xs) -&gt; go (s - x) (s : acc) xs; [] -&gt; s : acc) (sum l1) [] l1

-- &gt;&gt;&gt; calc [3,5,6]
-- [14,11,6,0]

calc1 l1 = reverse $ scanr (flip (-)) (sum l1) (reverse l1)

-- &gt;&gt;&gt; calc1 [3,5,6]
-- [14,11,6,0]

calc2 l1 = scanl' (-) (sum l1) l1

-- &gt;&gt;&gt; calc2 [3,5,6]
-- [14,11,6,0]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">module Try.Functions.General (main) where

import Data.Function ((&amp;))

-- How to declare a function? What are the function declaration parts?
-- What is the type (type signature) of a function?
main :: IO ()
main = putStrLn &quot;Hello, world!&quot;

-- Is it possible to declare a function without specifying its type signature? Can it cause problems, and if so, which ones?

-- But I want a Monoid
f1 :: Semigroup a =&gt; a -&gt; a
f1 a = a &lt;&gt; a

-- How and when the let... in... expression is used?
f2 :: Num a =&gt; a -&gt; a
f2 a = let b = 3 in a + b

-- How and when the where... clause is used?
f3 :: Integer
f3 = h'
 where
  h' = 3

-- Function application:

-- What is the difference between the following ways to apply a function:
-- f x (function application syntax), $ operator, &amp; operator?
f4 :: (a -&gt; b -&gt; c) -&gt; c
f4 s = t4
 where
  x = undefined :: a
  y = undefined :: b
  -- left assoc
  _ = s x
  -- left assoc
  _ = x &amp; s
  t3 :: a -&gt; b
  t3 _ = y
  -- right assoc
  t4 = s x $ t3 x

-- Why do they exist?
-- To apply functions in syntactically different ways

-- What is their precedence and associativity?
-- function application - left assoc, precedence 10 - https://stackoverflow.com/a/71032921
-- infixl 1 &amp;
-- infixr 0 $

-- What is partial application?

-- What functions can be applied partially?
-- Those having at least one argument

-- Why there are no function arguments with default values in Haskell?
-- Functions should be total in arguments

-- Sectioning:
-- What is section?
-- https://wiki.haskell.org/Section_of_an_infix_operator

-- Which functions could be used in sections?
-- Any infix

-- Could you use other than binary functions in sections?
-- Yes. Due to the right associativity of function type

f5 :: a -&gt; b -&gt; c -&gt; d
f5 = undefined
 where
  x = undefined :: a
  y = undefined :: b
  g = (x `f5`) y

-- Function application precedence:

-- What are the possible values for precedence in Haskell?
-- 1 - 9

-- What is associativity of operators?
-- It defines how to parenthesize the expressions using that operator
-- 3 * 4 * 5 -&gt; (3 * 4) * 5

-- How does it differ from associativity as a mathemathical property?
-- Mathematical associativity property states that for an operator *
-- (a * b) * c = a * (b * c)

-- Is the function application syntax associative? In other words, is (a b) c identical to a (b c)?
-- No

-- What are the possible values for associativity in Haskell?
-- infixl, infixr

-- Function composition:
-- How function composition operator is declared? What are its precedence and associativity?
-- infixr 9 .

f6 :: c -&gt; c
f6 = id . id

-- Is function composition mathematically associative?
-- Yes

f7 :: (c -&gt; d) -&gt; (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; d)
f7 x y z = n1
 where
  n1 = (x . y) . z
  n2 = x . (y . z)

-- What is a tail recursion?
-- It's when the recursive call is the last statement executed by the function

-- What is a tail call optimization?
-- Turn recursion into a loop

-- Can you give examples of functions with and without tail call optimization?
f8 :: (Eq t, Num t) =&gt; t -&gt; t
f8 0 = 0
f8 n = n + f8 (n - 1)

-- https://stackoverflow.com/a/13052612
f9 :: (Eq t, Num t) =&gt; t -&gt; t -&gt; t
f9 0 acc = acc
f9 n acc = f9 (n - 1) $! (acc + n)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reinterpreting-effects"><a class="header" href="#reinterpreting-effects">Reinterpreting effects</a></h1>
<p>This article assumes you are already familiar with <a href="haskell/developers-roadmap/FusedEffects/defining_effects.html">defining effects and their handlers</a>.</p>
<p>One of the nice aspects of effects is that they can support multiple effect handlers. Effects only specify actions, they don't actually perform them. Therefore, it's possible to &quot;reinterpret&quot; effects. There are multiple senses in which an effect can be reinterpreted:</p>
<ul>
<li>Implementing an effect in terms of other effects. &quot;Reinterpreting&quot; effects is a powerful tool for cleanly dividing implementations into the relevant abstraction layers with minimal leakage of implementation details.</li>
<li>Rewriting an effect and/or performing actions with the effect value and then performing the originally intended effect. This technique is conceptually similar to the middleware pattern commonly used in web applications. This known as <em>interposition</em> (see works by Oleg Kiselyov et al.)</li>
</ul>
<p>Let's explore both of these effect interpretation strategies with a small motivating example:</p>
<p>✨ We would like to implement a client library for an <a href="https://alexwohlbruck.github.io/cat-facts/docs/">HTTP-based API that provides interesting cat facts</a>. ✨</p>
<p>Let's break down some of the properties of the API client that would be desirable for a production use case:</p>
<ol>
<li>We would like to have our cat facts API be able to support different cat fact data sources in the future.</li>
<li>We would like to be able to mock failure conditions (such as network connectivity issues) for testing purposes.</li>
<li>We would like to be able to track timing metrics for how quickly we can retrieve cat facts.</li>
</ol>
<h2 id="initial-setup"><a class="header" href="#initial-setup">Initial setup</a></h2>
<!-- FOURMOLU_DISABLE -->
<pre><code class="language-haskell">{-# LANGUAGE ExistentialQuantification, FlexibleInstances, GADTs,
GeneralizedNewtypeDeriving, KindSignatures, OverloadedStrings, MultiParamTypeClasses,
RankNTypes, TypeApplications, TypeOperators, UndecidableInstances #-}
{-# LANGUAGE FlexibleContexts #-}
{-# OPTIONS_GHC -Wno-unused-top-binds #-}
module Try.FusedEffects.ReinterpretingEffects( main, main1, main2) where
-- from base
import Control.Applicative
import Data.Foldable (traverse_)
import Control.Exception (throwIO)
import Data.Kind (Type)
-- from fused-effects
import Control.Algebra
import Control.Carrier.Reader
import Control.Carrier.Error.Either
import Control.Carrier.Interpret
-- from transformers
import Control.Monad.IO.Class
-- From aeson
import Data.Aeson
-- From bytestring
import qualified Data.ByteString.Char8 as B
import qualified Data.ByteString.Lazy as L
-- From time
import Data.Time.Clock
-- From http-client
import qualified Network.HTTP.Client as HTTP
import Network.HTTP.Client.Internal (Response(..), ResponseClose(..))
-- From http-client-tls
import qualified Network.HTTP.Client.TLS as HTTP
-- From http-types
import Network.HTTP.Types
</code></pre>
<!-- FOURMOLU_ENABLE -->
<p>Since one of the best parts about effects is being able to think at a domain language level,let's start with defining the desired data which we wish to retrieve and an interface that feels natural to work with:</p>
<pre><code class="language-haskell">-- | The basic fact that we will retrieve.
newtype CatFact = CatFact
  { catFact :: String
  }
  deriving (Show)

instance FromJSON CatFact where
  parseJSON = withObject &quot;CatFact&quot; (\o -&gt; CatFact &lt;$&gt; o .: &quot;text&quot;)

-- | Our high level effect type that will be able to target different data sources.
data CatFactClient (m :: Type -&gt; Type) k where
  ListFacts ::
    -- | Number of facts to fetch
    Int -&gt;
    CatFactClient m [CatFact]

listFacts :: Has CatFactClient sig m =&gt; Int -&gt; m [CatFact]
listFacts n = send (ListFacts n)
</code></pre>
<p>Now that we have our very simple DSL in place, let's think about the underlying API: we know that it's an HTTP-based system, so let's introduce the notion of a handler that is provided a request and hands back an HTTP response.</p>
<pre><code class="language-haskell">data Http (m :: Type -&gt; Type) k where
  SendRequest :: HTTP.Request -&gt; Http m (HTTP.Response L.ByteString)

sendRequest :: Has Http sig m =&gt; HTTP.Request -&gt; m (HTTP.Response L.ByteString)
sendRequest r = send (SendRequest r)
</code></pre>
<p>The <code>listFacts</code> function provides the ‘what’ of this API, and the <code>sendRequest</code> function provides the ‘how’. In decomposing this problem into a set of effects, each responsible for a single layer of the original problem description, we provide ourselves with a flexible, composable vocabulary rather than a single monolithic action.</p>
<h2 id="stacking-effects"><a class="header" href="#stacking-effects">&quot;Stacking&quot; effects</a></h2>
<h3 id="the-production-use-case"><a class="header" href="#the-production-use-case">The production use-case</a></h3>
<p>Now that we have these two mini-DSL effect types established, we need to stitch them together.</p>
<p>Let's take a moment to think about what could go wrong with an HTTP API from which we plan to fetch some JSON and convert it into a list of <code>CatFact</code>s.</p>
<p>We can conceive that the server might occasionally return a malformed JSON response:</p>
<pre><code class="language-haskell">newtype JsonParseError = JsonParseError String
  deriving (Show, Eq)

decodeOrThrow :: (Has (Throw JsonParseError) sig m, FromJSON a) =&gt; L.ByteString -&gt; m a
decodeOrThrow = either (throwError . JsonParseError) pure . eitherDecode
</code></pre>
<p>A more HTTP-centric issue is that we might receive a content type we can't use. In this case, anything that's not <code>application/json</code>:</p>
<pre><code class="language-haskell">newtype InvalidContentType = InvalidContentType String
  deriving (Show, Eq)
</code></pre>
<p>Now we need to support fetching JSON given an HTTP request. We have no guarantee that an arbitrary HTTP request will actually return JSON, so for this implementation we have to account for failure conditions. This provides a great opportunity to see how effect handlers can actually rely on <em>multiple underlying effects</em>!</p>
<pre><code class="language-haskell">newtype CatFactsApi m a = CatFactsApi {runCatFactsApi :: m a}
  deriving
    ( Monad
    , Functor
    , Applicative
    , MonadIO
    , Alternative
    )

catFactsEndpoint :: HTTP.Request
catFactsEndpoint = HTTP.parseRequest_ &quot;https://cat-fact.herokuapp.com/facts/random&quot;

instance
  ( Has Http sig m
  , Has (Throw JsonParseError) sig m
  , Has (Throw InvalidContentType) sig m
  , Algebra sig m
  ) =&gt;
  Algebra (CatFactClient :+: sig) (CatFactsApi m)
  where
  alg hdl sig ctx = case sig of
    L (ListFacts numberOfFacts) -&gt; do
      resp &lt;- sendRequest (catFactsEndpoint{HTTP.queryString = &quot;?amount=&quot; &lt;&gt; B.pack (show numberOfFacts)})
      case lookup hContentType (HTTP.responseHeaders resp) of
        Just &quot;application/json; charset=utf-8&quot; -&gt; (&lt;$ ctx) &lt;$&gt; decodeOrThrow (HTTP.responseBody resp)
        other -&gt; throwError (InvalidContentType (show other))
    R other -&gt; CatFactsApi (alg (runCatFactsApi . hdl) other ctx)
</code></pre>
<p>We implement a <code>CatFacts</code> effect handler that depends on <em>three</em> underlying effects:</p>
<ol>
<li><code>Http</code> - we need to be able to make requests</li>
<li><code>Throw JsonParseError</code> - we need to be able to signal that some aspect of the JSON wasn't what we expected.</li>
<li><code>Throw InvalidContentType</code> - we need to be able to signal what we got wasn't JSON at all!</li>
</ol>
<p>The nice aspect of this is that we have neatly contained the failure scenarios to their relevant strata rather than leaking them into the higher-level abstraction (<code>listFacts</code>)!</p>
<p>Now we need to support performing HTTP requests:</p>
<pre><code class="language-haskell">newtype HttpClient m a = HttpClient {runHttp :: m a}
  deriving
    ( Monad
    , Functor
    , Applicative
    , MonadIO
    , Alternative
    )

instance (MonadIO m, Algebra sig m) =&gt; Algebra (Http :+: sig) (HttpClient m) where
  alg hdl sig ctx = case sig of
    L (SendRequest req) -&gt; (&lt;$ ctx) &lt;$&gt; liftIO (HTTP.getGlobalManager &gt;&gt;= HTTP.httpLbs req)
    R other -&gt; HttpClient (alg (runHttp . hdl) other ctx)
</code></pre>
<p>Note for the above code snippets how the <code>CatFactsApi</code> carrier delegates fetching JSON to any other effect that supports retrieving JSON given an HTTP request specification.</p>
<p>Note as well that <code>CatFactsApi</code> itself doesn't know how to perform an HTTP request. It delegates the request itself to a handler that implements the <code>Algebra</code> class for <code>(Http :+: sig)</code>.</p>
<p>Putting it all together for the actual production use case:</p>
<pre><code class="language-haskell">handlePrint :: Either InvalidContentType (Either JsonParseError [CatFact]) -&gt; IO ()
handlePrint r =
  case r of
    Left invalidContentTypeError -&gt; print invalidContentTypeError
    Right ok -&gt; case ok of
      Left jsonParseError -&gt; print jsonParseError
      Right facts -&gt; traverse_ (putStrLn . catFact) facts

catFactsRunner :: Has Http sig m =&gt; m (Either InvalidContentType (Either JsonParseError [CatFact]))
catFactsRunner =
  runError @InvalidContentType $
    runError @JsonParseError $
      runCatFactsApi $
        listFacts 10

main :: IO ()
main = runHttp catFactsRunner &gt;&gt;= handlePrint
</code></pre>
<p>Produces:</p>
<pre><code class="language-console">The Bengal is the result of crossbreeding between domestic cats and Asian leopard cats, and its name is derived from the scientific name for the Asian leopard cat (Felis bengalensis).
A happy cat holds her tail high and steady.
Kittens remain with their mother till the age of 9 weeks.
Recent studies have shown that cats can see blue and green. There is disagreement as to whether they can see red.
A steady diet of dog food may cause blindness in your cat - it lacks taurine.
Cat owners are 25% likely to pick George Harrison as their favorite Beatle.
The catnip plant contains an oil called hepetalactone which does for cats what marijuana does to some people. Not all cats react to it those that do appear to enter a trancelike state. A positive reaction takes the form of the cat sniffing the catnip, then licking, biting, chewing it, rub &amp; rolling on it repeatedly, purring, meowing &amp; even leaping in the air.
The color of the points in Siamese cats is heat related. Cool areas are darker.
Cats have free-floating clavicle bones that attach their shoulders to their forelimbs, which allows them to squeeze through very small spaces.
Wikipedia has a recording of a cat meowing, because why not?
</code></pre>
<h3 id="testing-with-alternative-effect-handlers"><a class="header" href="#testing-with-alternative-effect-handlers">Testing with alternative effect handlers</a></h3>
<p>Per point 2. of our initial implementation criteria, we want to be able to simulate failure cases for testing purposes. This is a great case for swapping in an alternative effect handler for our HTTP layer.</p>
<p>This time let's go from the bottom up. In situations where IO is involved, failure scenarios tend to surface from least-pure parts of code. In this case, we should therefore implement some facilities to experiment with the most failure-prone area: the network itself.</p>
<pre><code class="language-haskell">newtype MockHttpClient m a = MockHttpClient {runMockHttpClient :: ReaderC (HTTP.Request -&gt; IO (HTTP.Response L.ByteString)) m a}
  deriving
    ( Monad
    , Functor
    , Applicative
    , MonadIO
    , Alternative
    )

runMockHttp :: (HTTP.Request -&gt; IO (HTTP.Response L.ByteString)) -&gt; MockHttpClient m a -&gt; m a
runMockHttp responder m = runReader responder (runMockHttpClient m)

instance (MonadIO m, Algebra sig m) =&gt; Algebra (Http :+: sig) (MockHttpClient m) where
  alg hdl sig ctx = case sig of
    L (SendRequest req) -&gt; do
      responder &lt;- MockHttpClient ask
      (&lt;$ ctx) &lt;$&gt; liftIO (responder req)
    R other -&gt; MockHttpClient (alg (runMockHttpClient . hdl) (R other) ctx)

faultyNetwork :: HTTP.Request -&gt; IO (HTTP.Response L.ByteString)
faultyNetwork req = throwIO (HTTP.HttpExceptionRequest req HTTP.ConnectionTimeout)

wrongContentType :: HTTP.Request -&gt; IO (HTTP.Response L.ByteString)
wrongContentType req = pure resp
 where
  resp =
    Response
      { responseStatus = ok200
      , responseVersion = http11
      , responseHeaders = [(&quot;Content-Type&quot;, &quot;text/xml&quot;)]
      , responseBody = &quot;[{\&quot;text\&quot;: \&quot;Cats are not dogs\&quot;}]&quot;
      , responseCookieJar = mempty
      , responseClose' = ResponseClose (pure ())
      , responseOriginalRequest = req
      }

badJson :: HTTP.Request -&gt; IO (HTTP.Response L.ByteString)
badJson req =
  pure
    Response
      { responseStatus = ok200
      , responseVersion = http11
      , responseHeaders = [(&quot;Content-Type&quot;, &quot;application/json; charset=utf-8&quot;)]
      , responseBody = &quot;{}&quot;
      , responseCookieJar = mempty
      , responseClose' = ResponseClose (pure ())
      , responseOriginalRequest = req
      }
</code></pre>
<p>Let's update our <code>main</code> function and watch it in action:</p>
<pre><code class="language-haskell">main1 :: IO ()
main1 = do
  -- Should return JsonParseError
  runMockHttp badJson catFactsRunner &gt;&gt;= handlePrint
  -- Should return InvalidContentType
  runMockHttp wrongContentType catFactsRunner &gt;&gt;= handlePrint
</code></pre>
<p>Which returns:</p>
<pre><code class="language-haskell">JsonParseError &quot;Error in $: parsing [] failed, expected Array, but encountered Object&quot;
InvalidContentType &quot;Just \&quot;text/xml\&quot;&quot;
</code></pre>
<p>With effects, we have fine-grained ways of testing slices of our API. All that's needed to turn an integration test into a unit test or vice versa is a different set of <code>Algebra</code>-implementing effect handlers!</p>
<h2 id="observing--altering-effects"><a class="header" href="#observing--altering-effects">Observing &amp; altering effects</a></h2>
<p>Building new effect handling algebras can be a little bit verbose. In simpler situations, we may want to simply operate
on an effect without having to implement a whole new <code>Algebra</code> instance. We still have yet to build a solution to tracking
operational metrics (like request timings), so let's look at how to build a sort of &quot;effect middleware&quot; using <code>InterpretC</code>.</p>
<p><code>InterpretC</code> is an effect carrier that is intended for prototyping new effects that passes a callback function each
occurence of the specified effect type that is called via <code>send</code>. One trick that can be useful is to intercept an effect,
operate on the effect, and then re-<code>send</code> the effect (a.k.a. interposition). In other words, it's perfectly valid to have multiple handlers
for the same effect type and dispatch to the ones higher in the effect stack! Let's use this approach to time and log
our HTTP requests:</p>
<pre><code class="language-haskell">traceHttp ::
  (Has Http sig m, MonadIO m) =&gt;
  (forall s. Reifies s (Interpreter Http m) =&gt; InterpretC s Http m a) -&gt;
  m a
traceHttp = runInterpret $ \_ (SendRequest req) ctx -&gt; do
  startTime &lt;- liftIO getCurrentTime
  liftIO (putStr (B.unpack (HTTP.path req) ++ &quot; ... &quot;))
  -- Pass the request on to something that actually knows how to respond.
  resp &lt;- sendRequest req
  -- Once the actual response is obtained,
  -- we can capture the end time and status of the response.
  endTime &lt;- liftIO getCurrentTime
  let timeSpent = endTime `diffUTCTime` startTime
  liftIO $ putStrLn (&quot;[&quot; ++ show (statusCode $ HTTP.responseStatus resp) ++ &quot;] took &quot; ++ show timeSpent ++ &quot;\n\n&quot;)
  pure (resp &lt;$ ctx)
</code></pre>
<p>Updating our <code>main</code> function once more:</p>
<pre><code class="language-haskell">main2 :: IO ()
main2 = runHttp (traceHttp catFactsRunner) &gt;&gt;= handlePrint
</code></pre>
<p>Returns:</p>
<pre><code class="language-console">/facts/random ... [200] took 0.979107082s

Cats have a special scent organ located in the roof of their mouth, called the Jacobson's organ. It analyzes smells - and is the reason why you will sometimes see your cat &quot;sneer&quot; (called the flehmen response or flehming) when they encounter a strong odor.
It's important for cats to have regular ear exams—this is something you can do at home! Gently fold back the ears and look into the ear canal. The inner ear should be pale pink with little to no earwax. If you notice redness, swelling, discharge, or a lot of earwax, it's time to see a veterinarian.
Siamese kittens are born white because of the heat inside the mother's uterus before birth. This heat keeps the kittens' hair from darkening on the points.
Declawing a cat is the same as cutting a human's fingers off at the knuckle. There are several alternatives to a complete declawing, including trimming or a less radical (though more involved) surgery to remove the claws. Instead, train your cat to use a scratching post.
There is a species of cat smaller than the average housecat. It is native to Africa and it is the Black-footed cat (Felis nigripes). Its top weight is 5.5 pounds.
Gatos.
Cats are the most interesting mammals on earth.
Cats have free-floating clavicle bones that attach their shoulders to their forelimbs, which allows them to squeeze through very small spaces.
Fossil records from two million years ago show evidence of jaguars.
Since cats are so good at hiding illness, even a single instance of a symptom should be taken very seriously.
</code></pre>
<h3 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h3>
<p>Reviewing our initial criteria, we have an eminently extensible system that lets us maintain a healthy separation of concerns–
All while still allowing non-invasive behavior changes through the ability to intercept, rewrite, and resend effects!</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
We would like to have our cat facts API be able to support different cat fact data sources in the future.</li>
<li><input disabled="" type="checkbox" checked=""/>
We would like to be able to mock failure conditions (such as network connectivity issues) for testing purposes.</li>
<li><input disabled="" type="checkbox" checked=""/>
We would like to be able to track timing metrics for how quickly we can retrieve cat facts.</li>
</ul>
<p><img src="https://media.giphy.com/media/l6Td5sKDNmDGU/giphy.gif" alt="Mission accomplished" /></p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE BlockArguments #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE UndecidableInstances #-}
{-# OPTIONS_GHC -Wno-unused-top-binds #-}

module Try.FusedEffects.UndoIO (
  main1,
  main,
) where

import Control.Algebra (Algebra (alg), send, type (:+:) (L, R))
import Control.Applicative (Alternative)
import Control.Carrier.Error.Either (Catch, Has, Throw, catchError, runError, throwError)
import Control.Carrier.Fail.Either qualified as Fail
import Control.Carrier.Lift (sendM)
import Control.Carrier.State.Strict (StateC (..), runState)
import Control.Effect.Exception (Lift, bracket, try)
import Control.Exception.Lifted qualified as CL (bracket, catch, try)
import Control.Monad (MonadPlus, replicateM_)
import Control.Monad.Catch (MonadCatch, MonadMask, MonadThrow)
import Control.Monad.Catch qualified as CE
import Control.Monad.Except (runExceptT)
import Control.Monad.Fix (MonadFix)
import Control.Monad.IO.Class (MonadIO (..))
import Control.Monad.State.Strict (MonadTrans (..))
import Control.Monad.Trans.Control (MonadBaseControl)
import Control.Monad.Trans.Except (ExceptT)
import Control.Monad.Trans.Writer (WriterT (..))
import Control.Monad.Trans.Writer qualified as W (WriterT)
import Control.Monad.Writer.Class qualified as WC (MonadWriter, tell)
import Data.Data (Typeable)
import Data.Foldable (sequenceA_)
import Data.Functor (($&gt;))
import Data.Functor.Identity (Identity (..))
import Data.Kind (Type)

data WriterStack w (m :: Type -&gt; Type) k where
  Tell :: w -&gt; WriterStack w m ()
  Listen :: m a -&gt; WriterStack w m (w, a)
  Censor :: (w -&gt; w) -&gt; m a -&gt; WriterStack w m a

tell :: forall w m sig. Has (WriterStack w) sig m =&gt; w -&gt; m ()
tell = send . Tell

listen :: Has (WriterStack w) sig m =&gt; m a -&gt; m (w, a)
listen = send . Listen

censor :: Has (WriterStack w) sig m =&gt; (w -&gt; w) -&gt; m a -&gt; m a
censor f = send . Censor f

newtype WriterStackC w m a = WriterStackC {runWriterStackC :: StateC w m a}
  deriving (Alternative, Applicative, Functor, Monad, Fail.MonadFail, MonadFix, MonadIO, MonadPlus, MonadTrans)

runWriterStack :: forall w a m. Monoid w =&gt; WriterStackC w m a -&gt; m (w, a)
runWriterStack (WriterStackC m) = runState mempty m

execWriterStack :: forall w a m. (Monoid w, Functor m) =&gt; WriterStackC w m a -&gt; m w
execWriterStack = fmap fst . runWriterStack

instance (Monoid w, Algebra sig m) =&gt; Algebra (WriterStack w :+: sig) (WriterStackC w m) where
  alg hdl sig ctx =
    -- this is just to observe the type of hdl
    let hdl1 = hdl
     in WriterStackC $ case sig of
          L writer -&gt; StateC $ \w -&gt; case writer of
            Tell w1 -&gt; do
              let !w2 = w1 &lt;&gt; w
              return (w2, ctx)
            Listen m -&gt; do
              (w1, a) &lt;- runWriterStack (hdl (m &lt;$ ctx))
              let !w2 = w1 &lt;&gt; w
              return (w2, (w1,) &lt;$&gt; a)
            Censor f m -&gt; do
              (w1, a) &lt;- runWriterStack (hdl (m &lt;$ ctx))
              let !w2 = f w1 &lt;&gt; w
              return (w2, a)
          R other -&gt; alg (runWriterStackC . hdl) (R other) ctx

tell1 :: (Has (WriterStack [a]) sig m) =&gt; a -&gt; m ()
tell1 a = tell [a]

l :: [Int]
l = (4 :: Int) &lt;$ ([3, 2, 5] :: [Int]) $&gt; 5

-- &gt;&gt;&gt; l
-- [5,5,5]

type Log = [Int]

sl2 :: Log
sl2 = take 5 $
  (runIdentity . execWriterStack) do
    replicateM_ 1000000 (let !a = tell ([3] :: [Int]) in a)

-- &gt;&gt;&gt; s2
-- [3,3,3,3,3]

someActions :: forall m sig. (MonadIO m, Has (WriterStack [Int]) sig m, Has (WriterStack [IO ()]) sig m) =&gt; m ()
someActions = do
  tell @[Int] [1, 2]
  tell @[IO ()] [putStr &quot;world!\n&quot;]
  tell @[IO ()] [putStr &quot;Hello, &quot;]

main1 :: IO ()
main1 = do
  s &lt;- (fst &lt;$&gt;) $ runWriterStack @[IO ()] . runWriterStack @[Int] @() $ someActions
  sequenceA_ s

main :: IO ()
main = print &quot;Hello, world!&quot;
</code></pre>
<h2 id="writer-and-exceptions"><a class="header" href="#writer-and-exceptions">Writer and exceptions</a></h2>
<h3 id="using-lift-io"><a class="header" href="#using-lift-io">Using <code>Lift IO</code></a></h3>
<pre><code class="language-haskell">data FileError = WriteError FilePath | ReadError FilePath deriving (Typeable, Show)

instance CE.Exception FileError

someActions1 :: forall m sig. (Has (Lift IO) sig m, Has (Throw FileError) sig m, Has (Catch FileError) sig m, Has (WriterStack [IO ()]) sig m) =&gt; m ()
someActions1 = flip catchError (\(_ :: FileError) -&gt; tell @[IO ()] [putStr &quot;Not hello, &quot;]) do
  tell @[IO ()] [putStr &quot;world!\n&quot;]
  _ :: Either CE.SomeException () &lt;-
    try $
      bracket
        (sendM $ readFile &quot;SomeFile&quot;)
        (\_ -&gt; tell @[IO ()] [print &quot;File is here!&quot;])
        (\_ -&gt; tell @[IO ()] [print &quot;File is not here!&quot;])
  _ &lt;- throwError $ ReadError &quot;No such file&quot;
  tell @[IO ()] [putStr &quot;Hello, &quot;]

main2 :: IO ()
main2 = do
  s &lt;- (fst &lt;$&gt;) $ runWriterStack @[IO ()] . runError @FileError $ someActions1
  sequenceA_ s

main3 :: IO ()
main3 = do
  s &lt;- runError @FileError . runWriterStack @[IO ()] $ someActions1
  case s of
    Left x -&gt; print x
    Right (x, _) -&gt; sequenceA_ x
</code></pre>
<h2 id="trying-mtl-stack"><a class="header" href="#trying-mtl-stack">Trying <code>mtl</code> stack</a></h2>
<p>Still, Writer's log doesn't go into handlers</p>
<pre><code class="language-haskell">newtype MyStack e w a = MyStack {runMyStack :: ExceptT e (W.WriterT w IO) a}
  deriving (Functor, Applicative, Monad, WC.MonadWriter w, MonadIO, MonadMask, MonadCatch, MonadThrow)

someActions2 :: MyStack FileError [IO ()] ()
someActions2 = flip CE.catch (\(_ :: FileError) -&gt; WC.tell [putStr &quot;Not hello, &quot;]) do
  WC.tell [putStr &quot;world!\n&quot;]
  _ :: Either CE.SomeException () &lt;-
    CE.try $
      CE.bracket
        (liftIO $ readFile &quot;SomeFile&quot;)
        (\_ -&gt; WC.tell [putStr &quot;File is here!&quot;])
        (\_ -&gt; WC.tell [putStr &quot;File is not here!&quot;])
  _ &lt;- CE.throwM $ ReadError &quot;No such file&quot;
  WC.tell [putStr &quot;Hello, &quot;]
  return ()

main4 :: IO ()
main4 = do
  s &lt;- (snd &lt;$&gt;) $ runWriterT . runExceptT . runMyStack $ someActions2
  sequenceA_ s
</code></pre>
<h3 id="trying-lifted-base"><a class="header" href="#trying-lifted-base">Trying lifted-base</a></h3>
<pre><code class="language-haskell">someActions3 :: forall m sig. (MonadBaseControl IO m, Has (Lift IO) sig m, Has (Throw FileError) sig m, Has (WriterStack [IO ()]) sig m) =&gt; m ()
someActions3 = flip CL.catch (\(_ :: FileError) -&gt; tell @[IO ()] [putStr &quot;Not hello, &quot;]) do
  tell @[IO ()] [putStr &quot;world!\n&quot;]
  _ :: Either CE.SomeException () &lt;-
    CL.try $
      CL.bracket
        (sendM $ readFile &quot;SomeFile&quot;)
        (\_ -&gt; tell @[IO ()] [print &quot;File is here!&quot;])
        (\_ -&gt; tell @[IO ()] [print &quot;File is not here!&quot;])
  _ &lt;- throwError $ ReadError &quot;No such file&quot;
  tell @[IO ()] [putStr &quot;Hello, &quot;]

-- main5 :: IO ()
-- main5 = do
--   s &lt;- (fst &lt;$&gt;) $ runWriterStack @[IO ()] . runError @FileError $ someActions3
--   sequenceA_ s

increment :: Int -&gt; Int
increment x = x + 1

wrappedInt :: Maybe Int
wrappedInt = Just 3

wrappedIncrement :: Maybe (Int -&gt; Int)
wrappedIncrement = Just increment

s1 :: (Int -&gt; Int) -&gt; (Maybe Int -&gt; Maybe Int)
s1 = fmap

s1' :: (Int -&gt; Int) -&gt; (Maybe Int -&gt; Maybe Int)
s1' = undefined

s2 :: Maybe (Int -&gt; Int) -&gt; (Maybe Int -&gt; Maybe Int)
s2 = (&lt;*&gt;)

s2' :: Maybe (Int -&gt; Int) -&gt; (Maybe Int -&gt; Maybe Int)
s2' = undefined

wrappingIncrement :: Int -&gt; Maybe Int
wrappingIncrement x = Just (increment x)

s3 :: Int -&gt; Maybe Int
s3 = pure

s3' :: Int -&gt; Maybe Int
s3' = undefined

s4 :: Maybe Int -&gt; (Int -&gt; Maybe Int) -&gt; Maybe Int
s4 = (&gt;&gt;=)

s4' :: Maybe Int -&gt; (Int -&gt; Maybe Int) -&gt; Maybe Int
s4' = undefined
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeFamilyDependencies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE UndecidableInstances #-}

module Try.GADT.GADT where
</code></pre>
<h2 id="gadts"><a class="header" href="#gadts">GADTs</a></h2>
<ul>
<li>
<p>Wikibooks (<a href="https://en.wikibooks.org/wiki/Haskell/GADT">src</a>):</p>
<blockquote>
<p>With GADTs, a constructor for <code>Foo</code> a is not obliged to return <code>Foo a</code>; it can return any <code>Foo blah</code> that you can think of.</p>
</blockquote>
<!-- i 4 -->
<pre><code class="language-haskell">data TrueGadtFoo a where
  MkTrueGadtFoo :: a -&gt; TrueGadtFoo Int
</code></pre>
<ul>
<li>
<p>Still, need to use a relevant data constructor</p>
<pre><code class="language-hs">data Foo where
  MkFoo :: Bar Int -- This will not typecheck
</code></pre>
</li>
</ul>
</li>
<li>
<p>Support record syntax - <a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/gadt.html">src</a></p>
<ul>
<li><a href="https://hackage.haskell.org/package/servant-server-0.19.2/docs/src/Servant.Server.Internal.Delayed.html#Delayed">example</a></li>
</ul>
</li>
<li>
<p>Is it considered a good practice to put constraints in consructors inside GADT declaration?</p>
<ul>
<li>No. Use a compiler to derive instances like <code>Functor</code>, put constraints in functions.</li>
</ul>
</li>
</ul>
<h2 id="heterogeneous-list"><a class="header" href="#heterogeneous-list">Heterogeneous list</a></h2>
<p><a href="https://www.parsonsmatt.org/2017/04/26/basic_type_level_programming_in_haskell.html#heterogeneous-lists">src</a></p>
<!-- d -->
<pre><code class="language-haskell">data HList_ xs where
  HNil_ :: HList_ '[]
  (:::) :: a -&gt; HList_ as -&gt; HList_ (a ': as)

infixr 6 :::

hex :: HList_ '[Char, Integer, String]
hex = 'a' ::: 1 ::: &quot;hello&quot; ::: HNil_
</code></pre>
<h2 id="non-empty-list"><a class="header" href="#non-empty-list">Non-empty list</a></h2>
<pre><code class="language-haskell">data Empty
data NonEmpty

data SafeList a b where
  Nil :: SafeList a Empty
  Cons :: a -&gt; SafeList a b -&gt; SafeList a NonEmpty

safeHead :: SafeList a NonEmpty -&gt; a
safeHead (Cons a _) = a

safeTail :: SafeList a b -&gt; a
safeTail (Cons a Nil) = a
safeTail (Cons _ b) = safeTail b

st1 :: Integer
st1 = safeTail $ Cons 3 (Cons 4 Nil)

-- &gt;&gt;&gt;st1
-- 4
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE ImpredicativeTypes #-}

module Try.Generics.Generics () where

import Data.Kind (Type)
import GHC.Generics (Generic, Rep)

data Tree a = Leaf a | Node (Tree a) (Tree a)
  deriving (Generic)

-- &gt;&gt;&gt;:kind! forall a. Rep (Tree a)
-- forall a. Rep (Tree a) :: * -&gt; *
-- = M1
--     D
--     ('MetaData &quot;Tree&quot; &quot;TryGenerics&quot; &quot;main&quot; 'False)
--     (M1
--        C
--        ('MetaCons &quot;Leaf&quot; 'PrefixI 'False)
--        (M1
--           S
--           ('MetaSel
--              'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
--           (K1 R a))
--      :+: M1
--            C
--            ('MetaCons &quot;Node&quot; 'PrefixI 'False)
--            (M1
--               S
--               ('MetaSel
--                  'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
--               (K1 R (Tree a))
--             :*: M1
--                   S
--                   ('MetaSel
--                      'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
--                   (K1 R (Tree a))))

-- no generic instance
data Empty1

-- &gt;&gt;&gt;:kind! Rep Empty1
-- Rep Empty1 :: * -&gt; *
-- = Rep Empty1

-- has generic instance
data Empty2 deriving (Generic)

-- &gt;&gt;&gt;:kind! Rep Empty2
-- Rep Empty2 :: * -&gt; *
-- = M1 D ('MetaData &quot;Empty2&quot; &quot;TryGenerics&quot; &quot;main&quot; 'False) V1

-- &gt;&gt;&gt;:kind! Rep Bool
-- Rep Bool :: * -&gt; *
-- = M1
--     D
--     ('MetaData &quot;Bool&quot; &quot;GHC.Types&quot; &quot;ghc-prim&quot; 'False)
--     (M1 C ('MetaCons &quot;False&quot; 'PrefixI 'False) U1
--      :+: M1 C ('MetaCons &quot;True&quot; 'PrefixI 'False) U1)
</code></pre>
<p><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Generics.html#g:9">Representation of types with many constructors or many fields</a></p>
<pre><code class="language-haskell">data ManyFields a b c d e f g h i = A1 a b c d e f g h i deriving (Generic)

-- &gt;&gt;&gt;:kind! forall a b c d e f g h i. Rep (ManyFields a b c d e f g h i)
-- forall a b c d e f g h i. Rep (ManyFields a b c d e f g h i) :: *
--                                                                 -&gt; *
-- = M1
--     D
--     ('MetaData &quot;ManyFields&quot; &quot;Try.Generics&quot; &quot;main&quot; 'False)
--     (M1
--        C
--        ('MetaCons &quot;A1&quot; 'PrefixI 'False)
--        (((M1
--             S
--             ('MetaSel
--                'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
--             (K1 R a)
--           :*: M1
--                 S
--                 ('MetaSel
--                    'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
--                 (K1 R b))
--          :*: (M1
--                 S
--                 ('MetaSel
--                    'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
--                 (K1 R c)
--               :*: M1
--                     S
--                     ('MetaSel
--                        'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
--                     (K1 R d)))
--         :*: ((M1
--                 S
--                 ('MetaSel
--                    'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
--                 (K1 R e)
--               :*: M1
--                     S
--                     ('MetaSel
--                        'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
--                     (K1 R f))
--              :*: (M1
--                     S
--                     ('MetaSel
--                        'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
--                     (K1 R g)
--                   :*: (M1
--                          S
--                          ('MetaSel
--                             'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
--                          (K1 R h)
--                        :*: M1
--                              S
--                              ('MetaSel
--                                 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
--                              (K1 R i))))))

data ManyConstructors = B1 | C1 | D1 | E1 | F1 | G1 | H1 | I1 | J deriving (Generic)

-- &gt;&gt;&gt;:kind! Rep ManyConstructors
-- Rep ManyConstructors :: * -&gt; *
-- = M1
--     D
--     ('MetaData &quot;ManyConstructors&quot; &quot;Try.Generics&quot; &quot;main&quot; 'False)
--     (((M1 C ('MetaCons &quot;B1&quot; 'PrefixI 'False) U1
--        :+: M1 C ('MetaCons &quot;C1&quot; 'PrefixI 'False) U1)
--       :+: (M1 C ('MetaCons &quot;D1&quot; 'PrefixI 'False) U1
--            :+: M1 C ('MetaCons &quot;E1&quot; 'PrefixI 'False) U1))
--      :+: ((M1 C ('MetaCons &quot;F1&quot; 'PrefixI 'False) U1
--            :+: M1 C ('MetaCons &quot;G1&quot; 'PrefixI 'False) U1)
--           :+: (M1 C ('MetaCons &quot;H1&quot; 'PrefixI 'False) U1
--                :+: (M1 C ('MetaCons &quot;I1&quot; 'PrefixI 'False) U1
--                     :+: M1 C ('MetaCons &quot;J&quot; 'PrefixI 'False) U1))))
</code></pre>
<h2 id="defining-datatype-generic-functions"><a class="header" href="#defining-datatype-generic-functions">Defining datatype-generic functions</a></h2>
<p>https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Generics.html#g:10</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TupleSections #-}
{-# OPTIONS_GHC -Wno-unused-top-binds #-}

module Try.IO.RandomNumbers (main) where

import Control.Monad.Fix (fix)
import Data.Binary (decode, encode)
import Data.ByteString qualified as BS
import Data.ByteString.Builder (intDec, toLazyByteString)
import Data.ByteString.Char8 qualified as BSC
import Data.ByteString.Lazy qualified as LBS
import Data.ByteString.Lazy.Char8 qualified as LBSC
import Data.Foldable (Foldable (..))
import Data.Function ((&amp;))
import Data.Functor ((&lt;&amp;&gt;))
import Data.HashMap.Strict qualified as M
import GHC.IO.Handle.FD (withFile)
import GHC.IO.IOMode (IOMode (..))
import System.Random (newStdGen)
import System.Random.Stateful (Random (..))

nNumbers :: Int
nNumbers = 70 * 1024 * 1024

fname :: FilePath
fname = &quot;tmp/file-1&quot;

bounds :: (Int, Int)
bounds = (1, 10000)

-- | write generated numbers into a file
writeNumbers :: IO ()
writeNumbers = do
  print &quot;generating numbers&quot;
  g &lt;- newStdGen
  let randomStream :: [Int] = randomRs bounds g
  LBS.writeFile fname $ LBSC.unwords (toLazyByteString . intDec &lt;$&gt; take nNumbers randomStream)

kb :: Int
kb = 1024

chunkSize :: Int
chunkSize = 16 * kb

type MyState = (M.HashMap Int Int, LBS.ByteString)

-- | count numbers while reading the file in fixed chunks
-- and inserting them into a map in one go
countNumbersChunks :: IO ()
countNumbersChunks = do
  print &quot;counting numbers (chunks)&quot;
  print . sum . fst
    =&lt;&lt; withFile
      fname
      ReadMode
      ( \h -&gt; do
          fix
            ( \(ret :: MyState -&gt; IO MyState) statePrev@(!quantities, unparsed) -&gt; do
                chunk_ &lt;- LBS.hGet h chunkSize
                let
                  newChunk = unparsed &lt;&gt; chunk_
                  stateNew =
                    foldl'
                      ( \(!qs, !unparsed_) (!y) -&gt;
                          maybe
                            (qs, y)
                            (\(x_, _) -&gt; (M.insertWith (+) x_ 1 qs, &quot;&quot;))
                            (LBSC.readInt y)
                      )
                      statePrev
                      (LBSC.words newChunk)

                (if LBS.null chunk_ then return else ret) stateNew
            )
            (M.empty, &quot;&quot;)
      )

-- | count numbers using lazy bytestring's @readFile@
countNumbersReadFile :: IO ()
countNumbersReadFile = do
  print &quot;counting numbers (readFile)&quot;
  print
    . sum
    . M.fromListWith (+)
    . fmap (maybe undefined ((,1) . fst) . LBSC.readInt)
    . LBSC.words
    =&lt;&lt; LBS.readFile fname

main :: IO ()
main = do
  countNumbersChunks
</code></pre>
<p>Trying serialization</p>
<pre><code class="language-haskell">nums :: [Int]
nums = [1, 3, 4, 4, 5, 2, 5]

-- binary &lt;= 0.8.9.1
-- binary isn't human-readable

s :: [Int]
s = decode . encode $ [1 :: Int, 2, 3]

-- &gt;&gt;&gt; s
-- [1,2,3]

-- bytestring

tryConvertLBS' :: [Maybe (Int, LBSC.ByteString)]
tryConvertLBS' = LBSC.readInt &lt;$&gt; LBSC.words (LBSC.unwords (toLazyByteString . intDec &lt;$&gt; nums))

-- &gt;&gt;&gt; tryConvertLBS'
-- [Just (1,&quot;&quot;),Just (3,&quot;&quot;),Just (4,&quot;&quot;),Just (4,&quot;&quot;),Just (5,&quot;&quot;),Just (2,&quot;&quot;),Just (5,&quot;&quot;)]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# LANGUAGE ImplicitParams #-}

module Try.ImplicitParams.ImplicitParams where

data C

f :: Bool -&gt; C
f = undefined

-- так задаем
x :: C
x = let ?a = True; ?b = False in y

-- так используем
y :: (?b :: Bool, ?a :: Bool) =&gt; C
y = f ?a
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# LANGUAGE ConstrainedClassMethods #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}

module Try.Lens.MissingKey where

import Control.Lens
import Data.Map
import qualified Data.Map as Map
import GHC.Generics (Generic)

mp1 :: Map.Map String (Map.Map String Int)
mp1 = Map.fromList [(&quot;a&quot;, Map.fromList [(&quot;c&quot;, 3), (&quot;d&quot;, 5)])]

t = mp1 ^? ix &quot;a&quot; . ix &quot;d&quot;

-- &gt;&gt;&gt; t
-- Just 5

class Ixed m =&gt; PathIxed m where
  pat :: Index m -&gt; Prism' ([Index m], Maybe m) (([Index m], Maybe (IxValue m)), m)
  pat' :: (PathIxed m, Applicative f, s ~ ([Index m], Maybe (IxValue m)), a ~ ([Index m], Maybe m)) =&gt; Index m -&gt; (s -&gt; f s) -&gt; (a -&gt; f a)
  pat' x = pat x . _1

instance Ord a =&gt; PathIxed (Map a b) where
  pat p = prism embed match
   where
    embed :: (([a], Maybe b), Map a b) -&gt; ([a], Maybe (Map a b))
    embed ((path, v), parent) = (path &lt;&gt; [p], v &gt;&gt;= \v' -&gt; pure (Map.insert p v' parent))

    match :: ([a], Maybe (Map a b)) -&gt; Either ([a], Maybe (Map a b)) (([a], Maybe b), Map a b)
    match (path, m) =
      case m of
        Nothing -&gt; Left (path &lt;&gt; [p], Nothing)
        Just m' -&gt;
          case Map.lookup p m' of
            Nothing -&gt; Left (path &lt;&gt; [p], Nothing)
            Just p' -&gt; Right ((path &lt;&gt; [p], Just p'), m')

t1 = ([], Just mp1) ^? pat' &quot;a&quot; . pat' &quot;c&quot;

-- &gt;&gt;&gt; t1
-- Just ([&quot;a&quot;,&quot;c&quot;],Just 3)

t2 = matching' (pat' &quot;c&quot;) ([], Just mp1)

-- &gt;&gt;&gt; t2
-- Left ([&quot;c&quot;],Nothing)

t3 = matching' (pat' &quot;c&quot; . pat' &quot;d&quot;) ([], Just mp1)

-- &gt;&gt;&gt; t3
-- Left ([&quot;c&quot;],Nothing)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# LANGUAGE ApplicativeDo #-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE OverloadedLabels #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}

module Try.Lens.Node where

import Control.Lens (Iso, Iso', Plated, cosmos, filtered, has, ifiltered, indexing, iso, only, reversed, taking, traverseOf, traversed, (&amp;), (&lt;&amp;&gt;), (&lt;.), (^.), (^..), (^@..))
import Control.Lens.Plated (Plated (plate))
import Data.Data (Data)
import Data.Generics.Labels ()
import GHC.Generics (Generic)

data Node f a = Node
  { nodeData :: a
  , nodeName :: String
  , nodeChildren :: [Node f a]
  }
  deriving stock (Data, Generic)

tree :: Node f Int
tree =
  Node
    { nodeData = 3
    , nodeName = &quot;1&quot;
    , nodeChildren =
        [ Node
            { nodeData = 4
            , nodeName = &quot;2&quot;
            , nodeChildren =
                [ Node{nodeData = 5, nodeName = &quot;1&quot;, nodeChildren = []}
                ]
            }
        , Node
            { nodeData = 6
            , nodeName = &quot;1&quot;
            , nodeChildren =
                [ Node
                    { nodeData = 7
                    , nodeName = &quot;2&quot;
                    , nodeChildren =
                        [ Node{nodeData = 8, nodeName = &quot;3&quot;, nodeChildren = []}
                        ]
                    }
                ]
            }
        ]
    }

changeTraversalOrderTo :: forall t2 t1 a. Iso' (Node t1 a) (Node t2 a)
changeTraversalOrderTo = iso change change
 where
  change Node{..} = Node{nodeChildren = nodeChildren ^.. traversed . changeTraversalOrderTo, ..}

ex :: forall f. Plated (Node f Int) =&gt; Node f Int -&gt; [(Int, Int)]
ex tree = tree ^@.. changeTraversalOrderTo @f . indexing cosmos &lt;. filtered (has (#nodeName . only &quot;1&quot;)) . #nodeData

data InOrder

instance Plated (Node InOrder a) where
  plate f Node{..} = do
    nodeChildren &lt;- traverse f nodeChildren
    pure Node{..}

-- &gt;&gt;&gt; ex @InOrder tree
-- [(0,3),(2,5),(3,6)]

data WeirdOrder

instance (Num a, Ord a) =&gt; Plated (Node WeirdOrder a) where
  plate f Node{..} = do
    nodeChildren &lt;- traverseOf (\a b -&gt; (&lt;&gt;) &lt;$&gt; (traversed . ifiltered (\i v -&gt; odd i &amp;&amp; nodeData &lt;= 4)) a b &lt;*&gt; traversed a b) f nodeChildren
    pure $ Node{..}

-- &gt;&gt;&gt; ex @WeirdOrder tree
-- [(0,3),(1,6),(5,5),(6,6)]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">module Try.Misc.Determinant where

import Data.Matrix (Matrix, detLU, matrix)

m1 :: Matrix Double
m1 = matrix 3 3 (\(a, b) -&gt; fromIntegral (a ^ b))

-- &gt;&gt;&gt; m1
-- ┌                ┐
-- │  1.0  1.0  1.0 │
-- │  2.0  4.0  8.0 │
-- │  3.0  9.0 27.0 │
-- └                ┘

det :: Double
det = detLU m1

-- &gt;&gt;&gt; det
-- 12.0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE InstanceSigs #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE TypeApplications #-}

module Try.Monads.FunctionalDependencies where

import Data.Functor ((&lt;&amp;&gt;))

-- Fundeps exercise - https://www.fpcomplete.com/haskell/tutorial/fundeps/#exercises

newtype PersonReader a = PersonReader {runPersonReader :: Person -&gt; a}
  deriving (Functor, Applicative, Monad)

class Monad m =&gt; MonadReader env m | m -&gt; env where
  ask :: m env

data Person = Person
  { nameP :: String
  , ageP :: Int
  }
  deriving (Show)

askAge :: MonadReader Person m =&gt; m Int
askAge = ask &lt;&amp;&gt; ageP

askName :: MonadReader Person m =&gt; m String
askName = ask &lt;&amp;&gt; nameP

greeting :: forall m. (Monad m, MonadReader Person m) =&gt; m String
greeting = do
  name &lt;- askName
  age &lt;- askAge
  pure $ name ++ &quot; is &quot; ++ show age ++ &quot; years old&quot;

instance MonadReader Person PersonReader where
  ask :: PersonReader Person
  ask = PersonReader id

greetingId :: String
greetingId = runPersonReader (greeting @PersonReader) Person{nameP = &quot;ah&quot;, ageP = 3}

-- &gt;&gt;&gt;greetingId
-- &quot;ah is 3 years old&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE TupleSections #-}
{-# HLINT ignore &quot;Use gets&quot; #-}
{-# HLINT ignore &quot;Use asks&quot; #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE UndecidableInstances #-}
{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}

module Try.Monads.MonadBaseControl where

import Control.Monad.Base (MonadBase)
import Control.Monad.Reader (MonadReader (ask), ReaderT (runReaderT))
import Control.Monad.State (MonadState (get, put), MonadTrans (lift), StateT (runStateT))
import Control.Monad.Trans.Writer
import Data.Functor ((&lt;&amp;&gt;))
</code></pre>
<p>https://lexi-lambda.github.io/blog/2019/09/07/demystifying-monadbasecontrol/</p>
<h2 id="the-essence-of-monadbasecontrol"><a class="header" href="#the-essence-of-monadbasecontrol">The essence of MonadBaseControl</a></h2>
<ul>
<li>Capture the action’s input state and close over it.</li>
<li>Package up the action’s output state with its result and run it.</li>
<li>Restore the action’s output state into the enclosing transformer.</li>
<li>Return the action’s result.</li>
</ul>
<pre><code class="language-haskell">class MonadBase b m =&gt; MonadBaseControl b m | m -&gt; b where
  type InputState m
  type OutputState m
  captureInputState :: m (InputState m)

  -- run monad with an input state and return a result and the output state in another monad
  -- we have access to the result of the first monad
  closeOverInputState :: m a -&gt; InputState m -&gt; b (a, OutputState m)
  restoreOutputState :: OutputState m -&gt; m ()

instance MonadBaseControl IO IO where
  type InputState IO = ()
  type OutputState IO = ()
  captureInputState = pure ()
  closeOverInputState m () = m &lt;&amp;&gt; (,())
  restoreOutputState () = pure ()

instance MonadBaseControl b m =&gt; MonadBaseControl b (StateT s m) where
  type InputState (StateT s m) = (s, InputState m)
  type OutputState (StateT s m) = (s, OutputState m)
  captureInputState = (,) &lt;$&gt; get &lt;*&gt; lift captureInputState
  closeOverInputState m (s, ss) = do
    ((v, s'), ss') &lt;- closeOverInputState (runStateT m s) ss
    pure (v, (s', ss'))
  restoreOutputState (s, ss) = lift (restoreOutputState ss) *&gt; put s

instance MonadBaseControl b m =&gt; MonadBaseControl b (ReaderT r m) where
  type InputState (ReaderT r m) = (r, InputState m)
  type OutputState (ReaderT r m) = OutputState m
  captureInputState = (,) &lt;$&gt; ask &lt;*&gt; lift captureInputState
  closeOverInputState m (r, s) = closeOverInputState (runReaderT m r) s
  restoreOutputState s = lift (restoreOutputState s)

instance (MonadBaseControl b m, Monoid w) =&gt; MonadBaseControl b (WriterT w m) where
  type InputState (WriterT w m) = InputState m
  type OutputState (WriterT w m) = (w, OutputState m)
  captureInputState = lift captureInputState
  closeOverInputState m ss = do
    ((v, s'), ss') &lt;- closeOverInputState (runWriterT m) ss
    pure (v, (s', ss'))
  restoreOutputState (s, ss) = lift (restoreOutputState ss) *&gt; tell s
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# LANGUAGE BlockArguments #-}
{-# HLINT ignore &quot;Use newtype instead of data&quot; #-}
</code></pre>
<!-- LIMA_ENABLE -->
<pre><code class="language-haskell">{-# LANGUAGE DeriveFunctor #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE InstanceSigs #-}
{-# LANGUAGE TupleSections #-}
</code></pre>
<!-- LIMA_DISABLE -->
<pre><code class="language-haskell">{-# HLINT ignore &quot;Use &lt;$&gt;&quot; #-}
{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}
</code></pre>
<!-- LIMA_DISABLE -->
<pre><code class="language-haskell">module Try.Monads.Monads where
</code></pre>
<!-- LIMA_ENABLE -->
<h2 id="state"><a class="header" href="#state">State</a></h2>
<pre><code class="language-haskell">newtype State s a = State {runState :: s -&gt; (a, s)}

instance Functor (State s) where
  fmap :: (a -&gt; b) -&gt; State s a -&gt; State s b
  fmap f s = pure f &lt;*&gt; s

instance Applicative (State s) where
  pure :: a -&gt; State s a
  pure x = State (x,)
  (&lt;*&gt;) :: State s (a -&gt; b) -&gt; State s a -&gt; State s b
  f &lt;*&gt; x = do
    f1 &lt;- f
    x1 &lt;- x
    return $ f1 x1

instance Monad (State s) where
  return :: a -&gt; State s a
  return = pure
  (&gt;&gt;=) :: State s a -&gt; (a -&gt; State s b) -&gt; State s b
  (State f) &gt;&gt;= y = State $ \s -&gt;
    let (a1, s1) = f s
        State x = y a1
        (a2, s2) = x s1
     in (a2, s2)

get :: State s s
get = State $ \s -&gt; (s, s)

put :: s -&gt; State s ()
put s = State $ const ((), s)

expr :: State s ()
expr = do
  t1 &lt;- get
  put t1

expr1 :: ((), Int)
expr1 = flip runState 3 do
  t1 &lt;- get
  put (t1 + 2)

-- &gt;&gt;&gt;expr1
-- ((),5)
</code></pre>
<h2 id="cont"><a class="header" href="#cont">Cont</a></h2>
<pre><code class="language-haskell">newtype Cont r a = Cont {runCont :: (a -&gt; r) -&gt; r} deriving (Functor)

instance Applicative (Cont r) where
  pure :: a -&gt; Cont r a
  pure x = Cont ($ x)
  (&lt;*&gt;) :: Cont r (a -&gt; b) -&gt; Cont r a -&gt; Cont r b
  (Cont f) &lt;*&gt; (Cont x) = Cont $ \y -&gt; f $ \k -&gt; x $ y . k

instance Monad (Cont r) where
  return :: a -&gt; Cont r a
  return = pure
  (&gt;&gt;=) :: Cont r a -&gt; (a -&gt; Cont r b) -&gt; Cont r b
  (Cont f) &gt;&gt;= x = Cont $ \b -&gt; f $ \a -&gt; runCont (x a) $ \t -&gt; b t
</code></pre>
<h2 id="contt"><a class="header" href="#contt">ContT</a></h2>
<pre><code class="language-haskell">data ContT r m a = ContT {runContT :: (a -&gt; m r) -&gt; m r} deriving (Functor)

instance Applicative (ContT r m) where
  pure :: a -&gt; ContT r m a
  pure x = ContT ($ x)
  (&lt;*&gt;) :: ContT r m (a -&gt; b) -&gt; ContT r m a -&gt; ContT r m b
  (ContT f) &lt;*&gt; (ContT x) = ContT $ \y -&gt; f $ \k -&gt; x $ y . k

instance Monad (ContT r m) where
  return :: a -&gt; ContT r m a
  return = pure
  (&gt;&gt;=) :: ContT r m a -&gt; (a -&gt; ContT r m b) -&gt; ContT r m b
  (ContT f) &gt;&gt;= x = ContT $ \b -&gt; f $ \a -&gt; runContT (x a) $ \t -&gt; b t
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">module Try.Monoids.FizzBuzz where

import Control.Monad (guard)
import Data.Maybe (fromMaybe)

f :: [Integer] -&gt; [String]
f =
  let (m ~&gt; str) x = str &lt;$ guard (x `mod` m == 0)
   in map (fromMaybe . show &lt;*&gt; 3 ~&gt; &quot;fizz&quot; &lt;&gt; 5 ~&gt; &quot;buzz&quot;)

-- &gt;&gt;&gt; f [1..100]
-- [&quot;1&quot;,&quot;2&quot;,&quot;fizz&quot;,&quot;4&quot;,&quot;buzz&quot;,&quot;fizz&quot;,&quot;7&quot;,&quot;8&quot;,&quot;fizz&quot;,&quot;buzz&quot;,&quot;11&quot;,&quot;fizz&quot;,&quot;13&quot;,&quot;14&quot;,&quot;fizzbuzz&quot;,&quot;16&quot;,&quot;17&quot;,&quot;fizz&quot;,&quot;19&quot;,&quot;buzz&quot;,&quot;fizz&quot;,&quot;22&quot;,&quot;23&quot;,&quot;fizz&quot;,&quot;buzz&quot;,&quot;26&quot;,&quot;fizz&quot;,&quot;28&quot;,&quot;29&quot;,&quot;fizzbuzz&quot;,&quot;31&quot;,&quot;32&quot;,&quot;fizz&quot;,&quot;34&quot;,&quot;buzz&quot;,&quot;fizz&quot;,&quot;37&quot;,&quot;38&quot;,&quot;fizz&quot;,&quot;buzz&quot;,&quot;41&quot;,&quot;fizz&quot;,&quot;43&quot;,&quot;44&quot;,&quot;fizzbuzz&quot;,&quot;46&quot;,&quot;47&quot;,&quot;fizz&quot;,&quot;49&quot;,&quot;buzz&quot;,&quot;fizz&quot;,&quot;52&quot;,&quot;53&quot;,&quot;fizz&quot;,&quot;buzz&quot;,&quot;56&quot;,&quot;fizz&quot;,&quot;58&quot;,&quot;59&quot;,&quot;fizzbuzz&quot;,&quot;61&quot;,&quot;62&quot;,&quot;fizz&quot;,&quot;64&quot;,&quot;buzz&quot;,&quot;fizz&quot;,&quot;67&quot;,&quot;68&quot;,&quot;fizz&quot;,&quot;buzz&quot;,&quot;71&quot;,&quot;fizz&quot;,&quot;73&quot;,&quot;74&quot;,&quot;fizzbuzz&quot;,&quot;76&quot;,&quot;77&quot;,&quot;fizz&quot;,&quot;79&quot;,&quot;buzz&quot;,&quot;fizz&quot;,&quot;82&quot;,&quot;83&quot;,&quot;fizz&quot;,&quot;buzz&quot;,&quot;86&quot;,&quot;fizz&quot;,&quot;88&quot;,&quot;89&quot;,&quot;fizzbuzz&quot;,&quot;91&quot;,&quot;92&quot;,&quot;fizz&quot;,&quot;94&quot;,&quot;buzz&quot;,&quot;fizz&quot;,&quot;97&quot;,&quot;98&quot;,&quot;fizz&quot;,&quot;buzz&quot;]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">module Try.ParallelAndConcurrentHaskell.Exceptions where

import UnliftIO
</code></pre>
<h2 id="exceptions-1"><a class="header" href="#exceptions-1">Exceptions</a></h2>
<ul>
<li>
<p>Form a hierarchy</p>
</li>
<li>
<p>Catching</p>
<ul>
<li>
<p>Some handlers</p>
<pre><code class="language-hs">try :: Exception e =&gt; IO a -&gt; IO (Either e a)
handle :: Exception e =&gt; (e -&gt; IO a) -&gt; IO a -&gt; IO a
onException :: IO a -&gt; IO b -&gt; IO a
</code></pre>
</li>
<li>
<p><code>onException</code> rethrows the exception. Example:</p>
<pre><code class="language-hs">bracket before after thing =
  mask $ \restore -&gt; do
    a &lt;- before
    r &lt;- restore (thing a) `onException` after a
    _ &lt;- after a
    return r
</code></pre>
</li>
<li>
<p><code>catchJust</code>, <code>handleJust</code> select an exception by a predicate.</p>
</li>
</ul>
</li>
<li>
<p>Throwing</p>
<ul>
<li><code>throwIO :: Exception e =&gt; e -&gt; IO a</code> guarantees the ordering of exceptions</li>
<li><code>throw :: Exception e =&gt; e -&gt; a</code> doesn't</li>
</ul>
</li>
<li>
<p>Processing actions with possible exceptions</p>
<pre><code class="language-hs">bracket :: IO a -&gt; (a -&gt; IO b) -&gt; (a -&gt; IO c) -&gt; IO c
finally :: IO a -&gt; IO b -&gt; IO a
</code></pre>
</li>
</ul>
<h3 id="cancellation-and-timeouts"><a class="header" href="#cancellation-and-timeouts">Cancellation and Timeouts</a></h3>
<h4 id="masking"><a class="header" href="#masking">Masking</a></h4>
<pre><code class="language-hs">mask :: ((IO a -&gt; IO a) -&gt; IO b) -&gt; IO b
</code></pre>
<p>The mask operation defers the delivery of asynchronous exceptions for the duration of
its argument.</p>
<p>Here, asynchronous exceptions can only be delivered inside the argument of <code>restore</code> - inside <code>f a</code>.</p>
<pre><code class="language-haskell">problem :: MVar a -&gt; (a -&gt; IO a) -&gt; IO ()
problem m f = mask $ \restore -&gt; do
  a &lt;- takeMVar m
  r &lt;- restore (f a) `catchAny` \e -&gt; do putMVar m a; throwIO e
  putMVar m r
</code></pre>
<p>mask is applied to a function, which takes as its argument a function restore. The
restore function can be used to restore the delivery of asynchronous exceptions to its
present state during execution of the argument to mask. If we imagine shading the entire
argument to mask except for the expression (f a), asynchronous exceptions cannot be
raised in the shaded portions.</p>
<h4 id="interruptibility"><a class="header" href="#interruptibility">Interruptibility</a></h4>
<p>An <code>interruptible</code> operation may receive an asynchronous exception only if it actually blocks.
In the case of problem above, we know the MVar is definitely empty when we call putMVar,
so putMVar cannot block, which means that it is not interruptible.</p>
<h4 id="get-current-masking-state"><a class="header" href="#get-current-masking-state">Get current masking state</a></h4>
<pre><code class="language-hs">getMaskingState :: IO MaskingState

data MaskingState
  = Unmasked
  | MaskedInterruptible
  | MaskedUninterruptible
</code></pre>
<p>The getMaskingState function returns one of the following construc‐
tors:</p>
<ul>
<li><code>Unmasked</code> - The current thread is not inside <code>mask</code> or <code>uninterruptibleMask</code>.</li>
<li><code>MaskedInterruptible</code> - The current thread is inside <code>mask</code>.</li>
<li><code>MaskedUninterruptible</code> - The current thread is inside <code>uninterruptibleMask</code>.</li>
</ul>
<h4 id="multiple-mvars"><a class="header" href="#multiple-mvars">Multiple MVars</a></h4>
<p><code>modifyMVar</code> and company first <code>takeMVar</code>, then <code>putMVar</code>.</p>
<pre><code class="language-haskell">modifyTwo :: MVar a -&gt; MVar b -&gt; (a -&gt; b -&gt; IO (a, b)) -&gt; IO ()
modifyTwo ma mb f =
  modifyMVar_ mb $ \b -&gt;
    modifyMVar ma $ \a -&gt; f a b
</code></pre>
<p>If this blocks in the inner modifyMVar and an exception is raised, then the outer modifyMVar_ will restore the contents of the MVar it took.</p>
<h4 id="bracket"><a class="header" href="#bracket">Bracket</a></h4>
<pre><code class="language-hs">bracket :: IO a -&gt; (a -&gt; IO b) -&gt; (a -&gt; IO c) -&gt; IO c
bracket before after thing =
  mask $ \restore -&gt; do
    a &lt;- before
    r &lt;- restore (thing a) `onException` after a
    _ &lt;- after a
    return r
</code></pre>
<p>The IO actions passed in as before and after are performed inside mask. The bracket
function guarantees that if before returns, after will be executed in the future. It is
normal for before to contain a blocking operation; if an exception is raised while before
is blocked, then no harm is done. But before should perform only one blocking oper‐
ation. An exception raised by a second blocking operation would not result in after
being executed. If you need to perform two blocking operations, the right way is to nest
calls to bracket, as we did with modifyMVar.
Something else to watch out for here is using blocking operations in after. If you need
to do this, then be aware that your blocking operation is interruptible and might receive
an asynchronous exception.</p>
<h3 id="timeouts"><a class="header" href="#timeouts">Timeouts</a></h3>
<p>See</p>
<ul>
<li><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Exception-Base.html#v:catchJust">catchJust</a></li>
<li><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/System-Timeout.html#v:timeout">timeout</a></li>
<li><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Concurrent.html#v:throwTo">throwTo</a>
<ul>
<li>it's <strong>always</strong> interruptible</li>
</ul>
</li>
</ul>
<h3 id="catching-asynchronous-exceptions"><a class="header" href="#catching-asynchronous-exceptions">Catching asynchronous exceptions</a></h3>
<p>If you need to handle asynchronous exceptions, it’s usually important
for the exception handler to be inside a mask so that you don’t get interrupted by another
asynchronous exception before you’ve finished dealing with the first one. For that rea‐
son, catch or handle might be more appropriate, because you can take advantage of
the built-in mask.</p>
<p>Don't handle exceptions inside a handler.</p>
<h3 id="mask-and-forkio"><a class="header" href="#mask-and-forkio">mask and forkIO</a></h3>
<p>Use <code>async</code></p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# LANGUAGE ScopedTypeVariables #-}

module Try.ParallelAndConcurrentHaskell.MVar where

import Control.Concurrent ()
import Control.Exception (SomeException (SomeException), catch, mask, throw)
import qualified Data.Map as Map
import UnliftIO (MVar, atomically, modifyMVar, modifyMVar_, newEmptyMVar, newMVar, newTMVarIO, putMVar, takeMVar, takeTMVar)
</code></pre>
<h2 id="mvar"><a class="header" href="#mvar">MVar</a></h2>
<ul>
<li><a href="https://stackoverflow.com/questions/129329/optimistic-vs-pessimistic-locking">Pessimistic and optimistic locking</a></li>
<li><a href="https://ruhaskell.org/posts/theory/2015/02/13/mvars.html">Базовая работа с MVar</a></li>
</ul>
<h3 id="mvar-as-a-container-for-shared-state"><a class="header" href="#mvar-as-a-container-for-shared-state">MVar as a Container for Shared State</a></h3>
<p><code>MVar</code>s are lazy.</p>
<pre><code class="language-haskell">name :: String
name = &quot;name&quot;

number :: String
number = &quot;number&quot;

book :: Map.Map String String
book = Map.empty

p1 :: IO ()
p1 = do
  m &lt;- newMVar book
  putMVar m (Map.insert name number book)
</code></pre>
<p>This places in the <code>MVar</code> the unevaluated expression <code>Map.insert name number book</code>.</p>
<p>Benefit: can unlock state and dont wait for <code>insert</code> to complete.
Drawback: consecutive inserts may create thunks</p>
<p>Solution - evaluate to WHNF</p>
<pre><code class="language-haskell">p2 :: IO ()
p2 = do
  m &lt;- newMVar book
  putMVar m $! Map.insert name number book
</code></pre>
<h3 id="fairness"><a class="header" href="#fairness">Fairness</a></h3>
<blockquote>
<p>No thread can be blocked indefinitely on an MVar unless another thread holds that MVar
indefinitely.</p>
</blockquote>
<p>In other words, if a thread T is blocked in takeMVar and there are regular putMVar
operations on the same MVar, it is guaranteed that at some point thread T’s takeMVar
will return. In GHC, this guarantee is implemented by keeping blocked threads in a
FIFO queue attached to the MVar, so eventually every thread in the queue will get to
complete its operation as long as there are other threads performing regular putMVar
operations (an equivalent guarantee applies to threads blocked in putMVar when there
are regular takeMVars). Note that it is not enough to merely wake up the blocked thread
because another thread might run first and take (respectively put) the MVar, causing the
newly woken thread to go to the back of the queue again, which would invalidate the
fairness guarantee. The implementation must therefore wake up the blocked thread and
perform the blocked operation in a single atomic step, which is exactly what GHC does.</p>
<p>A consequence of the fairness implementation is that, when multiple threads are blocked
in takeMVar and another thread does a putMVar, only one of the blocked threads becomes
unblocked. This “single wakeup” property is a particularly important performance char‐
acteristic when a large number of threads are contending for a single MVar. As we shall
see later, it is the fairness guarantee—together with the single wakeup property—that
keeps MVars from being completely subsumed by software transactional memory.</p>
<h3 id="deadlocks"><a class="header" href="#deadlocks">Deadlocks</a></h3>
<ul>
<li>thread A did <code>takeMVar a &gt;&gt; putMVar b</code>, thread B did <code>putMVar b &gt;&gt; takeMVar a</code>
<ul>
<li>Executes
<ol>
<li><code>takeMVar a</code> - <code>A</code></li>
<li><code>putMVar b</code> - <code>B</code></li>
<li><code>putMVar b</code> - <code>A</code> sleeps</li>
<li><code>takeMVar a</code> - <code>B</code> sleeps</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>Solution:
Always first <code>takeMVar</code>, then <code>putMVar</code>.</p>
<h3 id="atomicity"><a class="header" href="#atomicity">Atomicity</a></h3>
<p>If a thread does <code>takeMVar</code>, the <code>MVar</code> becomes empty, so no other thread may <code>takeMVar</code>.
Then, that thread does <code>putMVar</code>.
If the <code>MVar</code> modification was successful, the whole operation seems atomic to other threads.</p>
<p>From <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Concurrent-MVar.html">Control.Concurrent.MVar</a>:</p>
<blockquote>
<p>In particular, the &quot;bigger&quot; functions in this module (swapMVar, withMVar, modifyMVar_ and modifyMVar) are simply the composition of a takeMVar followed by a putMVar with exception safety.
These have atomicity guarantees only if all other threads perform a takeMVar before a putMVar as well;
otherwise, they may block.</p>
</blockquote>
<h3 id="foreign-calls"><a class="header" href="#foreign-calls">Foreign calls</a></h3>
<p>-- TODO</p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# LANGUAGE NumericUnderscores #-}

module Try.ParallelAndConcurrentHaskell.STM where

import UnliftIO
import UnliftIO.Concurrent
</code></pre>
<h2 id="software-transactional-memory"><a class="header" href="#software-transactional-memory">Software Transactional memory</a></h2>
<h3 id="mvar-1"><a class="header" href="#mvar-1">MVar</a></h3>
<p>There may be a situation when <em>have</em> to take 2 <code>MVar</code>s and need to order taking.</p>
<ul>
<li>Thread 1 takes the MVar for desktop a.</li>
<li>Thread 2 takes the MVar for desktop b.</li>
<li>Thread 1 tries to take the MVar for desktop b and blocks.</li>
<li>Thread 2 tries to take the MVar for desktop a and blocks.</li>
</ul>
<p>Deadlock</p>
<h3 id="stm"><a class="header" href="#stm">STM</a></h3>
<p>Can make transactions.</p>
<p>The current thread is blocked until one of the TVars that it is reading is written to,
at which point the thread is unblocked again and the transaction is rerun.</p>
<pre><code class="language-hs">retry :: STM a
</code></pre>
<p>The meaning of <code>retry</code> is simply “abandon the current transaction and run it again.”</p>
<pre><code class="language-haskell">p :: IO (Int, Int)
p = do
  ta &lt;- newTMVarIO 2
  tb &lt;- newTMVarIO 3
  atomically $ do
    a &lt;- takeTMVar ta
    b &lt;- takeTMVar tb
    return (a, b)
</code></pre>
<p>This example is difficult to program with MVar because taking a single MVar is a side
effect that is visible to the rest of the program, and hence cannot be easily undone if the
other MVar is empty. One way to implement it is with a third MVar acting as a lock to
control access to the other two, but then of course all other clients have to be aware of
the locking protocol.</p>
<h3 id="merging-with-stm"><a class="header" href="#merging-with-stm">Merging with STM</a></h3>
<pre><code class="language-hs">orElse :: STM a -&gt; STM a -&gt; STM a
</code></pre>
<p>Combine two blocking transactions such that one is performed but not both.</p>
<p>The operation orElse a b has the following behavior:</p>
<ul>
<li>First, a is executed. If a returns a result, then the orElse call returns it and ends.</li>
<li>If a calls retry instead, a’s effects are discarded_ and b is executed instead.</li>
</ul>
<h3 id="async-exceptions"><a class="header" href="#async-exceptions">Async exceptions</a></h3>
<p>Exceptions just discard transactions.</p>
<h2 id="async"><a class="header" href="#async">Async</a></h2>
<ul>
<li>
<p>With <code>async</code>, the calling thread isn't blocked when running an <strong>async</strong> action.</p>
</li>
<li>
<p>We can check <code>Async a</code> for a result or block on it</p>
</li>
<li>
<p><code>withAsync :: IO a -&gt; (a -&gt; IO b) -&gt; IO b</code> - when the function <code>a -&gt; IO b</code> returns, <code>IO a</code> is killed.</p>
<ul>
<li>
<p>There's no contradiction. We can't use the value stored in <code>a</code> without calling <code>wait a</code>. But this will make the computation <code>IO b</code> to suspend until <code>IO a</code> finishes or throws an exception.</p>
<!-- i 6 -->
<pre><code class="language-haskell">exAsync = withAsync (threadDelay 3_000_000 &gt;&gt; print &quot;ping&quot;) (\a -&gt; wait a &gt;&gt; print &quot;pong&quot;)
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>retry</code> restarts a transaction and blocks the thread until one of the variables that were read changes its value</p>
</li>
<li>
<p><code>Broadcasting</code> channel (e.g., <code>TMChan</code>)</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE TemplateHaskell #-}
{-# HLINT ignore &quot;Avoid lambda using `infix`&quot; #-}
{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}

module Try.TemplateHaskell.ConstructorTags.Declare where

import Control.Lens (Iso', iso, (&amp;), (&lt;&gt;~))
import Control.Monad
import Language.Haskell.TH

data HydraEvent
  = GetUTxOResponse Int
  | TxValid Int

p1 :: Q [Dec]
p1 =
  [d|
    data HydraEvent
      = GetUTxOResponse Int
      | TxValid Int
    |]

-- &gt;&gt;&gt; runQ p1
-- [DataD [] HydraEvent_159 [] Nothing [NormalC GetUTxOResponse_160 [(Bang NoSourceUnpackedness NoSourceStrictness,ConT GHC.Types.Int)],NormalC TxValid_161 [(Bang NoSourceUnpackedness NoSourceStrictness,ConT GHC.Types.Int)]] []]

data HydraEventKind
  = GetUTxOResponseKind
  | TxValidKind
  deriving stock (Eq, Show)

p2 :: Q [Dec]
p2 =
  [d|
    data HydraEventKind
      = GetUTxOResponseKind
      | TxValidKind
      deriving stock (Eq, Show)
    |]

-- &gt;&gt;&gt; runQ p2
-- [DataD [] HydraEventKind_156 [] Nothing [NormalC GetUTxOResponseKind_157 [],NormalC TxValidKind_158 []] [DerivClause (Just StockStrategy) [ConT GHC.Classes.Eq,ConT GHC.Show.Show]]]

nm :: Iso' Name String
nm = iso from to
 where
  from = nameBase
  to = mkName

deriveTags :: Name -&gt; String -&gt; [Name] -&gt; Q [Dec]
deriveTags ty suff classes = do
  (TyConI tyCon) &lt;- reify ty
  (tyName, cs) &lt;- case tyCon of
    DataD _ n _ _ cs _ -&gt; pure (n, cs)
    NewtypeD _ n _ _ cs _ -&gt; pure (n, [cs])
    _ -&gt; fail &quot;deriveTags: only 'data' and 'newtype' are supported&quot;
  cs' &lt;-
    forM
      cs
      ( let mk n = pure $ NormalC (n &amp; nm &lt;&gt;~ suff) []
         in \case
              NormalC n _ -&gt; mk n
              RecC n _ -&gt; mk n
              _ -&gt; fail &quot;deriveTags: constructor names must be NormalC or RecC (See https://hackage.haskell.org/package/template-haskell-2.20.0.0/docs/src/Language.Haskell.TH.Syntax.html#Con)&quot;
      )
  let v = DataD [] (tyName &amp; nm &lt;&gt;~ suff) [] Nothing cs' [DerivClause (Just StockStrategy) (ConT &lt;$&gt; classes)]
  pure [v]

getHydraEventKind :: HydraEvent -&gt; HydraEventKind
getHydraEventKind event = case event of
  GetUTxOResponse{} -&gt; GetUTxOResponseKind
  TxValid{} -&gt; TxValidKind

p3 :: Q [Dec]
p3 =
  [d|
    getHydraEventKind :: HydraEvent -&gt; HydraEventKind
    getHydraEventKind event = case event of
      GetUTxOResponse{} -&gt; GetUTxOResponseKind
      TxValid{} -&gt; TxValidKind
    |]

-- &gt;&gt;&gt; runQ p3
-- [SigD getHydraEventKind_168 (AppT (AppT ArrowT (ConT Try.TemplateHaskell.Declare.HydraEvent)) (ConT Try.TemplateHaskell.Declare.HydraEventKind)),FunD getHydraEventKind_168 [Clause [VarP event_169] (NormalB (CaseE (VarE event_169) [Match (RecP Try.TemplateHaskell.Declare.GetUTxOResponse []) (NormalB (ConE Try.TemplateHaskell.Declare.GetUTxOResponseKind)) [],Match (RecP Try.TemplateHaskell.Declare.TxValid []) (NormalB (ConE Try.TemplateHaskell.Declare.TxValidKind)) []])) []]]

deriveMapping :: Name -&gt; String -&gt; String -&gt; Q [Dec]
deriveMapping ty suff mappingName = do
  (TyConI tyCon) &lt;- reify ty
  (tyName, cs) &lt;- case tyCon of
    DataD _ n _ _ cs _ -&gt; pure (n, cs)
    NewtypeD _ n _ _ cs _ -&gt; pure (n, [cs])
    _ -&gt; fail &quot;deriveTags: only 'data' and 'newtype' are supported&quot;
  let
    sig = SigD (mkName mappingName) (AppT (AppT ArrowT (ConT ty)) (ConT (tyName &amp; nm &lt;&gt;~ suff)))
  event &lt;- newName &quot;event&quot;
  matches &lt;-
    forM
      cs
      ( let mk n = pure $ Match (RecP n []) (NormalB (ConE (n &amp; nm &lt;&gt;~ suff))) []
         in \case
              NormalC n _ -&gt; mk n
              RecC n _ -&gt; mk n
              _ -&gt; fail &quot;deriveTags: constructor names must be NormalC or RecC (See https://hackage.haskell.org/package/template-haskell-2.20.0.0/docs/src/Language.Haskell.TH.Syntax.html#Con)&quot;
      )
  let
    fun = FunD (mkName mappingName) [Clause [VarP event] (NormalB (CaseE (VarE event) matches)) []]
  pure [sig, fun]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE QuasiQuotes #-}
{-# HLINT ignore &quot;Avoid lambda using `infix`&quot; #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TemplateHaskell #-}
{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}

module Try.TemplateHaskell.ConstructorTags.Use where

import Try.TemplateHaskell.ConstructorTags.Declare (HydraEvent (..), deriveMapping, deriveTags)

$(deriveTags ''HydraEvent &quot;Kind&quot; [''Show, ''Eq])
$(deriveMapping ''HydraEvent &quot;Kind&quot; &quot;getKind&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE TemplateHaskell #-}
{-# HLINT ignore &quot;Avoid lambda using `infix`&quot; #-}
{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}

module Try.TemplateHaskell.Typed.Declare where

import Language.Haskell.TH
import Language.Haskell.TH.Syntax

myFunc :: Q Exp
myFunc = [|\x -&gt; x + 1|]

add2 :: Q Exp
add2 = [|$myFunc . $myFunc|]

runAdd2 :: (Quasi m) =&gt; m Exp
runAdd2 = runQ add2

-- &gt;&gt;&gt; runAdd2
-- InfixE (Just (LamE [VarP x_2] (InfixE (Just (VarE x_2)) (VarE GHC.Num.+) (Just (LitE (IntegerL 1)))))) (VarE GHC.Base..) (Just (LamE [VarP x_3] (InfixE (Just (VarE x_3)) (VarE GHC.Num.+) (Just (LitE (IntegerL 1))))))

myFuncTyped :: Code Q (Integer -&gt; Integer)
myFuncTyped = [||\x -&gt; x + 1||]

runMyFuncTyped :: (Quasi m) =&gt; m Exp
runMyFuncTyped = runQ $ unTypeCode myFuncTyped

-- &gt;&gt;&gt; runMyFuncTyped
-- LamE [VarP x_5] (InfixE (Just (VarE x_5)) (VarE GHC.Num.+) (Just (LitE (IntegerL 1))))

add2Typed :: Code Q (Integer -&gt; Integer)
add2Typed = [||$$myFuncTyped . $$myFuncTyped||]

runAdd2Typed :: (Quasi m) =&gt; m Exp
runAdd2Typed = runQ $ unTypeCode add2Typed

-- &gt;&gt;&gt; runAdd2Typed
-- InfixE (Just (LamE [VarP x_162] (InfixE (Just (VarE x_162)) (VarE GHC.Num.+) (Just (LitE (IntegerL 1)))))) (VarE GHC.Base..) (Just (LamE [VarP x_163] (InfixE (Just (VarE x_163)) (VarE GHC.Num.+) (Just (LitE (IntegerL 1))))))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE QuasiQuotes #-}
{-# HLINT ignore &quot;Avoid lambda using `infix`&quot; #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TemplateHaskell #-}
{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}

module Try.TemplateHaskell.Typed.Use where

import Try.TemplateHaskell.Typed.Declare (runAdd2Typed)

p = $(runAdd2Typed) 2

-- &gt;&gt;&gt; p
-- 4
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">module Try.Test.Theory where
</code></pre>
<h3 id="testing"><a class="header" href="#testing">Testing</a></h3>
<h4 id="property-based-testing"><a class="header" href="#property-based-testing">Property-based testing</a></h4>
<ul>
<li><a href="https://www.fpcomplete.com/blog/quickcheck-hedgehog-validity/">Hedgehog, quickcheck</a>
<ul>
<li>examples: <a href="https://hackage.haskell.org/package/lima">lima</a></li>
</ul>
</li>
</ul>
<p>-<em>HiD, Chapter  8</em>*
Test types:</p>
<ul>
<li><code>unit</code> tests -</li>
<li><code>property-based</code> tests - checking property on a number of inputs</li>
<li><code>golden</code> tests - check against a reference file contents (<code>tasty-golden</code>)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeFamilies #-}

module Try.TypeClasses.Monoid where

import Control.Monad (guard)
</code></pre>
<h2 id="monoid-semigroup"><a class="header" href="#monoid-semigroup">Monoid, Semigroup</a></h2>
<p>From https://medium.com/@stackdoesnotwork/magical-monoids-50da92b069f4</p>
<pre><code class="language-haskell">-- f &lt;&gt; g = \x -&gt; f x &lt;&gt; g x

expr1 :: [Char]
expr1 = (take 3 &lt;&gt; const &quot;oi&quot; &lt;&gt; drop 4) &quot;Monads are cool!&quot;

-- &gt;&gt;&gt;expr1
-- &quot;Monoids are cool!&quot;
</code></pre>
<h2 id="guards"><a class="header" href="#guards">Guards</a></h2>
<pre><code class="language-haskell">deleteIfNegative :: (Num a, Ord a) =&gt; a -&gt; Maybe a
deleteIfNegative x = guard (x &gt;= 0) &gt;&gt; pure x

expr2 :: [Maybe Int]
expr2 = [deleteIfNegative 3, deleteIfNegative (-3)]

-- &gt;&gt;&gt;expr2
-- [Just 3,Nothing]

pyth :: [(Integer, Integer, Integer)]
pyth = do
  z &lt;- [1 ..]
  x &lt;- [1 .. z]
  y &lt;- [x .. z]
  guard (x ^ 2 + y ^ 2 == z ^ 2)
  return (x, y, z)

expr3 :: [(Integer, Integer, Integer)]
expr3 = take 5 pyth

-- &gt;&gt;&gt;expr3
-- [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17)]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE InstanceSigs #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE NumericUnderscores #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE StandaloneKindSignatures #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilyDependencies #-}
{-# LANGUAGE TypeOperators #-}

module Try.TypeClasses.Theory where
</code></pre>
<h3 id="type-classes"><a class="header" href="#type-classes">Type classes</a></h3>
<ul>
<li>
<p>The part before the <code>=&gt;</code> is the context, while the part after the <code>=&gt;</code> is the head of the instance declaration. - <a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/instances.html?highlight=overlapping%20instances#instance-declarations-and-resolution">src</a></p>
<pre><code class="language-hs">instance (assertion1, ..., assertion) =&gt; class type1 ... typem where ...
</code></pre>
</li>
<li>
<p>How are type classes implemented in Haskell?</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=8o51sA12VfI">All You Wanted to Know About Type Classes</a>
<ul>
<li>
<p>What is a dictionary?</p>
<ul>
<li>A data type with class functions as fields</li>
</ul>
</li>
<li>
<p>How is it defined and passed into functions? - <a href="https://arxiv.org/pdf/1907.00844.pdf#subsection.2.1">src</a></p>
<ul>
<li>embed <code>Superclass</code> dictionary into <code>Subclass</code> dictionary</li>
</ul>
<!-- i 6 -->
<pre><code class="language-haskell">newtype BaseD a = BaseD {base :: a -&gt; Bool}
data Sub1D a = Sub1D
  { super1 :: BaseD a
  , sub1 :: a -&gt; Bool
  }
</code></pre>
</li>
<li>
<p>Passed automatically by the compiler</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Why using constraints on a type variable within a data declaration isn't a good idea?</p>
<ul>
<li>They make code less flexible and disallow some instances - <a href="https://stackoverflow.com/a/40825913">SO</a></li>
<li>Can be achieved by using <code>GADTs</code></li>
</ul>
</li>
<li>
<p>What is coherence and why is it important to maintain it? What are the possible cases of coherence violation?</p>
<ul>
<li>
<blockquote>
<p>A program is coherent if it has exactly one meaning — i.e., its semantics is unambiguously determined.</p>
</blockquote>
</li>
<li><code>Coherence</code> is when multiple <code>type derivations</code> are possible - <a href="https://stackoverflow.com/a/68008592">SO</a></li>
<li>For each different derivation a different class instance can be used. This may lead to different behaviors</li>
<li><code>FlexibleInstances</code> and <code>MultiParamTypeClasses</code> introduce incoherence</li>
<li>Need to maintain coherence to write a program whose type checking (<code>static</code>) doesn't change its runtime (<code>dynamic</code>) properties</li>
</ul>
</li>
<li>
<p>Overlapping</p>
<ul>
<li>How does the instance selection process happen?
<ul>
<li>Find an instance with satisfying <code>B</code> of (<code>instance A =&gt; C B where</code>)</li>
<li>Find instance for <code>A</code></li>
</ul>
</li>
<li>Is it possible to have overlapping instances?
<ul>
<li><code>instance C a</code> and <code>instance C Bool</code></li>
</ul>
</li>
<li>Does having overlapping instances violate coherence?
<ul>
<li>No</li>
</ul>
</li>
<li>Basics of Haskell instance selection - <a href="https://www.youtube.com/watch?v=XfIlhJFmw3c">src</a></li>
<li>Is it possible to have a compiled and working program with coherence violations?
<ul>
<li>Yes - <a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/instances.html?highlight=overlapping%20instances#instance-signatures-type-signatures-in-instance-declarations">src</a> (see example above)</li>
</ul>
</li>
<li>How would you solve a problem of overlapping instances in various situations?
<ul>
<li>Make the most specific instance discoverable using the fine-grained per-instance pragmas</li>
<li>Rewrite
<ul>
<li><code>instance {-# OVERLAPPABLE #-} C a</code> and <code>instance C Bool</code></li>
<li><code>instance C a</code> and <code>instance {-# OVERLAPPING #-} C Bool</code></li>
<li><code>OVERLAPS</code> = both</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Orphans</p>
<ul>
<li>What are orphan instances? Why are they undesirable?
<ul>
<li>An orphan instance is a type class instance for class C and type T which is neither defined in the module where C is defined nor in the module where T is defined. - <a href="https://wiki.haskell.org/Orphan_instance">src</a></li>
<li>Type class instances are special in that they don't have a name and cannot be <code>imported</code> explicitly. This also means that they cannot be <code>excluded</code> explicitly. All instances defined in a module <code>A</code> are imported automatically when importing <code>A</code>, or importing any module that imports <code>A</code>, directly or indirectly.</li>
<li>Orphans may break the functionality planned by the library author</li>
<li>Orphans invalidate file fingerprints (hash of a file made by GHC to check later if a file has changed) and transitively - in modules that import them - <a href="https://tech.freckle.com/2018/12/12/a-home-for-orphan-instances/#fewer-dirty-fingerprints">src</a></li>
</ul>
</li>
<li>How to deliver orphans?
<ul>
<li>Expose type and instance only together by putting orphans into modules and re-exporting them - <a href="https://www.michaelpj.com/blog/2020/10/29/your-orphans-are-fine.html#private-modules">src</a>
<ul>
<li>Cons:
<ul>
<li>a user has to use your instances</li>
<li>your lib uses more dependencies</li>
</ul>
</li>
</ul>
</li>
<li>Define instances in a separate package - <a href="https://www.michaelpj.com/blog/2020/10/29/your-orphans-are-fine.html#private-packages">src</a>
<ul>
<li>cons: need to track these packages</li>
</ul>
</li>
</ul>
</li>
<li>Does having orphan instances violate coherence?
<ul>
<li>When orphans violate coherence:
<ul>
<li>If you actually import both instances, your program will fail to compile.</li>
<li>If you do not directly import both, but rather use two modules which independently use the differing instances, you can end up with incoherent behaviour.</li>
</ul>
</li>
</ul>
</li>
<li>What are the pros and cons of isolating orphans in special modules?
<ul>
<li>Pros: less often fingerprints invalidation</li>
<li>Cons: need to recompile the whole project on changes in that module - <a href="https://tech.freckle.com/2018/12/12/a-home-for-orphan-instances/#decrease-the-surplus-compilation">src</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p>How the problem of orphans and overlapping is solved in other languages or by different overloading implementation techniques?</p>
<ul>
<li>Scala
<ul>
<li>An orphan instance in Scala means an instance that exists neither in the type's companion object nor the type class' companion object - <a href="https://pjrt.medium.com/orphan-instances-in-scala-322caa78e382">src</a></li>
<li>Import packages with type and instance declaration separately</li>
</ul>
</li>
</ul>
</li>
<li>
<p>What are the problems of current typeclasses implementation?</p>
<ul>
<li>There's no formal proof that instance resolution is coherent</li>
</ul>
</li>
<li>
<p>Is there a problem of structuring the hierarchy of standard typeclasses?</p>
<!-- TODO -->
</li>
<li>
<p>What is Final Tagless (FT) style? - <a href="https://serokell.io/blog/introduction-tagless-final">src</a></p>
<ul>
<li>Example:
<ul>
<li><code>wimble :: (MonadReader Env m, MonadState State m) =&gt; m ()</code></li>
</ul>
</li>
<li>Can extend in two dimensions
<ol>
<li>a new interpreter (change implementation of <code>MonadReader</code>)</li>
<li>a new set of operations (add a constraint like <code>MonadWriter</code>)</li>
</ol>
</li>
<li><code>Application monad</code> (<code>AM</code>) - a monad for organizing effectful application code
<ul>
<li><code>FT</code> can define <code>AM</code></li>
</ul>
</li>
<li><code>Tagged Initial</code> - sum types are represented as <code>(tag, payload)</code>. <code>tag</code> - for pattern-matching</li>
<li><code>Tagless Initial</code> - use <code>GADTs</code> to ban nonsense expressions, no tags</li>
<li><code>Final Tagless</code> - use overloaded functions</li>
</ul>
</li>
<li>
<p><code>Functor</code> laws:</p>
<pre><code class="language-hs">fmap id = id
</code></pre>
<pre><code class="language-hs">fmap (f . g)  ==  fmap f . fmap g
</code></pre>
</li>
</ul>
<h4 id="foldable"><a class="header" href="#foldable">Foldable</a></h4>
<pre><code class="language-hs">class Foldable t where
</code></pre>
<ul>
<li>
<p>When using folds, one can force the evaluation of an accumulator</p>
<ul>
<li>
<p><code>deepseq</code> - <a href="https://www.youtube.com/watch?v=eAcNGbnuTYs&amp;list=PLe7Ei6viL6jGp1Rfu0dil1JH1SHk9bgDV&amp;index=32">YT</a></p>
</li>
<li>
<p><a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/strict.html">BangPatterns</a> with pattern matching on the element of an accumulator to force.</p>
<!-- i 4 -->
<pre><code class="language-haskell">-- &gt;&gt;&gt; foldl (\(!a1, !a2) x -&gt; (a1 + x, a2 + x)) (0, 0) [1..9]
-- (45,45)
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>foldl'</code> - fold a list from the left: <code>f (f (f x a1) a2) ...</code> and have accumulator in WHNF.</p>
<ul>
<li>May need to force the accumulator</li>
</ul>
</li>
<li>
<p><code>foldr</code> - calculate the full list and fold it from the right: <code>f (f (f x a5) a4) ...</code>.</p>
<ul>
<li>
<p>Can terminate early if an operation is strict in the left argument (like <code>&amp;&amp;</code>) - <a href="https://stackoverflow.com/a/27682341">SO</a></p>
</li>
<li>
<p>Can cause stack overflow as it has to evaluate the whole list first - <a href="https://wiki.haskell.org/Foldr_Foldl_Foldl&#x27;#Foldr">wiki</a></p>
<pre><code class="language-haskell">-- &gt;&gt;&gt; foldr (&amp;&amp;) False (repeat False)
-- False
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>fold :: (Foldable t, Monoid m) =&gt; t m -&gt; m</code></p>
<ul>
<li>
<p>folds a container with elements that have a <code>Monoid</code> instance</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt; fold [Just &quot;a&quot;, Nothing, Just &quot;c&quot;]
-- Just &quot;ac&quot;
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>foldMap :: (Foldable t, Monoid m) =&gt; (a -&gt; m) -&gt; t a -&gt; m</code> - maps each element of a container to a <code>Monoid</code> and <code>fold</code>s the container</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt; foldMap Just [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
-- Just &quot;abc&quot;
</code></pre>
</li>
</ul>
<h4 id="alternative-and-monadplus"><a class="header" href="#alternative-and-monadplus">Alternative and MonadPlus</a></h4>
<ul>
<li><a href="https://en.wikibooks.org/wiki/Haskell/Alternative_and_MonadPlus">Haskell wikibooks</a>:
<ul>
<li><code>Alternative</code>
<ul>
<li>
<p>Definition</p>
<pre><code class="language-hs">class Applicative f =&gt; Alternative f where
  empty :: f a
  (&lt;|&gt;) :: f a -&gt; f a -&gt; f a
</code></pre>
</li>
<li>
<p>There's no instance for <code>Either a</code></p>
</li>
<li>
<p>As it's an associative operation, it produces the same result for either fold</p>
<!-- i 6 -->
<pre><code class="language-haskell">-- &gt;&gt;&gt; foldr (&lt;|&gt;) empty [Just &quot;a&quot;, Nothing, Just &quot;c&quot;, Nothing, Just &quot;e&quot;]
-- Just &quot;a&quot;

-- &gt;&gt;&gt; foldl' (&lt;|&gt;) empty [Just &quot;a&quot;, Nothing, Just &quot;c&quot;, Nothing, Just &quot;e&quot;]
-- Just &quot;a&quot;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="traversable"><a class="header" href="#traversable">Traversable</a></h4>
<ul>
<li>
<p><a href="https://en.wikibooks.org/wiki/Haskell/Traversable">Haskell wikibooks</a>:</p>
<!-- i 4 -->
<pre><code class="language-haskell">class (Functor t, Foldable t) =&gt; Traversable t where
  traverse :: (Applicative f) =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)
  sequenceA :: (Applicative f) =&gt; t (f a) -&gt; f (t a)

  -- These methods have default definitions.
  -- They are merely specialised versions of the other two.
  mapM :: (Monad m) =&gt; (a -&gt; m b) -&gt; t a -&gt; m (t b)
  sequence :: (Monad m) =&gt; t (m a) -&gt; m (t a)
</code></pre>
</li>
</ul>
<h4 id="contravariant"><a class="header" href="#contravariant">Contravariant</a></h4>
<ul>
<li><a href="https://github.com/ocharles/blog/blob/master/guest-posts/2013-12-21-24-days-of-hackage-contravariant.md">Contravariant</a></li>
</ul>
<h4 id="profunctor"><a class="header" href="#profunctor">Profunctor</a></h4>
<ul>
<li><a href="https://github.com/ocharles/blog/blob/master/guest-posts/2013-12-22-24-days-of-hackage-profunctors.md">Profunctor</a></li>
<li><a href="https://typeclasses.com/profunctors">Understanding profunctors</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeFamilies #-}

module Try.TypeClasses.TypeClasses where
</code></pre>
<h2 id="problem"><a class="header" href="#problem">Problem</a></h2>
<p>Make a function that converts a <code>Foo</code> to <code>TFoo Foo</code> and other types to <code>TA a</code>.
Avoid <code>TypeApplications</code> if possible.</p>
<pre><code class="language-haskell">data Foo = Foo
data Bar = Bar

data FooOrA a = TFoo Foo | TA a

class Convert a b where
  toFooOrA :: a -&gt; FooOrA b

instance Convert Foo a where
  toFooOrA = TFoo

instance (a ~ b) =&gt; Convert a b where
  toFooOrA = TA

s1 :: Integer
s1 = case toFooOrA @Int 42 of
  TFoo _ -&gt; 1
  TA _ -&gt; 2

-- &gt;&gt;&gt;s
-- 1

s2 :: Integer
s2 = case toFooOrA Bar of
  TFoo _ -&gt; 1
  TA _ -&gt; 2

-- &gt;&gt;&gt;s2
-- 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# LANGUAGE QuasiQuotes #-}

module Try.TypeFamilies.StringInterpolate where

import Data.ByteString
import Data.String.Interpolate (i)
import Data.Text
</code></pre>
<h1 id="string-interpolate"><a class="header" href="#string-interpolate">string-interpolate</a></h1>
<p>Implementation <a href="https://williamyaoh.com/posts/2019-05-27-string-interpolation-and-overlapping-instances.html">explanation</a> feat. Type families, Tagged Classes</p>
<pre><code class="language-haskell">b :: Integer
b = 3

d :: Text
d = [i|comm|]

s :: ByteString
s = [i|A #{b} -c #{d}|]

-- &gt;&gt;&gt; s
-- &quot;A 3 -c comm&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE StandaloneKindSignatures #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE UndecidableInstances #-}

module Try.TypeFamilies.TaggedClasses where
</code></pre>
<h1 id="tagged-classes"><a class="header" href="#tagged-classes">Tagged classes</a></h1>
<ul>
<li><a href="https://github.com/monadfix/tagged-aeson">tagged-aeson</a></li>
</ul>
<h2 id="instance-chains"><a class="header" href="#instance-chains">Instance Chains</a></h2>
<p>PureScript provides <a href="https://github.com/purescript/documentation/blob/master/language/Type-Classes.md#instance-chains">Instance Chains</a>.</p>
<p>Here's how they can be rewritten using Tagged Classes</p>
<p>source - <a href="https://github.com/sigma-andex/purescript-barlow-lens/blob/295c4b32fbeca052ebfd3665a9071012e654b9c0/src/Data/Lens/Barlow/Parser.purs#L11">purescript-barlow-lens</a></p>
<pre><code class="language-haskell">import Data.Kind (Constraint)
import GHC.TypeLits (AppendSymbol, Symbol)

data Tag
  = WhenDot
  | WhenSpace
  | WhenSame
  | Else

type SelectTag :: Symbol -&gt; Symbol -&gt; Symbol -&gt; Symbol -&gt; Tag
type family SelectTag head tail out rest where
  SelectTag &quot;.&quot; t &quot;.&quot; t = WhenDot
  SelectTag &quot; &quot; t &quot;&quot; t = WhenSpace
  SelectTag h &quot;&quot; h &quot;&quot; = WhenSame
  SelectTag _ _ _ _ = Else

type ParsePercentageSymbol' :: Tag -&gt; Symbol -&gt; Symbol -&gt; Symbol -&gt; Symbol -&gt; Constraint
class ParsePercentageSymbol' tag head tail out rest

instance ParsePercentageSymbol' WhenDot &quot;.&quot; t &quot;&quot; t
instance ParsePercentageSymbol' WhenSpace &quot; &quot; t &quot;&quot; t
instance ParsePercentageSymbol' WhenSame h &quot;&quot; h &quot;&quot;
instance (ParsePercentageSymbol th tt tout trest, t ~ AppendSymbol th tt, out ~ AppendSymbol h tout) =&gt; ParsePercentageSymbol' Else h t out trest

type ParsePercentageSymbol :: Symbol -&gt; Symbol -&gt; Symbol -&gt; Symbol -&gt; Constraint
type ParsePercentageSymbol h t o r = ParsePercentageSymbol' (SelectTag h t o r) h t o r
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# LANGUAGE DataKinds #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE InstanceSigs #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE StandaloneKindSignatures #-}
{-# LANGUAGE TypeFamilyDependencies #-}
{-# LANGUAGE TypeOperators #-}
{-# OPTIONS_GHC -Wno-unticked-promoted-constructors #-}
{-# OPTIONS_GHC -Wno-missing-kind-signatures #-}
{-# OPTIONS_GHC -Wno-unused-type-patterns #-}

module Try.TypeFamilies.Theory where

import Data.Functor.Identity ( Identity )
import Data.Kind ( Type )
</code></pre>
<h3 id="type-and-data-families"><a class="header" href="#type-and-data-families">Type and Data Families</a></h3>
<p>Haskell wiki (<a href="https://wiki.haskell.org/GHC/Type_families#What_are_type_families.3F">src</a>):</p>
<blockquote>
<p>The concept of a type family comes from type theory. An indexed type family in type theory is a partial function at the type level.
Applying the function to parameters (called type indices) yields a type.
Type families permit a program to compute what data constructors it will operate on,
rather than having them fixed statically (as with simple type systems) or treated as opaque unknowns
(as with parametrically polymorphic types).</p>
</blockquote>
<blockquote>
<p>Type families are to vanilla data types what type class methods are to regular functions.
Vanilla polymorphic data types and functions have a single definition, which is used at all type instances.
Classes and type families, on the other hand, have an interface definition and any number of instance definitions.
A type family's interface definition declares its kind and its arity, or the number of type indices it takes.
Instance definitions define the type family over some part of the domain.</p>
</blockquote>
<ul>
<li><strong>Type Families: The Definitive Guide</strong> - <a href="https://serokell.io/blog/type-families-haskell">src</a>
<ul>
<li>
<p><code>Non-generative</code> type can be reduced to other types:</p>
<ul>
<li><code>Pair a</code> -&gt; <code>(a, a)</code></li>
<li>Non-generative type constructors have arities assigned to them and must be used saturated.</li>
</ul>
</li>
<li>
<p><code>Generative</code> type constructor - can't be reduced to another type</p>
<ul>
<li>
<p><code>Maybe Bool ~ Maybe Bool</code> and nothing else</p>
</li>
<li>
<p>We set the <code>kind</code> via a standalone <code>type ...</code>. Here, <code>MaybeIf</code> requires something of kind <code>Bool</code> for construction. Therefore, we supply a promoted <code>True</code> to it.</p>
<!-- i 6 -->
<pre><code class="language-haskell">type MaybeIf :: Bool -&gt; Type -&gt; Type
type family MaybeIf b t where
  MaybeIf True t = Maybe t
  MaybeIf False t = Identity t
</code></pre>
</li>
</ul>
</li>
<li>
<p>Use to implement operations on <code>GADTs</code> (e.g., concatenate lists)</p>
<pre><code class="language-haskell">type HList :: [Type] -&gt; Type
data HList xs where
  HNil :: HList '[]
  (:&amp;) :: x -&gt; HList xs -&gt; HList (x : xs)
infixr 5 :&amp;

type Append :: [a] -&gt; [a] -&gt; [a]
type family Append xs ys where -- header
  Append '[] ys = ys -- clause 1
  Append (x : xs) ys = x : Append xs ys -- clause 2
happend :: HList xs -&gt; HList ys -&gt; HList (Append xs ys)
happend = undefined
</code></pre>
</li>
<li>
<p><strong>Closed type families</strong></p>
<ul>
<li>
<p>The clauses of a closed type family are ordered and matched <strong>from top to bottom</strong></p>
</li>
<li>
<p>Overlapping equations</p>
<!-- i 8 -->
<pre><code class="language-haskell">type And :: Bool -&gt; Bool -&gt; Bool
type family And a b where
  And True True = True
  And _ _ = False
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Open type families</strong></p>
<ul>
<li>Such families can be extended anywhere</li>
<li>The equations of an open type family are either:
<ul>
<li>
<p>Not overlapping, so get a combinatorial explosion in patterns:</p>
<!-- i 8 -->
<pre><code class="language-haskell">type And' :: Bool -&gt; Bool -&gt; Bool
type family And' a b

type instance And' True True = True
type instance And' True False = False
type instance And' False True = False
type instance And' False False = False
</code></pre>
</li>
<li>
<p>Compatible:</p>
<ul>
<li>
<p>Can make right sides equal and unify left sides via rewriting</p>
<!-- i 10 -->
<pre><code class="language-haskell">type family G a b

type instance G a Bool = a -&gt; Bool
type instance G Char b = Char -&gt; b

-- ==&gt;

type instance G Char Bool = Char -&gt; Bool
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Associated types</strong></p>
<ul>
<li>
<p>Almost the same as open type families</p>
</li>
<li>
<p>Can set default values</p>
<!-- i 6 -->
<pre><code class="language-haskell">type family Unwrap x where
  Unwrap (f a) = a

class Container2 a where
  type Elem2 a

  -- default
  type Elem2 x = Int
  elements' :: a -&gt; [Elem2 a]
</code></pre>
</li>
<li>
<p>Example from <a href="https://williamyaoh.com/posts/2019-05-27-string-interpolation-and-overlapping-instances.html#cb12">string-interpolate</a></p>
</li>
</ul>
</li>
<li>
<p><strong>Injectivity</strong> - get input types from output types</p>
<ul>
<li>
<p>Use <code>TypeFamilyDependencies</code></p>
<!-- i 8 -->
<pre><code class="language-haskell">type family Not x = r | r -&gt; x where

-- &gt;&gt;&gt; s @True
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Data families</strong></p>
<ul>
<li>
<p><a href="https://wiki.haskell.org/GHC/Type_families#Detailed_definition_of_data_families">HaskellWiki</a></p>
</li>
<li>
<p>Compute <strong>new</strong> data types (type families compute the existing data types)</p>
<!-- i 6 -->
<pre><code class="language-haskell">data family Vector a
newtype instance Vector () = VUnit Int
newtype instance Vector Int = VInts [Int]
</code></pre>
</li>
<li>
<p>Can associate with a class</p>
<!-- i 8 -->
<pre><code class="language-haskell">class Vectorizable a where
  data Vector_ a
  vlength :: Vector_ a -&gt; Int

newtype S = S {unS :: [Int]}
instance Vectorizable S where
  data Vector_ S = Vector_ {unVector_ :: S}
  vlength :: Vector_ S -&gt; Int
  vlength = length . unS . unVector_
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE InstanceSigs #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE StandaloneKindSignatures #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeFamilyDependencies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE UndecidableInstances #-}
{-# OPTIONS_GHC -Wno-missing-kind-signatures #-}
{-# OPTIONS_GHC -Wno-unticked-promoted-constructors #-}
{-# OPTIONS_GHC -Wno-unused-type-patterns #-}

module Try.TypeFamilies.TypeFamilies where

import Data.Data (Proxy (Proxy), Typeable, typeRep)
import Data.Functor.Identity (Identity (Identity))
import Data.Kind (Type)

-- Type families

class Add a b where
  type SumTy a b
  plus :: a -&gt; b -&gt; SumTy a b

instance Add Integer Double where
  type SumTy Integer Double = Double
  plus :: Integer -&gt; Double -&gt; SumTy Integer Double
  plus x y = fromIntegral x + y

instance Add Double Integer where
  type SumTy Double Integer = Double
  plus :: Double -&gt; Integer -&gt; SumTy Double Integer
  plus x y = x + fromIntegral y

instance (Num a) =&gt; Add a a where
  type SumTy a a = a
  plus :: a -&gt; a -&gt; SumTy a a
  plus x y = x + y

checkAdd :: Double
checkAdd = plus (5 :: Integer) (6 :: Double)

-- &gt;&gt;&gt; checkAdd
-- 11.0

-- Type families https://serokell.io/blog/type-families-haskell

-- kind signature
type Append :: forall a. [a] -&gt; [a] -&gt; [a]
type family Append xs ys where -- header
  Append '[] ys = ys -- clause 1
  Append (x : xs) ys = x : Append xs ys

type MaybeIf :: Bool -&gt; Type -&gt; Type
type family MaybeIf b t where
  MaybeIf 'True t = Maybe t
  MaybeIf 'False t = Identity t

data PlayerInfo b = MkPlayerInfo
  { name :: MaybeIf b String
  , score :: MaybeIf b Integer
  }

s1 :: Identity Int
s1 = Identity 3 :: MaybeIf False Int

s2 :: Maybe Int
s2 = Just 3 :: MaybeIf True Int

-- move type family parameter from header to body
type MaybeIf' :: Bool -&gt; Type -&gt; Type
type family MaybeIf' b where
  MaybeIf' True = Maybe
  MaybeIf' False = Identity

-- Open type families

type family F a
type instance F a = [a]
type instance F Char = String

-- Compatibility
-- - Their left-hand sides are apart (i.e. not overlapping)
-- - Their left-hand sides unify with a substitution, under which the right-hand sides are equal.

-- Like, we make right-hand sides equal, and then rewrite left-hand sides until we get the same expressions
type family G a b
type instance G a Bool = a -&gt; Bool
type instance G Char b = Char -&gt; b

-- a -&gt; Bool ---&gt; Char -&gt; Bool =&gt; a = Char
-- Char -&gt; b ---&gt; Char -&gt; Bool =&gt; b = Bool
-- =&gt;
-- G a    Bool ---&gt; G Char Bool
-- G Char b    ---&gt; G Char Bool

type instance G Char Bool = Char -&gt; Bool
</code></pre>
<p>-- Multiline ghci code
&gt;&gt;&gt; a = 3
&gt;&gt;&gt; b = a
&gt;&gt;&gt; b + a
6</p>
<pre><code class="language-haskell">-- Associated types
-- Allows to switch from this
type family Elem a
class Container a where
  elements :: a -&gt; [Elem a]

type instance Elem [a] = a
instance Container [a] where
  elements :: [a] -&gt; [Elem [a]]
  elements = id

-- to this
class Container1 a where
  type Elem1 a
  elements1 :: a -&gt; [Elem a]

instance Container1 [a] where
  type Elem1 [a] = a
  elements1 :: [a] -&gt; [Elem [a]]
  elements1 = id

-- and get default values

type family Unwrap x where
  Unwrap (f a) = a

class Container2 a where
  type Elem2 a

  -- default
  type Elem2 x = Unwrap x
  elements' :: a -&gt; [Elem2 a]

-- Checks during pattern matching
dedup :: (Eq a) =&gt; [a] -&gt; [a]
dedup (x1 : x2 : xs) | x1 == x2 = dedup (x1 : xs)
dedup (y : xs) = y : dedup xs
dedup [] = []

-- Type family dependencies
-- injectivity

type family Not x = r | r -&gt; x where
  Not True = False

s :: forall x. (Not x ~ True, Typeable x) =&gt; String
s = show (typeRep $ Proxy @x)

-- ?
-- &gt;&gt;&gt;:set -XTypeFamilyDependencies
-- &gt;&gt;&gt;s
-- Couldn't match type `Not x0_a1S7U[tau:1]' with 'True
--   arising from a use of `s'
-- The type variable `x0_a1S7U[tau:1]' is ambiguous
-- In the expression: s
-- In an equation for `it_a1S6U': it_a1S6U = s

-- Associated data type
class Vectorizable a where
  data Vector a
  vlength :: Vector a -&gt; Int

newtype S = S {unS :: [Int]}
instance Vectorizable S where
  data Vector S = Vector {unVector :: S}
  vlength :: Vector S -&gt; Int
  vlength = length . unS . unVector

-- Data family
data family SomeFamily a
newtype instance SomeFamily Int = SomeF Int

-- TODO deduplicate with Theory
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="additional-resources"><a class="header" href="#additional-resources">Additional resources</a></h2>
<ul>
<li><a href="http://oleg.fi/gists/posts/2017-04-18-glassery.html#lens">Glassery</a></li>
<li><a href="https://github.com/Elvecent/notebooks/blob/master/lens-aeson/Main.ipynb">lens ipynb</a></li>
<li><a href="https://github.com/ekmett/lens/wiki/Operators">operators</a></li>
<li><a href="https://github.com/ekmett/lens/wiki/Derivation#traversals">optics derivation</a></li>
<li><a href="https://hackage.haskell.org/package/lens-5.2.2/docs/Control-Lens-Combinators.html#t:Plated">Plated</a> - for recursive data structures</li>
<li><a href="https://www.haskellforall.com/2021/09/optics-are-monoids.html">Optics are monoids</a> - just <code>cosmos</code>!
<ul>
<li><code>adjoin</code> - a union of disjoint traversals</li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=QZy4Yml3LTY">Putting Lenses to Work</a></li>
<li><a href="https://gist.github.com/lgastako/8da651c012c4e341e3ca12f22f08833c">Tree numbering</a> - <code>unsafePartsOf</code></li>
<li>package <a href="https://hackage.haskell.org/package/generic-lens">generic-lens</a>
<ul>
<li>Uses <code>OverloadedLabels</code> to generate lenses and prisms for instances of <code>Generic</code>.</li>
<li>Allows to avoid <code>TemplateHaskell</code> and have more flexible order of expressions in a module.</li>
<li>The disadvantage is runtime costs connected with the usage of generics.</li>
</ul>
</li>
</ul>
<h2 id="optics-by-example"><a class="header" href="#optics-by-example">Optics by example</a></h2>
<p>Notes on <a href="https://leanpub.com/optics-by-example">Optics by example</a>.</p>
<!-- FOURMOLU_DISABLE -->
<pre><code class="language-haskell">{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE InstanceSigs #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE ViewPatterns #-}
{-# LANGUAGE BlockArguments #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE DeriveFoldable #-}
</code></pre>
<!-- D

{-# OPTIONS_GHC -Wno-redundant-constraints #-}
{-# OPTIONS_GHC -Wno-unused-top-binds #-}
{-# OPTIONS_GHC -Wno-unused-imports #-}

E -->
<!-- FOURMOLU_ENABLE -->
<pre><code class="language-haskell">module Book (main) where

import Control.Applicative (Applicative (..))
import Control.Lens
import Control.Lens.Unsound (adjoin, lensProduct)
import Control.Monad.Reader (ReaderT (runReaderT))
import Control.Monad.State ( MonadIO(liftIO), StateT, modify, runState, MonadState(get) )
import Control.Monad.Writer (Writer, WriterT, execWriter, tell)
import Data.Bitraversable (Bitraversable)
import Data.ByteString qualified as BS
import Data.Char (chr, isUpper, ord, toLower, toUpper)
import Data.Either.Validation ( Validation(..) )
import Data.Foldable (Foldable (..))
import Data.Foldable qualified as Foldable
import Data.Generics.Labels ()
import Data.List ( intercalate )
import Data.List qualified as L
import Data.List.NonEmpty (NonEmpty ((:|)), nonEmpty, toList)
import Data.Map (fromList)
import Data.Map qualified as M
import Data.Maybe (fromMaybe, listToMaybe)
import Data.Monoid (Sum (..))
import Data.Ord (comparing)
import Data.Set qualified as S (Set, fromList)
import Data.Text qualified as T
import Data.Text.Lens (unpacked)
import Data.Tree (Tree (..))
import GHC.Word qualified
import Numeric.Lens (adding, multiplying, negated)
import Text.Read (readMaybe)
import Data.Kind (Type)
import qualified Data.Text as Text
import qualified Data.Map as Map

main :: IO ()
main = print &quot;hello&quot;
</code></pre>
<h2 id="3-lenses"><a class="header" href="#3-lenses">3. Lenses</a></h2>
<ul>
<li>A Lens must focus ONE thing inside a structure.</li>
<li>A Lens must never fail to get or set that focus.</li>
</ul>
<h3 id="31-introduction-to-lenses"><a class="header" href="#31-introduction-to-lenses">3.1 Introduction to Lenses</a></h3>
<h4 id="exercises---optic-anatomy"><a class="header" href="#exercises---optic-anatomy">Exercises - Optic Anatomy</a></h4>
<p>Find: action, path, structure, focus</p>
<pre><code class="language-haskell">-- This will be evaluated by HLS
-- &gt;&gt;&gt; view (_1 . _2) ((1, 2), 3)
-- 2

-- This will be evaluated by ghcid

-- $&gt; print &quot;Hello&quot;
</code></pre>
<ul>
<li>action: 'view'</li>
<li>path: <code>(_1 . _2)</code></li>
<li>structure: <code>((1, 2), 3)</code></li>
<li>focus: <code>2</code></li>
</ul>
<pre><code class="language-haskell">-- &gt;&gt;&gt; set (_2 . _Left) &quot;new&quot; (False, Left &quot;old&quot;)
-- (False,Left &quot;new&quot;)
</code></pre>
<ul>
<li>action: <code>set</code></li>
<li>path: <code>(_2 . _Left)</code></li>
<li>structure: <code>(False, Left &quot;old&quot;)</code></li>
<li>focus: <code>&quot;old&quot;</code></li>
</ul>
<pre><code class="language-haskell">-- &gt;&gt;&gt; over (taking 2 worded . traversed) toUpper &quot;testing one two three&quot;
-- &quot;TESTING ONE two three&quot;
</code></pre>
<ul>
<li>action: <code>over</code></li>
<li>path: <code>(taking 2 worded . traversed)</code></li>
<li>structure: <code>&quot;testing one two three&quot;</code></li>
<li>focus: <code>&quot;testing one&quot;</code></li>
</ul>
<pre><code class="language-haskell">-- &gt;&gt;&gt;foldOf (both . each) ([&quot;super&quot;, &quot;cali&quot;],[&quot;fragilistic&quot;, &quot;expialidocious&quot;])
-- &quot;supercalifragilisticexpialidocious&quot;
</code></pre>
<ul>
<li>action: <code>foldOf</code></li>
<li>path: <code>(both . each)</code></li>
<li>structure: <code>([&quot;super&quot;, &quot;cali&quot;],[&quot;fragilistic&quot;, &quot;expialidocious&quot;])</code></li>
<li>focus: <code>[&quot;super&quot;, &quot;cali&quot;, &quot;fragilistic&quot;, &quot;expilidocious&quot;]</code></li>
</ul>
<h3 id="32-lens-actions"><a class="header" href="#32-lens-actions">3.2 Lens Actions</a></h3>
<pre><code class="language-haskell">-- &gt;&gt;&gt;view _1 ('a', 'b')
-- 'a'

-- &gt;&gt;&gt; set _1 'x' ('a', 'b')
-- ('x','b')

-- &gt;&gt;&gt; over _1 (*100) (1, 2)
-- (100,2)
</code></pre>
<h4 id="exercises---lens-actions"><a class="header" href="#exercises---lens-actions">Exercises - Lens Actions</a></h4>
<ol>
<li>
<p>solution:</p>
<!-- i 4 -->
<pre><code class="language-haskell">ex1 :: Lens' (Char, Int) Char
ex1 = undefined
</code></pre>
</li>
<li>
<p>Lens actions:</p>
<ul>
<li>get</li>
<li>set</li>
<li>modify</li>
</ul>
</li>
<li>
<p>focus on <code>c</code></p>
<pre><code class="language-haskell">-- &gt;&gt;&gt;view _3 ('a','b','c')
-- 'c'

-- &gt;&gt;&gt;s = over _2 (*10) (False, 2)
-- &gt;&gt;&gt;:t s
-- s :: Num b =&gt; (Bool, b)
-- &gt;&gt;&gt;s
-- (False,20)
</code></pre>
</li>
</ol>
<!-- d -->
<h3 id="33-lenses-and-records"><a class="header" href="#33-lenses-and-records">3.3 Lenses and records</a></h3>
<pre><code class="language-haskell">data Ship = Ship {_name :: String, _numCrew :: Int} deriving (Show)

name_ :: Lens' Ship String
name_ = lens getName setName
 where
  getName :: Ship -&gt; String
  getName = _name
  setName :: Ship -&gt; String -&gt; Ship
  setName ship _name = ship{_name}

purplePearl :: Ship
purplePearl = Ship{_name = &quot;Purple Pearl&quot;, _numCrew = 38}
</code></pre>
<ol>
<li>
<p>apply lens</p>
<!-- i 4 -->
<pre><code class="language-haskell">-- &gt;&gt;&gt;view name_ purplePearl
-- &quot;Purple Pearl&quot;

-- &gt;&gt;&gt;over name_ (const &quot;Purple  Pearl&quot;) purplePearl
-- Ship {_name = &quot;Purple  Pearl&quot;, _numCrew = 38}

makeLenses ''Ship

-- &gt;&gt;&gt;:t name
-- name :: Lens' Ship String
</code></pre>
</li>
</ol>
<!-- d -->
<h4 id="exercises---records-part-two"><a class="header" href="#exercises---records-part-two">Exercises - Records Part Two</a></h4>
<ol>
<li>
<p>Rewrite</p>
<!-- i 4 -->
<pre><code class="language-haskell">data Spuzz
data Chumble
gazork :: Functor f =&gt; (Spuzz -&gt; f Spuzz) -&gt; Chumble -&gt; f Chumble
gazork = undefined

gazork_ :: Lens' Spuzz Chumble
gazork_ = undefined
</code></pre>
</li>
</ol>
<!-- d -->
<h2 id="34-limitations"><a class="header" href="#34-limitations">3.4 Limitations</a></h2>
<p><strong>Lens</strong> - An optic which always accesses <strong>exactly one focus</strong>.</p>
<h3 id="exercises"><a class="header" href="#exercises">Exercises</a></h3>
<ol>
<li>
<p>Can make both a getter and a setter</p>
<!-- i 4 -->
<pre><code class="language-haskell">get1 :: (a, b, c) -&gt; b
get1 (_, b, _) = b

set1 :: (a, b, c) -&gt; b -&gt; (a, b, c)
set1 (a, _, c) b_ = (a, b_, c)
</code></pre>
</li>
<li>
<p>Can't get from <code>Nothing</code>, so, can't have <code>inMaybe :: Lens' (Maybe a) a</code> not fail sometimes</p>
<pre><code class="language-haskell">get2 :: Maybe a -&gt; a
get2 (Just a) = a
get2 _ = undefined
</code></pre>
</li>
<li>
<p>Similar situation with <code>left :: Lens' (Either a b) a</code></p>
</li>
<li>
<p>No, a list may have &lt; 2 elements</p>
</li>
<li>
<p>Yes, you always can set and get a value, and there'll be only one value focused</p>
<pre><code class="language-haskell">conditional :: Lens' (Bool, a, a) a
conditional = undefined
</code></pre>
</li>
</ol>
<!-- d -->
<h2 id="35-lens-laws"><a class="header" href="#35-lens-laws">3.5 Lens Laws</a></h2>
<p>Allow to reason about a lens' behavior.</p>
<ol>
<li>You get back what you set (set-get)
<ul>
<li><code>view myLens (set myLens newValue structure) == newValue</code></li>
</ul>
</li>
<li>Setting back what you got doesn't do anything (get-set)
<ul>
<li><code>set myLens (view myLens structure) structure == structure</code></li>
</ul>
</li>
<li>Setting twice is the same as setting once (set-set)
<ul>
<li><code>set myLens differentValue (set myLens value structure) == set myLens differentValue structure</code></li>
</ul>
</li>
</ol>
<h3 id="unlawful-lenses"><a class="header" href="#unlawful-lenses">Unlawful lenses</a></h3>
<p>When using unlawful lenses in a library, should write a note.</p>
<p><code>lensProduct</code> combines two lenses to get a new one</p>
<ul>
<li>these lenses should be <strong>disjoint</strong>. Otherwise, how to set?</li>
</ul>
<pre><code class="language-haskell">newtype Ex1 = Ex1 {_unEx1 :: String} deriving (Show, Eq)

makeLenses ''Ex1

alongsideEx1 :: Lens' Ex1 (Ex1, String)
alongsideEx1 = lensProduct id unEx1

ex3 :: Ex1
ex3 = Ex1 &quot;c&quot;

ex4 :: (Ex1, String)
ex4 = (Ex1 &quot;a&quot;, &quot;b&quot;)

-- ex5 :: Bool
ex5 :: (Ex1, String)
ex5 = view alongsideEx1 (set alongsideEx1 ex4 ex3)
</code></pre>
<p>We don't get back what we set:</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt;ex5
-- (Ex1 {_unEx1 = &quot;b&quot;},&quot;b&quot;)

-- &gt;&gt;&gt;ex4 == ex5
-- False
</code></pre>
<h4 id="exercises---laws"><a class="header" href="#exercises---laws">Exercises - Laws</a></h4>
<ol>
<li>
<p>break <code>get-set</code></p>
<!-- i 4 -->
<pre><code class="language-haskell">break2 :: Lens' Ex1 String
break2 = lens (const &quot;1&quot;) (\_ _ -&gt; Ex1 &quot;2&quot;)

ex6 :: String
ex6 = view break2 ex3

-- &gt;&gt;&gt;ex6
-- &quot;1&quot;

ex7 :: Ex1
ex7 = set break2 ex6 ex3

-- &gt;&gt;&gt;ex7
-- Ex1 {_unEx1 = &quot;2&quot;}
</code></pre>
</li>
<li>
<p><code>get-set</code>, <code>set-set</code> work, <code>set-get</code> fails</p>
<pre><code class="language-haskell">data Err
  = ReallyBadError {_msg :: String}
  | ExitCode {_code :: Int}
  deriving (Show, Eq)

msg :: Lens' Err String
msg = lens getMsg setMsg
 where
  getMsg (ReallyBadError message) = message
  -- Hrmm, I guess we just return &quot;&quot;?
  getMsg (ExitCode _) = &quot;&quot;
  setMsg (ReallyBadError _) newMessage = ReallyBadError newMessage
  -- Nowhere to set it, I guess we do nothing?
  setMsg (ExitCode n) _ = ExitCode n

err :: Err
err = ExitCode 3

msgTest :: Bool
msgTest =
  view msg (set msg &quot;a&quot; err) /= &quot;a&quot;
    &amp;&amp; set msg (view msg err) err == err
    &amp;&amp; set msg &quot;a&quot; (set msg &quot;a&quot; err) == set msg &quot;a&quot; err

-- &gt;&gt;&gt;msgTest
-- True
</code></pre>
</li>
<li>
<p>fail <code>get-set</code>, pass other</p>
<pre><code class="language-haskell">msg1 :: Lens' Err String
msg1 = lens getMsg setMsg
 where
  getMsg (ReallyBadError message) = message
  -- Hrmm, I guess we just return &quot;&quot;?
  getMsg (ExitCode _) = &quot;&quot;
  setMsg (ReallyBadError _) newMessage = ReallyBadError newMessage
  -- Nowhere to set it, I guess we do nothing?
  setMsg (ExitCode _) x = ReallyBadError x

msg1Test :: Bool
msg1Test =
  set msg1 (view msg1 err) err /= err
    &amp;&amp; set msg1 &quot;a&quot; (set msg1 &quot;a&quot; err) == set msg1 &quot;a&quot; err
    &amp;&amp; view msg1 (set msg1 &quot;a&quot; err) == &quot;a&quot;

-- &gt;&gt;&gt;msg1Test
-- True
</code></pre>
</li>
<li>
<p>like <code>msg1</code></p>
<pre><code class="language-haskell">data Sink = A Int | B String deriving (Show, Eq)

sink :: Lens' Sink String
sink = lens getSink setSink
 where
  getSink (A x) = show x
  getSink (B x) = x
  setSink (A _) x = B x
  setSink (B _) x = B x

sinkEx :: Sink
sinkEx = A 4

sinkTest :: Bool
sinkTest =
  set sink (view sink sinkEx) sinkEx /= sinkEx
    &amp;&amp; view sink (set sink &quot;a&quot; sinkEx) == &quot;a&quot;
    &amp;&amp; set sink &quot;a&quot; (set sink &quot;a&quot; sinkEx) == set sink &quot;a&quot; sinkEx

-- &gt;&gt;&gt;sinkTest
-- True
</code></pre>
</li>
<li>
<p>break all rules</p>
<pre><code class="language-haskell">newtype Break = Break String deriving (Show, Eq)

break_ :: Break
break_ = Break &quot;hey&quot;

breakAll :: Lens' Break String
breakAll = lens get_ set_
 where
  get_ (Break _) = &quot;!&quot;
  set_ (Break s) x = Break $ s ++ x

breakAllTest :: Bool
breakAllTest =
  set breakAll (view breakAll break_) break_ /= break_
    &amp;&amp; view breakAll (set breakAll &quot;a&quot; break_) /= &quot;a&quot;
    &amp;&amp; set breakAll &quot;a&quot; (set breakAll &quot;a&quot; break_) /= set breakAll &quot;a&quot; break_

-- &gt;&gt;&gt;breakAllTest
-- True
</code></pre>
</li>
<li>
<p>builder</p>
<pre><code class="language-haskell">data Builder = Builder
  { _context :: [String]
  , _build :: [String] -&gt; String
  }

instance Eq Builder where
  (==) :: Builder -&gt; Builder -&gt; Bool
  x == y = x._context == y._context

builderLens :: Lens' Builder String
builderLens = lens builderGet builderSet
 where
  builderGet (Builder{..}) = case _context of [] -&gt; &quot;&quot;; s -&gt; head s
  builderSet (Builder{..}) s = Builder{_context = case s of &quot;&quot; -&gt; []; _ -&gt; [s], ..}

builder1 :: Builder
builder1 = Builder{_context = [], _build = fold}

builderTest :: Bool
builderTest =
  set builderLens (view builderLens builder1) builder1 == builder1
    &amp;&amp; view builderLens (set builderLens &quot;a&quot; builder1) == &quot;a&quot;
    &amp;&amp; view builderLens (set builderLens &quot;&quot; builder1) == &quot;&quot;
    &amp;&amp; set builderLens &quot;a&quot; (set builderLens &quot;a&quot; builder1) == set builderLens &quot;a&quot; builder1
    &amp;&amp; set builderLens &quot;&quot; (set builderLens &quot;&quot; builder1) == set builderLens &quot;&quot; builder1

-- &gt;&gt;&gt;builderTest
-- True
</code></pre>
</li>
</ol>
<!-- d -->
<h3 id="36-virtual-fields"><a class="header" href="#36-virtual-fields">3.6 Virtual Fields</a></h3>
<p>Export only lenses, not constructors. This is to make importing modules independent of a type's inner representation.</p>
<p>For a data type, we can make lenses that hide some computations on the existing type's fields and lenses.</p>
<pre><code class="language-haskell">data Temperature = Temperature
  { _location :: String
  , _celsius :: Float
  }
  deriving (Show)

makeLenses ''Temperature

celsiusToFahrenheit :: Float -&gt; Float
celsiusToFahrenheit c = (c * (9 / 5)) + 32
fahrenheitToCelsius :: Float -&gt; Float
fahrenheitToCelsius f = (f - 32) * (5 / 9)

fahrenheit :: Lens' Temperature Float
fahrenheit = lens getter setter
 where
  getter = celsiusToFahrenheit . view celsius
  setter temp_ f = set celsius (fahrenheitToCelsius f) temp_

temp :: Temperature
temp = Temperature &quot;Berlin&quot; 7.0

-- &gt;&gt;&gt;over fahrenheit (+18) temp
-- Temperature {_location = &quot;Berlin&quot;, _celsius = 17.0}
</code></pre>
<p>When changing a field's name in the original data type,
we can separately export a lens for the old field.
This lens is calculated based on the updated type's fields and lenses.</p>
<pre><code class="language-haskell">data Temperature_ = Temperature_
  { _location_ :: String
  , _kelvin_ :: Float
  }
  deriving (Show)

makeLenses ''Temperature_

celsius_ :: Lens' Temperature_ Float
celsius_ = lens getter setter
 where
  getter = subtract 273.15 . view kelvin_
  setter temp_ c = set kelvin_ (c + 273.15) temp_
</code></pre>
<h4 id="exercises---virtual-fields"><a class="header" href="#exercises---virtual-fields">Exercises - Virtual Fields</a></h4>
<ol>
<li>
<p>substitute lens</p>
<!-- i 4 -->
<pre><code class="language-haskell">data User = User
  { _firstName :: String
  , _lastName :: String
  , _userEmail :: String
  }
  deriving (Show)

makeLenses ''User

username :: Lens' User String
username = lens getter setter
 where
  getter = view userEmail
  setter user_ s = set userEmail s user_
</code></pre>
</li>
<li>
<p>unlawful <code>fullName</code> lens</p>
<pre><code class="language-haskell">fullName :: Lens' User String
fullName = lens getter setter
 where
  getter user_ = view firstName user_ ++ &quot; &quot; ++ view lastName user_
  setter user_ f =
    let fname : (unwords -&gt; lname) = words f
     in set firstName fname (set lastName lname user_)

user :: User
user = User &quot;John&quot; &quot;Cena&quot; &quot;invisible@example.com&quot;

-- &gt;&gt;&gt;view fullName user
-- &quot;John Cena&quot;

-- &gt;&gt;&gt;set fullName &quot;Doctor of Thuganomics&quot; user
-- User {_firstName = &quot;Doctor&quot;, _lastName = &quot;of Thuganomics&quot;, _email = &quot;invisible@example.com&quot;}
</code></pre>
</li>
</ol>
<!-- d -->
<h3 id="37--data-correction-and-maintaining-invariants"><a class="header" href="#37--data-correction-and-maintaining-invariants">3.7  Data correction and maintaining invariants</a></h3>
<p>We can provide some advanced logic in our setters and getters.
E.g., saturate a number to a value between a pair of given values.</p>
<h4 id="exercises---self-correcting-lenses"><a class="header" href="#exercises---self-correcting-lenses">Exercises - Self-Correcting Lenses</a></h4>
<ol>
<li>
<p>and 2.</p>
<!-- i 4 -->
<pre><code class="language-haskell">data ProducePrices = ProducePrices
  { _limePrice :: Float
  , _lemonPrice :: Float
  }
  deriving (Show)

limePrice :: Lens' ProducePrices Float
limePrice = lens getter setter
 where
  getter = _limePrice
  setter ProducePrices{..} p =
    ProducePrices
      { _limePrice = newLimePrice
      , _lemonPrice =
          if abs (_lemonPrice - newLimePrice) &lt;= 0.5
            then _lemonPrice
            else max (newLimePrice + signum (_lemonPrice - newLimePrice) * 0.5) 0
      }
   where
    newLimePrice = max p 0

prices :: ProducePrices
prices = ProducePrices 1.50 1.48

-- &gt;&gt;&gt;set limePrice 2 prices
-- ProducePrices {_limePrice = 2.0, _lemonPrice = 1.5}

-- &gt;&gt;&gt;set limePrice 1.8 prices
-- ProducePrices {_limePrice = 1.8, _lemonPrice = 1.48}

-- &gt;&gt;&gt; set limePrice 1.63 prices
-- ProducePrices {_limePrice = 1.63, _lemonPrice = 1.48}

-- &gt;&gt;&gt;  set limePrice (-1.00) prices
-- ProducePrices {_limePrice = 0.0, _lemonPrice = 0.5}
</code></pre>
</li>
</ol>
<!-- d -->
<h2 id="4-polymorphic-optics"><a class="header" href="#4-polymorphic-optics">4 Polymorphic Optics</a></h2>
<pre><code class="language-hssss">type Lens s t a b = forall f. Functor f =&gt; (a -&gt; f b) -&gt; s -&gt; f t
</code></pre>
<ul>
<li><code>s</code>: structure before action</li>
<li><code>t</code>: structure after action</li>
<li><code>a</code>: focus before action</li>
<li><code>b</code>: focus after action</li>
</ul>
<p><strong>We need polymorphic lenses whenever an action might want to change the type of the focus.</strong></p>
<pre><code class="language-haskell">ex8 :: ([Char], Int)
ex8 = over _1 show (1 :: Int, 1)

-- &gt;&gt;&gt;ex8
-- (&quot;1&quot;,1)

data Promotion a = Promotion
  { _item :: a
  , _discountPercentage :: Double
  }
  deriving (Show)
</code></pre>
<h3 id="42-when-do-we-need-polymorphic-lenses"><a class="header" href="#42-when-do-we-need-polymorphic-lenses">4.2 When do we need polymorphic lenses</a></h3>
<p><code>over :: Lens' s a -&gt; (a -&gt; a) -&gt; s -&gt; s</code></p>
<h4 id="changing-type-variables-with-polymorphic-lenses"><a class="header" href="#changing-type-variables-with-polymorphic-lenses">Changing type variables with polymorphic lenses</a></h4>
<pre><code class="language-haskell">item :: Lens (a, b) (c, b) a c
item = lens getter setter
 where
  getter :: (a, b) -&gt; a
  getter = fst
  setter :: (a, b) -&gt; c -&gt; (c, b)
  setter (_, b) c = (c, b)
</code></pre>
<h4 id="exercises---polymorphic-lenses"><a class="header" href="#exercises---polymorphic-lenses">Exercises - Polymorphic Lenses</a></h4>
<ol>
<li>
<p><code>Vorpal</code></p>
<!-- i 4 -->
<pre><code class="language-haskell">data Vorpal a

vorpal :: Lens (Vorpal a) (Vorpal b) a b
vorpal = undefined
</code></pre>
</li>
<li>
<p>Polymorphic unlawful</p>
<pre><code class="language-haskell">data Preferences a = Preferences {_best :: a, _worst :: a} deriving (Show)

best :: Lens (Preferences a) (Preferences b) a b
best = lens getter setter
 where
  getter (Preferences a _) = a
  setter (Preferences _ _) c = Preferences{_best = c, _worst = c}
</code></pre>
</li>
<li>
<p>Result</p>
<pre><code class="language-haskell">data Result e = Result {_lineNumber :: Int, _result :: Either e String}

result :: Lens (Result a) (Result b) a b
result = undefined
</code></pre>
</li>
<li>
<p>Multiple</p>
<pre><code class="language-haskell">data Multi a b

multi :: Lens (Multi a b) (Multi c d) (a, b) (c, d)
multi = undefined
</code></pre>
</li>
<li>
<p>Predicate</p>
<pre><code class="language-haskell">newtype Predicate a = Predicate (a -&gt; Bool)

predicate :: Lens (Predicate a) (Predicate b) (a -&gt; Bool) (b -&gt; Bool)
predicate = lens getter setter
 where
  getter (Predicate x) = x
  setter (Predicate _) = Predicate
</code></pre>
</li>
</ol>
<!-- d -->
<h4 id="how-do-lens-types-compose"><a class="header" href="#how-do-lens-types-compose">How do Lens Types Compose?</a></h4>
<p>We compose <code>Lens' a b</code> and <code>Lens' b c</code>.</p>
<p>Inside, they are <code>b -&gt; a</code> and <code>c -&gt; b</code> so that we can compose them like <code>(b -&gt; a) . (c -&gt; b)</code></p>
<pre><code class="language-haskell">ex9 :: forall (a :: Type) (b :: Type) (c :: Type) (d :: Type) e f. (e -&gt; f)
ex9 = (d . s) m
 where
  m :: a -&gt; b
  m = undefined
  s :: (a -&gt; b) -&gt; (c -&gt; d)
  s = undefined
  d :: (c -&gt; d) -&gt; (e -&gt; f)
  d = undefined
</code></pre>
<h5 id="example"><a class="header" href="#example">Example</a></h5>
<pre><code class="language-haskell">data Person
data Address
data StreetAddress

personAddressLens :: forall f. Functor f =&gt; (Address -&gt; f Address) -&gt; Person -&gt; f Person
personAddressLens = undefined

personAddressLens_ :: Lens Person Person Address Address
personAddressLens_ = undefined

addressStreetLens :: forall f. Functor f =&gt; (StreetAddress -&gt; f StreetAddress) -&gt; Address -&gt; f Address
addressStreetLens = undefined

addressStreetLens_ :: Lens Address Address StreetAddress StreetAddress
addressStreetLens_ = undefined

personStreetLens :: Functor f =&gt; (StreetAddress -&gt; f StreetAddress) -&gt; Person -&gt; f Person
personStreetLens = personAddressLens . addressStreetLens

personStreet :: StreetAddress
personStreet = view personStreetLens (undefined :: Person)
</code></pre>
<h4 id="exercises---lens-composition"><a class="header" href="#exercises---lens-composition">Exercises - Lens Composition</a></h4>
<ol>
<li>
<p>Pairs</p>
<!-- i 4 -->
<pre><code class="language-haskell">-- &gt;&gt;&gt; view (_2 . _1 . _2) (&quot;Ginerva&quot;, ((&quot;Galileo&quot;, &quot;Waldo&quot;), &quot;Malfoy&quot;))
-- &quot;Waldo&quot;
</code></pre>
</li>
<li>
<p>Domino</p>
<pre><code class="language-haskell">data Five
data Eight
data Two
data Three

fiveEightDomino :: Lens' Five Eight
fiveEightDomino = undefined
twoThreeDomino :: Lens' Two Three
twoThreeDomino = undefined
dominoTrain :: Lens' Five Three
dominoTrain = fiveEightDomino . mysteryDomino . twoThreeDomino

mysteryDomino :: Lens' Eight Two
mysteryDomino = undefined
</code></pre>
</li>
<li>
<p>Rewrite</p>
<pre><code class="language-haskell">data Armadillo
data Hedgehog
data Platypus
data BabySloth

g :: Functor f =&gt; (Armadillo -&gt; f Hedgehog) -&gt; (Platypus -&gt; f BabySloth)
g = undefined

h :: Lens Platypus BabySloth Armadillo Hedgehog
h = undefined
</code></pre>
</li>
<li>
<p>Compose</p>
<pre><code class="language-haskell">data Gazork
data Trowlg
data Bandersnatch
data Yakka
data Zink
data Wattoom
data Grug
data Pubbawup
data Foob
data Mog
data Boojum
data Jabberwock
data Snark
data JubJub

snajubjumwock :: Lens Snark JubJub Boojum Jabberwock
snajubjumwock = undefined
boowockugwup :: Lens Boojum Jabberwock Grug Pubbawup
boowockugwup = undefined
gruggazinkoom :: Lens Grug Pubbawup Zink Wattoom
gruggazinkoom = undefined
zinkattumblezz :: Lens Zink Wattoom Chumble Spuzz
zinkattumblezz = undefined
spuzorktrowmble :: Lens Chumble Spuzz Gazork Trowlg
spuzorktrowmble = undefined
gazorlglesnatchka :: Lens Gazork Trowlg Bandersnatch Yakka
gazorlglesnatchka = undefined
banderyakoobog :: Lens Bandersnatch Yakka Foob Mog
banderyakoobog = undefined

ex10 :: (Foob -&gt; [Mog]) -&gt; Snark -&gt; [JubJub]
ex10 = snajubjumwock @[] . boowockugwup . gruggazinkoom . zinkattumblezz . spuzorktrowmble . gazorlglesnatchka . banderyakoobog
</code></pre>
</li>
</ol>
<!-- d -->
<h2 id="5-operators"><a class="header" href="#5-operators">5. Operators</a></h2>
<p><strong>Fixity</strong> - operator precedence</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt;:t _1 . _2 .~ 3
-- _1 . _2 .~ 3 :: (Field1 s t a1 b1, Field2 a1 b1 a2 b2, Num b2) =&gt; s -&gt; t
</code></pre>
<p>is equivalent to</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt;:t (_1 . _2) .~ 3
-- (_1 . _2) .~ 3 :: (Field1 s t a1 b1, Field2 a1 b1 a2 b2, Num b2) =&gt; s -&gt; t
</code></pre>
<p>We can use <code>&amp;</code> to make a convenient-to-read chain</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt;((2,3),4) &amp; (_1 . _2) .~ 5
-- ((2,5),4)

-- &gt;&gt;&gt; :{
-- unknown command '{'
multiline :: Integer
multiline = 3
</code></pre>
<p>Or even</p>
<pre><code class="language-haskell">ex11 :: ((Integer, Integer), (Integer, Integer))
ex11 =
  ((2, 3), (4, 6))
    &amp; (_1 . _2) .~ 5
    &amp; (_2 . _1) .~ 5

-- &gt;&gt;&gt;ex9
-- ((2,5),(5,6))
</code></pre>
<p>Optics operators - <a href="https://github.com/Zelenya/chrome-annotation-extension-optics/blob/6d9d4459fefc80b36b5e2fc2271fbaaee2923911/src/content.js#L11-L138">src</a></p>
<ul>
<li><code>&lt;|</code> <code>cons</code></li>
<li><code>|&gt;</code> <code>snoc</code></li>
<li><code>^..</code> <code>toListOf</code></li>
<li><code>^?</code> <code>preview</code>/<code>head</code></li>
<li><code>^?!</code> <strong>UNSAFE</strong> <code>preview</code>/<code>head</code></li>
<li><code>^@..</code> <code>itoListOf</code></li>
<li><code>^@?</code> <strong>SAFE</strong> <code>head</code> (with index)</li>
<li><code>^@?!</code> <strong>UNSAFE</strong> <code>head</code> (with index)</li>
<li><code>^.</code> <code>view</code></li>
<li><code>^@.</code> <code>iview</code></li>
<li><code>&lt;.</code> a function composition (<code>Indexed</code> with non-indexed)</li>
<li><code>.&gt;</code> a function composition (non-indexed with <code>Indexed</code>)</li>
<li><code>&lt;.&gt;</code> a composition of Indexed functions</li>
<li><code>%%~</code> modify target; extract functorial/applicative result</li>
<li><code>%%=</code> modify target in state; return extra information</li>
<li><code>&amp;~</code> used to chain lens operations</li>
<li><code>&lt;&amp;&gt;</code> a flipped version of <code>&lt;$&gt;</code></li>
<li><code>??</code> used to flip argument order of composite functions</li>
<li><code>&lt;%~</code> <code>modify</code> lens target; return result</li>
<li><code>&lt;+~</code> increment lens target; return result</li>
<li><code>&lt;-~</code> decrement lens target; return result</li>
<li><code>&lt;*~</code> multiply lens target; return result</li>
<li><code>&lt;//~</code> divide lens target; return result</li>
<li><code>&lt;^~</code> raise lens target; return result</li>
<li><code>&lt;^^~</code> raise lens target; return result</li>
<li><code>&lt;__~</code> raise lens target; return result</li>
<li><code>&lt;||~</code> logically-or lens target; return result</li>
<li><code>&lt;&amp;&amp;~</code> logically-and lens target; return result</li>
<li><code>&lt;&lt;%~</code> <code>modify</code> lens target, return old value</li>
<li><code>&lt;&lt;.~</code> replace lens target, return old value</li>
<li><code>&lt;&lt;?~</code> replace lens target (with <code>Just value</code>), return old value</li>
<li><code>&lt;&lt;+~</code> increment lens target; return old value</li>
<li><code>&lt;&lt;-~</code> decrement lens target; return old value</li>
<li><code>&lt;&lt;*~</code> multiply lens target; return old value</li>
<li><code>&lt;&lt;//~</code> divide lens target; return old value</li>
<li><code>&lt;&lt;^~</code> raise lens target; return old value</li>
<li><code>&lt;&lt;^^~</code> raise lens target; return old value</li>
<li><code>&lt;&lt;__~</code> raise lens target; return old value</li>
<li><code>&lt;||~</code> logically-or lens target; return old value</li>
<li><code>&lt;&amp;&amp;~</code> logically-and lens target; return old value</li>
<li><code>&lt;&lt;&lt;&gt;~</code> <code>modify</code> lens target with (<code>&lt;&gt;</code>); return old value</li>
<li><code>&lt;%=</code> <code>modify</code> target in state; return result</li>
<li><code>&lt;+=</code> add to target in state; return result</li>
<li><code>&lt;-=</code> subtract from target in state; return result</li>
<li><code>&lt;*=</code> multiple the target in state; return result</li>
<li><code>&lt;//=</code> divide the target in state; return result</li>
<li><code>&lt;^=</code> raise lens target in state; return result</li>
<li><code>&lt;^^=</code> raise lens target in state; return result</li>
<li><code>&lt;__=</code> raise lens target in state; return result</li>
<li><code>&lt;||=</code> logically-or lens target in state; return result</li>
<li><code>&lt;&amp;&amp;=</code> logically-and lens target in state; return result</li>
<li><code>&lt;&lt;%=</code> <code>modify</code> lens target in state; return old value</li>
<li><code>&lt;&lt;.=</code> replace lens target in state; return old value</li>
<li><code>&lt;&lt;?=</code> replace target (with Just value) in state, return old value</li>
<li><code>&lt;&lt;+=</code> add to target in state; return old value</li>
<li><code>&lt;&lt;-=</code> subtract from target in state; return old value</li>
<li><code>&lt;&lt;*=</code> multiple the target in state; return old value</li>
<li><code>&lt;&lt;//=</code> divide the target in state; return old value</li>
<li><code>&lt;&lt;^=</code> raise lens target in state; return old value</li>
<li><code>&lt;&lt;^^=</code> raise lens target in state; return old value</li>
<li><code>&lt;&lt;__=</code> raise lens target in state; return old value</li>
<li><code>&lt;&lt;||=</code> logically-or lens target in state; return old value</li>
<li><code>&lt;&lt;&amp;&amp;=</code> logically-and lens target in state; return old value</li>
<li><code>&lt;&lt;&lt;&gt;=</code> <code>modify</code> target with (<code>&lt;&gt;</code>) in state; return old value</li>
<li><code>&lt;&lt;~</code> run monadic action, set lens target</li>
<li><code>&lt;&lt;&gt;~</code> (<code>&lt;&gt;</code>) onto the end of lens target; return result</li>
<li><code>&lt;&lt;&gt;=</code> (<code>&lt;&gt;</code>) onto the end of lens target in state; return result</li>
<li><code>&lt;%@~</code> <code>modify</code> <code>IndexedLens</code> target; return intermediate result</li>
<li><code>&lt;&lt;%@~</code> modify <code>IndexedLens</code> target; return old value</li>
<li><code>%%@~</code> modify <code>IndexedLens</code> target; return supplementary result</li>
<li><code>%%@=</code> modify <code>IndexedLens</code> target in state; return supplementary result</li>
<li><code>&lt;%@=</code> modify <code>IndexedLens</code> target in state; return intermediate result</li>
<li><code>&lt;&lt;%@=</code> modify <code>IndexedLens</code> target in state; return old value</li>
<li><code>^#</code> <code>view</code> (<code>ALens</code> version)</li>
<li><code>#~</code> <code>set</code> (<code>ALens</code> version)</li>
<li><code>#%~</code> <code>over</code> (<code>ALens</code> version)</li>
<li><code>#%%~</code> <code>modify</code> <code>ALens</code> target; extract functorial/applicative result</li>
<li><code>%%=</code> <code>modify</code> target in state; return extra information</li>
<li><code>#=</code> <code>assign</code> (<code>ALens</code> version)</li>
<li><code>#%=</code> <code>map</code> over <code>ALens</code> target(s) in state</li>
<li><code>&lt;#%~</code> <code>modify</code> <code>ALens</code> target; return result</li>
<li><code>&lt;#%=</code> <code>modify</code> <code>ALens</code> target in state; return result</li>
<li><code>#%%=</code> <code>modify</code> <code>ALens</code> target in state; return extra information</li>
<li><code>&lt;#~</code> <code>set</code> with pass-through (<code>ALens</code> version)</li>
<li><code>&lt;#=</code> <code>set</code> with pass-through in state (<code>ALens</code> version)</li>
<li><code>%~</code> <code>over</code> / <code>modify</code> target(s)</li>
<li><code>.~</code> <code>set</code></li>
<li><code>?~</code> <code>set</code> to <code>Just value</code></li>
<li><code>&lt;.~</code> <code>set</code> with pass-through</li>
<li><code>&lt;?~</code> <code>set</code> to <code>Just value</code> with pass-through</li>
<li><code>+~</code> increment target(s)</li>
<li><code>*~</code> multiply target(s)</li>
<li><code>-~</code> decrement target(s)</li>
<li><code>//~</code> divide target(s)</li>
<li><code>^~</code> raise target(s)</li>
<li><code>^~</code> raise target(s)</li>
<li><code>^^~</code> raise target(s)</li>
<li><code>__~</code> raise target(s)</li>
<li><code>||~</code> logically-or target(s)</li>
<li><code>&amp;&amp;~</code> logically-and target(s)</li>
<li><code>.=</code> assign in state</li>
<li><code>%=</code> map over target(s) in state</li>
<li><code>?=</code> <code>set</code> target(s) to <code>Just value</code> in state</li>
<li><code>+=</code> add to target(s) in state</li>
<li><code>*=</code> multiply target(s) in state</li>
<li><code>-=</code> decrement from target(s) in state</li>
<li><code>//=</code> divide target(s) in state</li>
<li><code>^=</code> raise target(s) in state</li>
<li><code>^=</code> raise target(s) in state</li>
<li><code>^^=</code> raise target(s) in state</li>
<li><code>__=</code> raise target(s) in state</li>
<li><code>||=</code> logically-or target(s) in state</li>
<li><code>&amp;&amp;=</code> logically-and target(s) in state</li>
<li><code>&lt;~</code> run monadic action, <code>set</code> target(s) in state</li>
<li><code>&lt;.=</code> <code>set</code> with pass-through in state</li>
<li><code>&lt;?=</code> <code>set</code> <code>Just value</code> with pass-through in state</li>
<li><code>&lt;&gt;~</code> <code>modify</code> target with (<code>&lt;&gt;</code>)</li>
<li><code>&lt;&gt;=</code> <code>modify</code> target with (<code>&lt;&gt;</code>) in state</li>
<li><code>.@~</code> <code>iset</code> / set target(s) with index</li>
<li><code>.@=</code> set target(s) in state with index</li>
<li><code>%@~</code> <code>iover</code> / <code>modify</code> target(s) with index</li>
<li><code>%@=</code> <code>modify</code> target(s) in state with index</li>
<li><code>&amp;</code> a reverse application operator</li>
<li><code>#</code> review</li>
<li><code>id</code> focus the <code>full</code> structure</li>
</ul>
<h3 id="59-exercises---operators"><a class="header" href="#59-exercises---operators">5.9 Exercises - Operators</a></h3>
<ol>
<li>
<p>Get to</p>
<!-- i 4 -->
<pre><code class="language-haskell">data Gate = Gate {_open :: Bool, _oilTemp :: Float} deriving (Show)
makeLenses ''Gate
data Army = Army {_archers :: Int, _knights :: Int} deriving (Show)
makeLenses ''Army
data Kingdom = Kingdom {_name1 :: String, _army :: Army, _gate :: Gate} deriving (Show)
makeLenses ''Kingdom
duloc :: Kingdom
duloc = Kingdom{_name1 = &quot;Duloc&quot;, _army = Army{_archers = 22, _knights = 14}, _gate = Gate{_open = True, _oilTemp = 10.0}}

goalA :: Kingdom
goalA = duloc &amp; name1 &lt;&gt;~ &quot;: a perfect place&quot; &amp; army . knights *~ 3 &amp; gate . open &amp;&amp;~ False

-- &gt;&gt;&gt;goalA
-- Kingdom {_name1 = &quot;Duloc: a perfect place&quot;, _army = Army {_archers = 22, _knights = 42}, _gate = Gate {_open = False, _oilTemp = 10.0}}

goalB :: Kingdom
goalB = duloc &amp; name1 &lt;&gt;~ &quot;cinstein&quot; &amp; army . archers -~ 5 &amp; army . knights +~ 12 &amp; gate . oilTemp *~ 10

-- &gt;&gt;&gt;goalB
-- Kingdom {_name1 = &quot;Duloccinstein&quot;, _army = Army {_archers = 17, _knights = 26}, _gate = Gate {_open = True, _oilTemp = 100.0}}

goalB_ :: Kingdom
goalB_ = duloc &amp; name1 &lt;&gt;~ &quot;cinstein&quot; &amp; army %~ (\x -&gt; x &amp; archers -~ 5 &amp; knights +~ 12) &amp; gate . oilTemp *~ 10

-- &gt;&gt;&gt;goalB_
-- Kingdom {_name1 = &quot;Duloccinstein&quot;, _army = Army {_archers = 17, _knights = 26}, _gate = Gate {_open = True, _oilTemp = 100.0}}

goalC :: (String, Kingdom)
goalC = duloc &amp; gate . oilTemp //~ 2 &amp; name1 &lt;&gt;~ &quot;: Home&quot; &amp; name1 &lt;&lt;%~ (&lt;&gt; &quot;of the talking Donkeys&quot;)

-- &gt;&gt;&gt;goalC
-- (&quot;Duloc: Home&quot;,Kingdom {_name1 = &quot;Duloc: Homeof the talking Donkeys&quot;, _army = Army {_archers = 22, _knights = 14}, _gate = Gate {_open = True, _oilTemp = 5.0}})
</code></pre>
</li>
<li>
<p>Enter code</p>
<pre><code class="language-haskell">ex12 :: (Bool, [Char])
ex12 = (False, &quot;opossums&quot;) &amp; _1 ||~ True

-- &gt;&gt;&gt;ex10
-- (True,&quot;opossums&quot;)

ex13 :: Integer
ex13 = 2 &amp; id *~ 3

-- &gt;&gt;&gt;ex11
-- 6

ex14 :: ((Bool, [Char]), Double)
ex14 =
  ((True, &quot;Dudley&quot;), 55.0)
    &amp; (_1 . _2 &lt;&gt;~ &quot; - the worst&quot;)
    &amp; (_2 -~ 15)
    &amp; (_2 //~ 2)
    &amp; (_1 . _2 %~ map toUpper)
    &amp; (_1 . _1 .~ False)

-- &gt;&gt;&gt;ex12
-- ((False,&quot;DUDLEY - THE WORST&quot;),20.0)
</code></pre>
</li>
<li>
<p><code>&amp;</code></p>
</li>
<li>
<p><code>(%~) :: Lens s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t</code></p>
</li>
</ol>
<!-- d -->
<h2 id="6-folds"><a class="header" href="#6-folds">6. Folds</a></h2>
<ul>
<li>have no laws!</li>
<li>focus on several elements</li>
<li>composition makes successive folds focus on the elements of previous focuses, forming a tree</li>
<li>the result of a composite fold is a <code>Foldable</code> of leaves of such a tree</li>
<li>combinators can work with a set of focuses (leaves) at a necessary level of such a tree</li>
</ul>
<pre><code class="language-haskell">-- &gt;&gt;&gt; [[1, 2, 3], [10, 20, 30], [100, 200, 300]] ^.. folded . taking 2 folded
-- [1,2,10,20,100,200]
</code></pre>
<h3 id="61-introduction-to-folds"><a class="header" href="#61-introduction-to-folds">6.1 Introduction to Folds</a></h3>
<ul>
<li>Folds can focus <strong>MANY</strong> things, Lenses must focus <strong>ONE</strong> thing</li>
<li>Folds can only <strong>get</strong> zero or more things, Lenses must always be able to <strong>get</strong> and <strong>set</strong></li>
<li>Folds aren't polymorphic</li>
</ul>
<h4 id="focusing-all-elements-of-a-container"><a class="header" href="#focusing-all-elements-of-a-container">Focusing all elements of a container</a></h4>
<pre><code class="language-hs">type Fold s a = forall m. Monoid m =&gt; Getting m s a
type Getting r s a = (a -&gt; Const r a) -&gt; s -&gt; Const r s
newtype Const a (b :: k) = Const { getConst :: a }
</code></pre>
<ul>
<li><code>s</code>: structure</li>
<li><code>a</code>: focus</li>
</ul>
<h4 id="collapsing-the-set"><a class="header" href="#collapsing-the-set">Collapsing the Set</a></h4>
<pre><code class="language-hs">folded :: Foldable f =&gt; Fold (f a) a
</code></pre>
<pre><code class="language-haskell">ex15 :: [Integer]
ex15 = [Just 3, Nothing, Nothing] ^.. folded . _Just

-- &gt;&gt;&gt;ex15
-- [3]
</code></pre>
<h4 id="using-lenses-as-folds"><a class="header" href="#using-lenses-as-folds">Using lenses as folds</a></h4>
<p>We have</p>
<pre><code class="language-hs">type Lens s t a b = forall f. Functor f =&gt; (a -&gt; f b) -&gt; s -&gt; f t
type Fold s a = forall m. Monoid m =&gt; Getting m s a
type Getting r s a = (a -&gt; Const r a) -&gt; s -&gt; Const r s
</code></pre>
<p>So, we can use a <code>Lens' s a</code> as a <code>Fold s a</code></p>
<ul>
<li><code>^..</code> first applies the folds, and returns them in a list</li>
</ul>
<pre><code class="language-haskell">getPair2 :: Fold (a, b) b
getPair2 = _2

-- &gt;&gt;&gt;(3,4) ^.. getPair2
-- [4]
</code></pre>
<h4 id="foundational-fold-combinators"><a class="header" href="#foundational-fold-combinators">Foundational fold combinators</a></h4>
<ul>
<li><code>both</code> - Traverse both parts of a Bitraversable container with matching types</li>
<li><code>each</code> - generalizes <code>both</code> for tuples</li>
</ul>
<pre><code class="language-haskell">ex16 :: [Integer]
ex16 = (1, 2) ^.. both

-- &gt;&gt;&gt;ex16
-- [1,2]

ex17 :: [Integer]
ex17 = (1, 2, 4, 5, 6) ^.. each

-- &gt;&gt;&gt;ex17
-- [1,2,4,5,6]

ex18 :: [GHC.Word.Word8]
ex18 = (&quot;Do or do not&quot; :: BS.ByteString) ^.. each
</code></pre>
<h4 id="exercises---simple-folds"><a class="header" href="#exercises---simple-folds">Exercises - Simple Folds</a></h4>
<ol>
<li>beasts</li>
</ol>
<pre><code class="language-haskell">beastSizes :: [(Int, String)]
beastSizes = [(3, &quot;Sirens&quot;), (882, &quot;Kraken&quot;), (92, &quot;Ogopogo&quot;)]

-- &gt;&gt;&gt; beastSizes ^.. folded
-- [(3,&quot;Sirens&quot;),(882,&quot;Kraken&quot;),(92,&quot;Ogopogo&quot;)]

-- &gt;&gt;&gt; beastSizes ^.. folded . folded
-- [&quot;Sirens&quot;,&quot;Kraken&quot;,&quot;Ogopogo&quot;]

-- &gt;&gt;&gt; beastSizes ^.. folded . folded . folded
-- &quot;SirensKrakenOgopogo&quot;

-- &gt;&gt;&gt; beastSizes ^.. folded . _2
-- [&quot;Sirens&quot;,&quot;Kraken&quot;,&quot;Ogopogo&quot;]

-- &gt;&gt;&gt; toListOf (folded . folded) [[1, 2, 3], [4, 5, 6]]
-- [1,2,3,4,5,6]

ex19 :: [Char]
ex19 = toListOf (folded . folded) (M.fromList [(&quot;Jack&quot; :: String, &quot;Captain&quot; :: String), (&quot;Will&quot;, &quot;First Mate&quot;)])

-- &gt;&gt;&gt; ex19
-- &quot;CaptainFirst Mate&quot;

-- &gt;&gt;&gt; (&quot;Hello&quot; :: String, &quot;It's me&quot;) ^.. both . folded
-- &quot;HelloIt's me&quot;

-- &gt;&gt;&gt; (&quot;Why&quot;, &quot;So&quot;, &quot;Serious?&quot;) ^.. each
-- [&quot;Why&quot;,&quot;So&quot;,&quot;Serious?&quot;]

quotes :: [(T.Text, T.Text, T.Text)]
quotes = [(&quot;Why&quot;, &quot;So&quot;, &quot;Serious?&quot;), (&quot;This&quot;, &quot;is&quot;, &quot;SPARTA&quot;)]

ex20 :: [Char]
ex20 = quotes ^.. each . each . each

-- &gt;&gt;&gt; ex20
-- &quot;WhySoSerious?ThisisSPARTA&quot;
</code></pre>
<ol>
<li>Blank</li>
</ol>
<pre><code class="language-haskell">-- &gt;&gt;&gt;[1, 2, 3] ^.. folded
-- [1,2,3]

-- &gt;&gt;&gt; (&quot;Light&quot;, &quot;Dark&quot;) ^.. _1
-- [&quot;Light&quot;]

-- &gt;&gt;&gt; [(&quot;Light&quot;, &quot;Dark&quot;), (&quot;Happy&quot;, &quot;Sad&quot;)] ^.. each . each
-- [&quot;Light&quot;,&quot;Dark&quot;,&quot;Happy&quot;,&quot;Sad&quot;]

-- &gt;&gt;&gt; [(&quot;Light&quot;, &quot;Dark&quot;), (&quot;Happy&quot;, &quot;Sad&quot;)] ^.. each . _1
-- [&quot;Light&quot;,&quot;Happy&quot;]

ex21 :: String
ex21 = ([(&quot;Light&quot;, &quot;Dark&quot; :: String), (&quot;Happy&quot;, &quot;Sad&quot;)] ^.. each . _2) ^.. each . each

-- &gt;&gt;&gt; ex21
-- &quot;DarkSad&quot;

-- &gt;&gt;&gt; (&quot;Bond&quot;, &quot;James&quot;, &quot;Bond&quot;) ^.. each
-- [&quot;Bond&quot;,&quot;James&quot;,&quot;Bond&quot;]
</code></pre>
<h3 id="62-custom-folds"><a class="header" href="#62-custom-folds">6.2 Custom Folds</a></h3>
<p>We should project the pieces of a structure into something <code>Foldable</code>. Then, we can construct a <code>Fold</code>.</p>
<pre><code class="language-hs">folding :: Foldable f =&gt; (s -&gt; f a) -&gt; Fold s a
</code></pre>
<pre><code class="language-haskell">newtype Name = Name
  { getName :: String
  }
  deriving (Show)
data ShipCrew = ShipCrew
  { _shipName :: Name
  , _captain :: Name
  , _firstMate :: Name
  , _conscripts :: [Name]
  }
  deriving (Show)
makeLenses ''ShipCrew

myCrew :: ShipCrew
myCrew =
  ShipCrew
    { _shipName = Name &quot;Purple Pearl&quot;
    , _captain = Name &quot;Grumpy Roger&quot;
    , _firstMate = Name &quot;Long-John Bronze&quot;
    , _conscripts = [Name &quot;One-eyed Jack&quot;, Name &quot;Filthy Frank&quot;]
    }

collectCrewMembers :: ShipCrew -&gt; [Name]
collectCrewMembers sc = [sc ^. captain, sc ^. firstMate] ++ sc ^. conscripts

crewMembers :: Fold ShipCrew Name
crewMembers = folding collectCrewMembers

-- &gt;&gt;&gt;myCrew ^.. crewMembers
-- [Name {getName = &quot;Grumpy Roger&quot;},Name {getName = &quot;Long-John Bronze&quot;},Name {getName = &quot;One-eyed Jack&quot;},Name {getName = &quot;Filthy Frank&quot;}]
</code></pre>
<h4 id="mapping-over-folds"><a class="header" href="#mapping-over-folds">Mapping over folds</a></h4>
<p><code>to</code></p>
<ul>
<li>
<p>converts a function into a <code>Getter</code>.</p>
</li>
<li>
<p>that's why, should never fail to get something from a structure.</p>
</li>
<li>
<p>Book:</p>
<pre><code class="language-hs">to :: (s -&gt; a) -&gt; Fold s a
</code></pre>
</li>
<li>
<p>Real:</p>
</li>
</ul>
<pre><code class="language-haskell">-- &gt;&gt;&gt;:t to
-- to :: (Profunctor p, Contravariant f) =&gt; (s -&gt; a) -&gt; Optic' p f s a
</code></pre>
<pre><code class="language-hs">class Profunctor (p :: Type -&gt; Type -&gt; Type) where
  dimap :: (a -&gt; b) -&gt; (c -&gt; d) -&gt; p b c -&gt; p a d
</code></pre>
<ul>
<li><a href="https://github.com/ocharles/blog/blob/master/guest-posts/2013-12-22-24-days-of-hackage-profunctors.md">Profunctors</a></li>
</ul>
<p>Example</p>
<pre><code class="language-haskell">ex22 :: [Char]
ex22 = &quot;Two-faced Tony&quot; ^. to (take 2)

-- &gt;&gt;&gt; ex22
-- &quot;Tw&quot;
</code></pre>
<p>Composition</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt; Name &quot;Two-faced Tony&quot; ^. to getName . to (fmap toUpper)
-- &quot;TWO-FACED TONY&quot;

-- &gt;&gt;&gt; Name &quot;Two-faced Tony&quot; ^. to (fmap toUpper . getName)
-- &quot;TWO-FACED TONY&quot;

-- &gt;&gt;&gt; myCrew ^.. crewMembers . to getName
-- [&quot;Grumpy Roger&quot;,&quot;Long-John Bronze&quot;,&quot;One-eyed Jack&quot;,&quot;Filthy Frank&quot;]
</code></pre>
<h4 id="combining-multiple-folds-on-the-same-structure"><a class="header" href="#combining-multiple-folds-on-the-same-structure">Combining multiple folds on the same structure</a></h4>
<pre><code class="language-haskell">crewNames1 :: ShipCrew -&gt; [Name]
crewNames1 sc = [captain, firstMate] ^.. folded . to (sc ^.) &lt;&gt; sc ^. conscripts

crewNames2 :: Fold ShipCrew Name
crewNames2 = folding (\s -&gt; foldMap (s ^..) [captain, firstMate, conscripts . folded])

crewNames3 :: Fold ShipCrew Name
crewNames3 = folding (\s -&gt; [captain, firstMate, conscripts . folded] ^.. folded . to (s ^..) . folded)

-- &gt;&gt;&gt; myCrew ^.. crewNames2 . to getName
-- [&quot;Grumpy Roger&quot;,&quot;Long-John Bronze&quot;,&quot;One-eyed Jack&quot;,&quot;Filthy Frank&quot;]
</code></pre>
<h4 id="exercises---custom-folds"><a class="header" href="#exercises---custom-folds">Exercises - Custom Folds</a></h4>
<ol>
<li>
<p>blanks</p>
<!-- i 4 -->
<pre><code class="language-haskell">ex23 :: [Char]
ex23 = [&quot;Yer&quot; :: String, &quot;a&quot;, &quot;wizard&quot;, &quot;Harry&quot;] ^.. folded . folded

-- &gt;&gt;&gt; ex23
-- &quot;YerawizardHarry&quot;

-- &gt;&gt;&gt; [[1, 2, 3], [4, 5, 6]] ^.. folded . folding (take 2)
-- [1,2,4,5]

-- &gt;&gt;&gt; [[1, 2, 3], [4, 5, 6]] ^.. folded . to (take 2)
-- [[1,2],[4,5]]

-- &gt;&gt;&gt; [&quot;bob&quot;, &quot;otto&quot;, &quot;hannah&quot;] ^.. folded . to reverse
-- [&quot;bob&quot;,&quot;otto&quot;,&quot;hannah&quot;]

-- &gt;&gt;&gt; (&quot;abc&quot;, &quot;def&quot;) ^.. folding (\(a, b) -&gt; [a, b]). to reverse . folded
-- &quot;cbafed&quot;
</code></pre>
</li>
<li>
<p>fold paths</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt; [1..5] ^.. folded . folding (\x -&gt; [x * 100])
-- [100,200,300,400,500]

-- &gt;&gt;&gt; (1, 2) ^.. folding (\(a,b) -&gt; [a, b])
-- [1,2]

-- &gt;&gt;&gt; [(1, &quot;one&quot;), (2, &quot;two&quot;)] ^.. folded . folding (\(_,x) -&gt; [x])
-- [&quot;one&quot;,&quot;two&quot;]

ex24 :: [Int]
ex24 = (Just 1, Just 2, Just 3) ^.. folding (\(a, b, c) -&gt; [a, b, c]) . folded

-- &gt;&gt;&gt; ex24
-- [1,2,3]

ex25 :: [Int]
ex25 = [Left 1, Right 2, Left 3] ^.. folded . folded

-- &gt;&gt;&gt; ex25
-- [2]

ex26 :: [Int]
ex26 = [([1, 2], [3, 4]), ([5, 6], [7, 8])] ^.. folded . folding (uncurry (&lt;&gt;))

-- &gt;&gt;&gt; ex26
-- [1,2,3,4,5,6,7,8]

-- &gt;&gt;&gt; [1, 2, 3, 4] ^.. folded . to (\x -&gt; (if odd x then Left else Right) x)
-- [Left 1,Right 2,Left 3,Right 4]

-- &gt;&gt;&gt; [(1, (2, 3)), (4, (5, 6))] ^.. folded . folding (\(a, (b,c)) -&gt; [a,b,c])
-- [1,2,3,4,5,6]

ex27 :: [Integer]
ex27 = [(Just 1, Left &quot;one&quot;), (Nothing, Right 2)] ^.. folded . folding (\(x, y) -&gt; x ^.. folded &lt;&gt; y ^.. folded)

-- &gt;&gt;&gt; ex27
-- [1,2]

ex28 :: [Either Integer String]
ex28 = [(1, &quot;one&quot;), (2, &quot;two&quot;)] ^.. folded . folding (\(x, y) -&gt; [Left x, Right y])

-- &gt;&gt;&gt; ex28
-- [Left 1,Right &quot;one&quot;,Left 2,Right &quot;two&quot;]

-- &gt;&gt;&gt; S.fromList [&quot;apricots&quot;, &quot;apples&quot;] ^.. folded . to reverse . folded
-- &quot;selppastocirpa&quot;
</code></pre>
</li>
<li>
<p>outside of the box</p>
<pre><code class="language-haskell">ex29 :: [Char]
ex29 = [(12, 45, 66), (91, 123, 87)] ^.. folded . folding (\(_, x, _) -&gt; reverse (show x))

-- &gt;&gt;&gt; ex29
-- &quot;54321&quot;

-- &gt;&gt;&gt; [(1, &quot;a&quot;), (2, &quot;b&quot;), (3, &quot;c&quot;), (4, &quot;d&quot;)] ^.. folded . folding (\(x,y) -&gt; if odd x then [] else [y])
-- [&quot;b&quot;,&quot;d&quot;]
</code></pre>
</li>
</ol>
<!-- d -->
<h3 id="63-fold-actions"><a class="header" href="#63-fold-actions">6.3 Fold Actions</a></h3>
<p>Fold queries</p>
<ul>
<li>Which focuses match this <strong>predicate</strong>?</li>
<li>What's the <strong>largest</strong> element in my structure</li>
<li>What's the result of running this <strong>side-effect</strong> on every focus?</li>
<li>What's the <strong>sum</strong> of these numeric focuses?</li>
<li>Does this fold focus <strong>any</strong> elements?</li>
<li>Does this <strong>specific value</strong> exist in my structure?</li>
</ul>
<h4 id="writing-queries-with-folds"><a class="header" href="#writing-queries-with-folds">Writing queries with folds</a></h4>
<p>There are folds for common functions like</p>
<ul>
<li><code>minimumOf</code></li>
<li><code>sumOf</code></li>
</ul>
<pre><code class="language-hs">sumOf :: Num a =&gt; Getting (Endo (Endo a)) s a -&gt; s -&gt; a
</code></pre>
<p>Instead of <code>Getting (Some type) s a</code>, can put many optics, e.g., <code>Fold s a</code>.</p>
<ul>
<li><code>elemOf :: Eq a =&gt; Fold s a -&gt; a -&gt; s -&gt; Bool</code> - does a fold contain an element?</li>
<li><code>anyOf :: Fold s a -&gt; (a -&gt; Bool) -&gt; s -&gt; Bool</code> - does any focus match a predicate?</li>
<li><code>allOf :: Fold s a -&gt; (a -&gt; Bool) -&gt; s -&gt; Bool</code> - do all focuses match a predicate?</li>
<li><code>findOf :: Fold s a -&gt; (a -&gt; Bool) -&gt; s -&gt; Maybe a</code> - find the first elem that matches a predicate</li>
<li><code>has :: Fold s a -&gt; s -&gt; Bool</code> - does my fold have any elements</li>
<li><code>hasn't :: Fold s a -&gt; s -&gt; Bool</code> - or not?</li>
<li><code>lengthOf :: Fold s a -&gt; s -&gt; Int</code> - how many focuses are there?</li>
<li><code>sumOf :: Num n =&gt; Fold s n -&gt; s -&gt; n</code> - sum of focuses</li>
<li><code>productOf :: Num n =&gt; Fold s n -&gt; s -&gt; n</code> - their product</li>
<li><code>firstOf :: Fold s a -&gt; s -&gt; Maybe a</code> - get the first focus</li>
<li><code>preview :: Fold s a -&gt; s -&gt; Maybe a</code> - like <code>firstOf</code></li>
<li><code>(^?) :: s -&gt; Fold s a -&gt; Maybe a</code> - like <code>firstOf</code></li>
<li><code>worded :: Fold String String</code> - like words</li>
<li><code>lastOf :: Fold s a -&gt; s -&gt; Maybe a</code> - get the last focus</li>
<li><code>minimumOf :: Ord a =&gt; Fold s a -&gt; s -&gt; Maybe a</code> - minimum</li>
<li><code>maximumOf :: Ord a =&gt; Fold s a -&gt; s -&gt; Maybe a</code> - maximum</li>
<li><code>maximumByOf :: Fold s a -&gt; (a -&gt; a -&gt; Ordering) -&gt; s -&gt; Maybe a</code> - max element by a comparison func</li>
<li><code>folding :: Foldable f =&gt; (s -&gt; f a) -&gt; Fold s a</code> - convert structure to a <code>Foldable</code></li>
<li><code>foldrOf :: Fold s a -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r</code> - like foldr</li>
<li><code>foldlOf :: Fold s a -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r</code> - like foldl</li>
<li><code>foldMapOf :: Monoid r =&gt; Fold s a -&gt; (a -&gt; r) -&gt; s -&gt; r</code> - like foldMap</li>
<li><code>foldByOf :: Fold s a -&gt; (a -&gt; a -&gt; a) -&gt; a -&gt; s -&gt; a</code> - lets use a custom <code>(&lt;&gt;) :: a -&gt; a -&gt; a</code></li>
<li><code>foldMapByOf :: Fold s a -&gt; (r -&gt; r -&gt; r) -&gt; r -&gt; (a -&gt; r) -&gt; s -&gt; r</code> - same, but also lets map to a <code>Monoid</code></li>
</ul>
<pre><code class="language-haskell">data Actor = Actor
  { _actorName :: String
  , _birthYear :: Int
  }
  deriving (Show, Eq)
makeLenses ''Actor

data TVShow = TVShow
  { _title :: String
  , _numEpisodes :: Int
  , _numSeasons :: Int
  , _criticScore :: Double
  , _actors :: [Actor]
  }
  deriving (Show, Eq)
makeLenses ''TVShow

howIMetYourMother :: TVShow
howIMetYourMother =
  TVShow
    { _title = &quot;How I Met Your Mother&quot;
    , _numEpisodes = 208
    , _numSeasons = 9
    , _criticScore = 83
    , _actors =
        [ Actor &quot;Josh Radnor&quot; 1974
        , Actor &quot;Cobie Smulders&quot; 1982
        , Actor &quot;Neil Patrick Harris&quot; 1973
        , Actor &quot;Alyson Hannigan&quot; 1974
        , Actor &quot;Jason Segel&quot; 1980
        ]
    }
buffy :: TVShow
buffy =
  TVShow
    { _title = &quot;Buffy the Vampire Slayer&quot;
    , _numEpisodes = 144
    , _numSeasons = 7
    , _criticScore = 81
    , _actors =
        [ Actor &quot;Sarah Michelle Gellar&quot; 1977
        , Actor &quot;Alyson Hannigan&quot; 1974
        , Actor &quot;Nicholas Brendon&quot; 1971
        , Actor &quot;David Boreanaz&quot; 1969
        , Actor &quot;Anthony Head&quot; 1954
        ]
    }

tvShows :: [TVShow]
tvShows =
  [ howIMetYourMother
  , buffy
  ]

-- &gt;&gt;&gt; sumOf (folded . numEpisodes) tvShows
-- 352

comparingOf :: Ord a =&gt; Getting a s a -&gt; s -&gt; s -&gt; Ordering
comparingOf l = comparing (view l)

ex30 :: Maybe Actor
ex30 = maximumByOf (folded . actors . folded) (comparingOf birthYear) tvShows

-- &gt;&gt;&gt; ex30
-- Just (Actor {_actorName = &quot;Cobie Smulders&quot;, _birthYear = 1982})
</code></pre>
<h4 id="folding-with-effects"><a class="header" href="#folding-with-effects">Folding with effects</a></h4>
<p>Effectful folding</p>
<ul>
<li><code>traverse_ :: (Foldable t, Applicative f) =&gt; (a -&gt; f b) -&gt; t a -&gt; f ()</code> - fold with effects</li>
</ul>
<p>Similar to ordinary <code>Foldable</code> functions:</p>
<ul>
<li><code>traverseOf_ :: Functor f =&gt; Fold s a -&gt; (a -&gt; f r) -&gt; s -&gt; f ()</code></li>
<li><code>forOf_ :: Functor f =&gt; Fold s a -&gt; s -&gt; (a -&gt; f r) -&gt; f ()</code></li>
</ul>
<p>Uses just <code>Functor</code> (not <code>Applicative</code>) as <code>Lens</code> focuses a single element.</p>
<pre><code class="language-haskell">calcAge :: Actor -&gt; Int
calcAge actor = 2030 - actor ^. birthYear

showActor :: Actor -&gt; String
showActor actor = actor ^. actorName &lt;&gt; &quot;: &quot; &lt;&gt; show (calcAge actor)

-- $&gt; traverseOf_ (folded . actors . folded . to showActor) putStrLn tvShows

-- &gt;&gt;&gt; import Control.Monad.State
-- &gt;&gt;&gt; execState (traverseOf_ (folded . actors . folded) (modify . const (+1)) tvShows) 0
-- 10
</code></pre>
<h4 id="combining-fold-results"><a class="header" href="#combining-fold-results">Combining fold results</a></h4>
<p><code>Fold</code>s are all about collecting pieces of things and <code>Monoid</code>s are all about combining
things together. We can find many focuses within a structure,
then combine the pieces together using a <code>Monoid</code>.</p>
<pre><code class="language-hs">foldOf :: Getting a s a -&gt; s -&gt; a
foldMapOf :: Getting r s a -&gt; (a -&gt; r) -&gt; s -&gt; r
</code></pre>
<p>Implement an average fold</p>
<pre><code class="language-haskell">ageSummary :: Actor -&gt; (Sum Int, Sum Int)
ageSummary actor = (Sum 1, Sum (calcAge actor))

ex31 :: Double
ex31 = fromIntegral age / fromIntegral n
 where
  sums = foldMapOf (folded . actors . folded) ageSummary tvShows
  n = getSum (fst sums)
  age = getSum (snd sums)

-- &gt;&gt;&gt; ex31
-- 57.2
</code></pre>
<h4 id="using-view-on-folds"><a class="header" href="#using-view-on-folds">Using <code>view on folds</code></a></h4>
<p>Don't use <code>view</code> or <code>^.</code> on folds. It works only if focuses are <code>Monoid</code>s. Use <code>foldOf</code></p>
<pre><code class="language-haskell">-- &gt;&gt;&gt; Just (42 :: Int) ^. folded
-- No instance for (Monoid Int) arising from a use of `folded'
-- In the second argument of `(^.)', namely `folded'
-- In the expression: Just (42 :: Int) ^. folded
-- In an equation for `it_a2Cc0O':
--     it_a2Cc0O = Just (42 :: Int) ^. folded
</code></pre>
<h4 id="customizing-monoidal-folds"><a class="header" href="#customizing-monoidal-folds">Customizing monoidal folds</a></h4>
<p>These functions allow customizing the (&lt;&gt;) operation on <code>Monoid</code>s</p>
<pre><code class="language-hs">folding :: Foldable f =&gt; (s -&gt; f a) -&gt; Fold s a
foldByOf :: Fold s a -&gt; (a -&gt; a -&gt; a) -&gt; a -&gt; s -&gt; a
foldMapByOf :: Fold s a -&gt; (r -&gt; r -&gt; r) -&gt; r -&gt; (a -&gt; r) -&gt; s -&gt; r
foldrOf :: Fold s a -&gt; (a -&gt; r -&gt; r) -&gt; r -&gt; s -&gt; r
foldlOf :: Fold s a -&gt; (r -&gt; a -&gt; r) -&gt; r -&gt; s -&gt; r
</code></pre>
<pre><code class="language-haskell">ex32 :: M.Map String Int
ex32 =
  foldMapByOf
    -- Focus each actor's name
    (folded . actors . folded . actorName)
    -- Combine duplicate keys with addition
    (M.unionWith (+))
    -- start with the empty Map
    mempty
    -- inject names into Maps with a count of 1
    (`M.singleton` 1)
    tvShows

-- &gt;&gt;&gt; ex32
-- fromList [(&quot;Alyson Hannigan&quot;,2),(&quot;Anthony Head&quot;,1),(&quot;Cobie Smulders&quot;,1),(&quot;David Boreanaz&quot;,1),(&quot;Jason Segel&quot;,1),(&quot;Josh Radnor&quot;,1),(&quot;Neil Patrick Harris&quot;,1),(&quot;Nicholas Brendon&quot;,1),(&quot;Sarah Michelle Gellar&quot;,1)]
</code></pre>
<h4 id="exercises---fold-actions"><a class="header" href="#exercises---fold-actions">Exercises - Fold Actions</a></h4>
<ol>
<li>
<p>pick action</p>
<!-- i 4 -->
<pre><code class="language-haskell">-- &gt;&gt;&gt; has folded []
-- False

-- &gt;&gt;&gt; foldOf both (&quot;Yo&quot;, &quot;Adrian!&quot;)
-- &quot;YoAdrian!&quot;

-- &gt;&gt;&gt; elemOf each &quot;phone&quot; (&quot;E.T.&quot;, &quot;phone&quot;, &quot;home&quot;)
-- True

-- &gt;&gt;&gt; minimumOf folded [5, 7, 2, 3, 13, 17, 11]
-- Just 2

-- &gt;&gt;&gt; maximumOf folded [5, 7, 2, 3, 13, 17, 11]
-- Just 17

-- &gt;&gt;&gt; anyOf folded ((&gt; 9) . length) [&quot;Bulbasaur&quot;, &quot;Charmander&quot;, &quot;Squirtle&quot;]
-- True

-- &gt;&gt;&gt; findOf folded even [11, 22, 3, 5, 6]
-- Just 22
</code></pre>
</li>
<li>
<p>devise folds</p>
<pre><code class="language-haskell">ex33 :: Maybe String
ex33 = findOf folded (\x -&gt; x == reverse x) [&quot;umbrella&quot;, &quot;olives&quot;, &quot;racecar&quot;, &quot;hammer&quot;]

-- &gt;&gt;&gt;ex33
-- Just &quot;racecar&quot;

-- &gt;&gt;&gt;allOf each even (2,4,6)
-- True

ex34 :: Maybe (Int, String)
ex34 = maximumByOf folded (\x y -&gt; compare (x ^. _1) (y ^. _1)) [(2 :: Int, &quot;I'll&quot; :: String), (3, &quot;Be&quot;), (1, &quot;Back&quot;)]

-- &gt;&gt;&gt; ex34
-- Just (3,&quot;Be&quot;)

-- &gt;&gt;&gt; sumOf each (1,2)
-- 3
</code></pre>
</li>
<li>
<p>bonus</p>
<pre><code class="language-haskell">isVowel :: Char -&gt; Bool
isVowel x = x `elem` (&quot;aouiey&quot; :: String)

ex35 :: Maybe String
ex35 =
  maximumByOf
    worded
    (\x y -&gt; let s = (length . filter isVowel) in compare (s x) (s y))
    (&quot;Do or do not, there is no try.&quot; :: String)

-- &gt;&gt;&gt; ex35
-- Just &quot;there&quot;
</code></pre>
</li>
</ol>
<!-- d -->
<h3 id="64-higher-order-folds"><a class="header" href="#64-higher-order-folds">6.4 Higher Order Folds</a></h3>
<p>There're optics combinators that <strong>alter other optics</strong>. They accept an optic and return a new one.</p>
<p>(with simplified types)</p>
<ul>
<li><code>taking :: Int -&gt; Fold s a -&gt; Fold s a</code> - like <code>take</code></li>
<li><code>dropping :: Int -&gt; Fold s a -&gt; Fold s a</code> - like <code>drop</code></li>
<li><code>takingWhile :: (a -&gt; Bool) -&gt; Fold s a -&gt; Fold s a</code> - like <code>takeWhile</code></li>
<li><code>droppingWhile :: (a -&gt; Bool) -&gt; Fold s a -&gt; Fold s a</code> - like <code>dropWhile</code></li>
<li><code>backwards :: Fold s a -&gt; Fold s a</code> - reverse the order of focuses of a fold</li>
</ul>
<h4 id="taking-dropping"><a class="header" href="#taking-dropping">Taking, Dropping</a></h4>
<p>(real types are complex)</p>
<p>take N focuses</p>
<pre><code class="language-hs">taking :: Int -&gt; Fold s a -&gt; Fold s a
dropping :: Int -&gt; Fold s a -&gt; Fold s a
</code></pre>
<pre><code class="language-haskell">-- &gt;&gt;&gt;[3,5,4,6,7] ^.. taking 3 folded
-- [3,5,4]

-- &gt;&gt;&gt;[3,5,4,6,7] ^.. dropping 3 folded
-- [6,7]
</code></pre>
<p>Since new folds branch on focuses, the next optics are applied on each branch separately.</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt; [[1, 2, 3], [10, 20, 30], [100, 200, 300]] ^.. folded . taking 2 folded
-- [1,2,10,20,100,200]

-- &gt;&gt;&gt; (&quot;Albus&quot; :: String, &quot;Dumbledore&quot;) ^.. both . taking 3 folded
-- &quot;AlbDum&quot;
</code></pre>
<p>We can move the combinator to operate on the necessary set of focuses, e.g., the final one.</p>
<pre><code class="language-haskell">-- No brackets; we're taking '3' from the results of 'both', then folding them
-- &gt;&gt;&gt; (&quot;Albus&quot; :: String, &quot;Dumbledore&quot;) ^.. taking 3 both . folded
-- &quot;AlbusDumbledore&quot;

-- &gt;&gt;&gt; (&quot;Albus&quot; :: String, &quot;Dumbledore&quot;) ^.. taking 3 (both . folded)
-- &quot;Alb&quot;

-- &gt;&gt;&gt; (&quot;Albus&quot; :: String, &quot;Dumbledore&quot;) ^.. dropping 2 (both . folded)
-- &quot;busDumbledore&quot;
</code></pre>
<h4 id="backwards"><a class="header" href="#backwards">Backwards</a></h4>
<p>Reverses the order of a fold.</p>
<p>Book:</p>
<pre><code class="language-hs">backwards :: Fold s a -&gt; Fold s a
</code></pre>
<p>Real:</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt;:t backwards
-- backwards
--   :: (Profunctor p, Profunctor q) =&gt;
--      Optical p q (Backwards f) s t a b -&gt; Optical p q f s t a b
</code></pre>
<p>Examples:</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt; [1, 2, 3] ^.. backwards folded
-- [3,2,1]
</code></pre>
<h4 id="takingwhile-droppingwhile"><a class="header" href="#takingwhile-droppingwhile">takingWhile, droppingWhile</a></h4>
<pre><code class="language-haskell">-- &gt;&gt;&gt; [1..100] ^.. takingWhile (&lt;10) folded
-- [1,2,3,4,5,6,7,8,9]

-- &gt;&gt;&gt; [1..100] ^.. droppingWhile (&lt;90) folded
-- [90,91,92,93,94,95,96,97,98,99,100]
</code></pre>
<h4 id="exercises---higher-order-folds"><a class="header" href="#exercises---higher-order-folds">Exercises - Higher Order Folds</a></h4>
<ol>
<li>
<p>blanks</p>
<!-- i 4 -->
<pre><code class="language-haskell">-- &gt;&gt;&gt; (&quot;Here's looking at you, kid&quot; :: String) ^.. dropping 7 folded
-- &quot;looking at you, kid&quot;

-- &gt;&gt;&gt; [&quot;My Precious&quot; :: String, &quot;Hakuna Matata&quot;, &quot;No problemo&quot;] ^.. folded . taking 1 .
-- &quot;MHN&quot;

-- &gt;&gt;&gt; [&quot;My Precious&quot;, &quot;Hakuna Matata&quot;, &quot;No problemo&quot;] ^.. taking 1 (folded . worded)
-- [&quot;My&quot;]

-- &gt;&gt;&gt; [&quot;My Precious&quot;, &quot;Hakuna Matata&quot;, &quot;No problemo&quot;] ^.. folded . taking 1 worded . folded
-- &quot;MyHakunaNo&quot;

-- &gt;&gt;&gt; [&quot;My Precious&quot;, &quot;Hakuna Matata&quot;, &quot;No problemo&quot;] ^.. folded . taking 1 (folding words) . folded
-- &quot;MyHakunaNo&quot;

ex36 :: Integer
ex36 = sumOf (taking 2 each) (10, 50, 100)

-- &gt;&gt;&gt; ex36
-- 60

-- &gt;&gt;&gt; (&quot;stressed&quot;, &quot;guns&quot;, &quot;evil&quot;) ^.. backwards each
-- [&quot;evil&quot;,&quot;guns&quot;,&quot;stressed&quot;]

-- &gt;&gt;&gt; (&quot;stressed&quot;, &quot;guns&quot;, &quot;evil&quot;) ^.. backwards each . to reverse
-- [&quot;live&quot;,&quot;snug&quot;,&quot;desserts&quot;]

-- &gt;&gt;&gt; import Data.Char (isAlpha)
-- &gt;&gt;&gt; &quot;blink182 k9 blazeit420&quot; ^.. folding (filter (\x -&gt; not (isAlpha x || x == ' ')))
-- &quot;1829420&quot;
</code></pre>
</li>
<li>
<p>use higher-order folds</p>
<pre><code class="language-haskell">temperatureSample :: [Int]
temperatureSample = [-10, -5, 4, 3, 8, 6, -2, 3, -5, -7]

-- &gt;&gt;&gt; length $ temperatureSample ^.. takingWhile (&lt;= 0) folded
-- 2

-- &gt;&gt;&gt; maximumOf (taking 4 folded) temperatureSample
-- Just 4

-- &gt;&gt;&gt; temperatureSample ^? dropping 1 (droppingWhile (/= 4) folded)
-- Just 3

-- &gt;&gt;&gt; length $ temperatureSample ^.. takingWhile (&lt; 0) (backwards folded)
-- 2

-- &gt;&gt;&gt; temperatureSample ^.. takingWhile (&gt; 0) (droppingWhile (&lt;= 0) folded)
-- [4,3,8,6]

trimmingWhile :: (a -&gt; Bool) -&gt; Fold s a -&gt; Fold s a
trimmingWhile c f = backwards (droppingWhile c (backwards (droppingWhile c f)))

-- &gt;&gt;&gt; temperatureSample ^.. trimmingWhile (&lt; 0) folded
-- [4,3,8,6,-2,3]
</code></pre>
</li>
</ol>
<!-- d -->
<h3 id="65-filtering-folds"><a class="header" href="#65-filtering-folds">6.5 Filtering folds</a></h3>
<ul>
<li>Filter focuses (like WHERE in SQL)</li>
<li>Can run a separate fold to calculate the filter condition</li>
<li>Can go deeper after filtering</li>
</ul>
<p>Book:</p>
<ul>
<li><code>filtered :: (s -&gt; Bool) -&gt; Fold s s</code> - filter a fold</li>
<li><code>filteredBy :: Fold s a -&gt; Fold s s</code> or <code>filteredBy :: Fold s a -&gt; IndexedTraversal' a s s</code> - filter by a condition represented as a fold</li>
</ul>
<p>Real:</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt;:t filtered
-- filtered :: (Choice p, Applicative f) =&gt; (a -&gt; Bool) -&gt; Optic' p f a a

-- &gt;&gt;&gt;:t filteredBy
-- filteredBy
--   :: (Indexable i p, Applicative f) =&gt;
--      Getting (First i) a i -&gt; p a (f a) -&gt; a -&gt; f a
</code></pre>
<p>Examples:</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt; [1, 2, 3, 4] ^.. folded . filtered even
-- [2,4]

-- &gt;&gt;&gt; [&quot;apple&quot;, &quot;passionfruit&quot;, &quot;orange&quot;, &quot;pomegranate&quot;] ^.. folded . filtered ((&gt;6) . length)
-- [&quot;passionfruit&quot;,&quot;pomegranate&quot;]

-- A data structure to represent a single card
data Card = Card
  { _cardName :: String
  , _aura :: Aura
  , _holo :: Bool
  , _moves :: [Move]
  }
  deriving (Show, Eq)

-- Each card has an aura-type
data Aura
  = Wet
  | Hot
  | Spark
  | Leafy
  deriving (Show, Eq)

-- Cards have attack moves
data Move = Move
  { _moveName :: String
  , _movePower :: Int
  }
  deriving (Show, Eq)

makeLenses ''Card
makeLenses ''Move

deck :: [Card]
deck =
  [ Card &quot;Skwortul&quot; Wet False [Move &quot;Squirt&quot; 20]
  , Card &quot;Scorchander&quot; Hot False [Move &quot;Scorch&quot; 20]
  , Card &quot;Seedasaur&quot; Leafy False [Move &quot;Allergize&quot; 20]
  , Card &quot;Kapichu&quot; Spark False [Move &quot;Poke&quot; 10, Move &quot;Zap&quot; 30]
  , Card &quot;Elecdude&quot; Spark False [Move &quot;Asplode&quot; 50]
  , Card &quot;Garydose&quot; Wet True [Move &quot;Gary's move&quot; 40]
  , Card &quot;Moisteon&quot; Wet False [Move &quot;Soggy&quot; 3]
  , Card &quot;Grasseon&quot; Leafy False [Move &quot;Leaf Cut&quot; 30]
  , Card &quot;Spicyeon&quot; Hot False [Move &quot;Capsaicisize&quot; 40]
  , Card &quot;Sparkeon&quot; Spark True [Move &quot;Shock&quot; 40, Move &quot;Battery&quot; 50]
  ]
</code></pre>
<ul>
<li>
<p>How many moves have an attack power above 30?</p>
<!-- i 4 -->
<pre><code class="language-haskell">ex38 :: Int
ex38 =
  lengthOf
    ( folded
        . moves
        . folded
        . movePower
        . filtered (&gt; 30)
    )
    deck

-- &gt;&gt;&gt; ex38
-- 5
</code></pre>
</li>
<li>
<p>List all cards which have ANY move with an attack power greater than 40</p>
<pre><code class="language-haskell">ex39 :: [String]
ex39 =
  deck
    ^.. folded
      . filtered (anyOf (moves . folded . movePower) (&gt; 40))
      . cardName

-- &gt;&gt;&gt; ex39
-- [&quot;Elecdude&quot;,&quot;Sparkeon&quot;]
</code></pre>
</li>
<li>
<p>List all Spark Moves with a power greater than 30</p>
<pre><code class="language-haskell">-- ex40 :: [Move]
ex40 :: [String]
ex40 =
  deck
    ^.. folded
      . filtered (\x -&gt; x ^. aura == Spark)
      . moves
      . folded
      . filtered (\x -&gt; x ^. movePower &gt; 30)
      . moveName

-- &gt;&gt;&gt;ex40
-- [&quot;Asplode&quot;,&quot;Shock&quot;,&quot;Battery&quot;]
</code></pre>
</li>
</ul>
<p>Other helpers</p>
<ul>
<li>
<p><code>filteredBy :: Fold s a -&gt; Fold s s</code> - filter by a condition represented as a fold</p>
</li>
<li>
<p><code>only :: Eq a =&gt; a -&gt; Prism' a ()</code> - return () iff input is equal to a reference value</p>
</li>
<li>
<p><code>nearly :: a -&gt; (a -&gt; Bool) -&gt; Prism' a ()</code> - check condition. As it returns a prism, we have to supply the first argument for re-construction</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt; has (only &quot;needle&quot;) &quot;needle&quot;
-- True
</code></pre>
</li>
<li>
<p>List all Spark Moves with a power greater than 30</p>
<pre><code class="language-haskell">ex41 :: [String]
ex41 =
  deck
    ^.. folded
      . filteredBy (aura . only Spark)
      . moves
      . folded
      . filteredBy (movePower . filtered (&gt; 30))
      . moveName

-- &gt;&gt;&gt; ex41
-- [&quot;Asplode&quot;,&quot;Shock&quot;,&quot;Battery&quot;]

ex42 :: Maybe String
ex42 =
  maximumByOf
    -- filter for holo cards
    (folded . filteredBy holo)
    -- compare them on number of moves
    (comparing (lengthOf moves))
    deck
    &lt;&amp;&gt; (^. cardName)

-- &gt;&gt;&gt; ex42
-- Just &quot;Sparkeon&quot;
</code></pre>
</li>
</ul>
<!-- d -->
<h4 id="exercises---filtering"><a class="header" href="#exercises---filtering">Exercises - Filtering</a></h4>
<ul>
<li>
<p>List all the cards whose name starts with 'S'</p>
<!-- i 4 -->
<pre><code class="language-haskell">ex43 :: [String]
ex43 = deck ^.. folded . filteredBy (cardName . taking 1 folded . only 'S') . cardName

-- &gt;&gt;&gt; ex43
-- [&quot;Skwortul&quot;,&quot;Scorchander&quot;,&quot;Seedasaur&quot;,&quot;Spicyeon&quot;,&quot;Sparkeon&quot;]
</code></pre>
</li>
<li>
<p>What's the lowest attack power of all moves?</p>
<pre><code class="language-haskell">ex44 :: Maybe Int
ex44 = minimumOf (folded . moves . folded . movePower) deck

-- &gt;&gt;&gt;ex44
-- Just 3
</code></pre>
</li>
<li>
<p>What's the name of the first card which has more than one move?</p>
<pre><code class="language-haskell">ex45 :: Maybe String
ex45 = findOf (folded . filtered (\x -&gt; length (x ^. moves) &gt; 1)) (const True) deck &lt;&amp;&gt; (^. cardName)

-- &gt;&gt;&gt;ex45
-- Just &quot;Kapichu&quot;
</code></pre>
</li>
<li>
<p>Are there any Hot cards with a move with more than 30 attack power?</p>
<pre><code class="language-haskell">ex46 :: Bool
ex46 =
  not . null $
    deck
      ^.. folded
        . filteredBy (aura . only Hot)
        . filteredBy (moves . folded . filteredBy (movePower . nearly 0 (&gt; 30)))

-- &gt;&gt;&gt;ex46
-- [Card {_cardName = &quot;Spicyeon&quot;, _aura = Hot, _holo = False, _moves = [Move {_moveName = &quot;Capsaicisize&quot;, _movePower = 40}]}]
</code></pre>
</li>
<li>
<p>List the names of all holographic cards with a Wet aura.</p>
<pre><code class="language-haskell">ex47 :: [String]
ex47 = deck ^.. folded . filtered (\x -&gt; x ^. holo &amp;&amp; x ^. aura == Wet) . cardName

-- &gt;&gt;&gt;ex47
-- [&quot;Garydose&quot;]
</code></pre>
</li>
<li>
<p>What's the sum of all attack power for all moves belonging to non-Leafy cards?</p>
<pre><code class="language-haskell">ex48 :: Int
ex48 = sumOf (folded . filtered (\x -&gt; x ^. aura /= Leafy) . moves . folded . movePower) deck

-- &gt;&gt;&gt;ex48
-- 303
</code></pre>
</li>
</ul>
<!-- d -->
<h3 id="7-traversals"><a class="header" href="#7-traversals">7. Traversals</a></h3>
<p>Have multiple focuses. Can transform them.</p>
<h4 id="71-introduction-to-traversals"><a class="header" href="#71-introduction-to-traversals">7.1. Introduction to Traversals</a></h4>
<p>Can get or set many focuses <strong>in-place</strong>.</p>
<ul>
<li><strong>rows</strong> - optics that we <strong>have</strong></li>
<li><strong>columns</strong> - how want to <strong>use</strong> that optics</li>
</ul>
<p><img src="haskell/optics-by-example/README/tableTraversals.png" alt="alt" /></p>
<h4 id="from-fold-to-traversal"><a class="header" href="#from-fold-to-traversal">From Fold to Traversal</a></h4>
<pre><code class="language-hs">both :: Bitraversable r =&gt; Traversal (r a a) (r b b) a b
</code></pre>
<p>In case of tuples, <code>both</code> focuses both sides of a tuple.</p>
<p><code>Traversal s t a b</code>:</p>
<ul>
<li><code>s</code>: structure before action</li>
<li><code>t</code>: structure after action</li>
<li><code>a</code>: focus before action</li>
<li><code>b</code>: focus after action</li>
</ul>
<p>Let's modify both elements of a tuple</p>
<pre><code class="language-haskell">ex49 :: (String, String)
ex49 = (&quot;Bubbles&quot;, &quot;Buttercup&quot;) &amp; both %~ (++ &quot;!&quot;)

-- &gt;&gt;&gt; ex49
-- (&quot;Bubbles!&quot;,&quot;Buttercup!&quot;)
</code></pre>
<p>Focuses may change type as long as the type of a structure remains valid. In case of each, we have to change types of all elements of a tuple.</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt; (&quot;Bubbles&quot;, &quot;Buttercup&quot;) &amp; each %~ length
-- (7,9)

-- &gt;&gt;&gt; [1, 2, 3, 4, 5] &amp; dropping 3 traversed %~ show
-- No instance for (Num String) arising from the literal `1'
-- In the expression: 1
-- In the first argument of `(&amp;)', namely `[1, 2, 3, 4, 5]'
-- In the expression: [1, 2, 3, 4, 5] &amp; dropping 3 traversed %~ show
</code></pre>
<p>Some structures disallow changing the type.</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt; (&quot;Houston we have a problem&quot; :: T.Text) &amp; each .~ (22 :: Int)
-- Couldn't match type `Int' with `Char' arising from a use of `each'
-- In the first argument of `(.~)', namely `each'
-- In the second argument of `(&amp;)', namely `each .~ (22 :: Int)'
-- In the expression:
--   (&quot;Houston we have a problem&quot; :: Text) &amp; each .~ (22 :: Int)
</code></pre>
<p>Can use some functions that we used for <code>Fold</code>s, e.g., <code>filtered</code>.</p>
<pre><code class="language-haskell">-- Reverse only the long strings
ex50 :: (String, String)
ex50 =
  (&quot;short&quot;, &quot;really long&quot;)
    &amp; both . filtered ((&gt; 5) . length)
      %~ reverse

-- &gt;&gt;&gt;ex50
-- (&quot;short&quot;,&quot;gnol yllaer&quot;)
</code></pre>
<h3 id="72-traversal-combinators"><a class="header" href="#72-traversal-combinators">7.2 Traversal Combinators</a></h3>
<h4 id="traversing-each-element-of-a-container"><a class="header" href="#traversing-each-element-of-a-container">Traversing each element of a container</a></h4>
<p>Some optics are incompatible in types, e.g., <code>folded</code> and <code>%~</code>. That is, you can't modify focuses in a fold</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt; [1, 2, 3] &amp; folded %~ (*10)
-- Could not deduce (Contravariant Identity)
--   arising from a use of `folded'
-- from the context: Num b_aNbRI[sk:1]
--   bound by the inferred type of
--              it_aNbPv :: Num b_aNbRI[sk:1] =&gt; [b_aNbRI[sk:1]]
--   at /home/eyjafjallajokull/Desktop/projects/optics-by-example/README.hs:2207:2-28
-- In the first argument of `(%~)', namely `folded'
-- In the second argument of `(&amp;)', namely `folded %~ (* 10)'
-- In the expression: [1, 2, 3] &amp; folded %~ (* 10)
</code></pre>
<p>That's why there is a specific function for traversing.</p>
<p>Book:</p>
<pre><code class="language-hs">traversed :: Traversable f =&gt; Traversal (f a) (f b) a b
</code></pre>
<p>Real:</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt; :t traversed
-- traversed :: Traversable f =&gt; IndexedTraversal Int (f a) (f b) a b
</code></pre>
<pre><code class="language-hs">class (Functor t, Foldable t) =&gt; Traversable t
</code></pre>
<p>If you compose a <code>Traversal</code> and a <code>Fold</code>, you get a <code>Fold</code>.</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt;[[3 :: Int, 4]] &amp; traversed . folded %~ (*10)
-- No instance for (Contravariant Identity)
--   arising from a use of `folded'
-- In the second argument of `(.)', namely `folded'
-- In the first argument of `(%~)', namely `traversed . folded'
-- In the second argument of `(&amp;)', namely
--   `traversed . folded %~ (* 10)'

-- &gt;&gt;&gt;[[3 :: Int, 4]] ^.. traversed . folded
-- [3,4]
</code></pre>
<p>Compared to <strong>folded</strong>, <strong>traversed</strong> operates on <strong>less</strong> containers with <strong>more</strong> operations.</p>
<pre><code class="language-haskell">powerLevels :: M.Map String Integer
powerLevels =
  M.fromList
    [ (&quot;Gohan&quot;, 710)
    , (&quot;Goku&quot;, 9001)
    , (&quot;Krillin&quot;, 5000)
    , (&quot;Piccolo&quot;, 408)
    ]

-- operate on the values of a map
ex51 :: M.Map String String
ex51 =
  powerLevels
    &amp; traversed %~ \n -&gt;
      if n &gt; 9000
        then &quot;Over 9000&quot;
        else show n

-- &gt;&gt;&gt;ex51
-- fromList [(&quot;Gohan&quot;,&quot;710&quot;),(&quot;Goku&quot;,&quot;Over 9000&quot;),(&quot;Krillin&quot;,&quot;5000&quot;),(&quot;Piccolo&quot;,&quot;408&quot;)]
</code></pre>
<h4 id="more-combinators"><a class="header" href="#more-combinators">More Combinators</a></h4>
<p>Book:</p>
<ul>
<li><code>worded :: Traversal' String String</code> - focus on words</li>
<li><code>lined :: Traversal' String String</code> - focus on lines</li>
</ul>
<p>Real:</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt; :t worded
-- worded :: Applicative f =&gt; IndexedLensLike' Int f String String

-- &gt;&gt;&gt; :t lined
-- lined :: Applicative f =&gt; IndexedLensLike' Int f String String
</code></pre>
<p>They're unlawful, because they wrongly reconstruct the results. E.g., like <code>unwords . words</code>, they substitute a single space for multiple spaces.</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt; &quot;blue \n suede \n \n shoes&quot; &amp; worded %~ \(x:xs) -&gt; toUpper x : xs
-- &quot;Blue Suede Shoes&quot;
</code></pre>
<h4 id="traversing-multiple-paths-at-once"><a class="header" href="#traversing-multiple-paths-at-once">Traversing multiple paths at once</a></h4>
<p>Focus on all <code>a</code>s from both structures in a tuple.</p>
<pre><code class="language-hs">beside :: Traversal s t a b -&gt; Traversal s' t' a b -&gt; Traversal (s,s') (t,t') a b
beside :: Lens s t a b      -&gt; Lens s' t' a b      -&gt; Traversal (s,s') (t,t') a b
beside :: Fold s a          -&gt; Fold s' a           -&gt; Fold (s,s') a
</code></pre>
<pre><code class="language-haskell">-- &gt;&gt;&gt; let dinos = (&quot;T-Rex&quot;, (42, &quot;Stegosaurus&quot;))
-- &gt;&gt;&gt;  dinos ^.. beside id _2
-- [&quot;T-Rex&quot;,&quot;Stegosaurus&quot;]

ex52 :: (String, [String])
ex52 =
  (&quot;Cowabunga&quot;, [&quot;let's&quot;, &quot;order&quot;, &quot;pizza&quot;])
    -- Each half of the tuple has a different path to focus the characters
    &amp; beside traversed (traversed . traversed)
      %~ toUpper

-- &gt;&gt;&gt;ex52
-- (&quot;COWABUNGA&quot;,[&quot;LET'S&quot;,&quot;ORDER&quot;,&quot;PIZZA&quot;])
</code></pre>
<p>There are other <code>Bitraversable</code>s like <code>Either</code>.</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt; Left (1, 2) &amp; beside both traversed %~ negate
-- Left (-1,-2)
</code></pre>
<h4 id="focusing-a-specific-traversal-element"><a class="header" href="#focusing-a-specific-traversal-element">Focusing a specific traversal element</a></h4>
<p>Focuses a single element with a given index.
Can't change the type of that focus because it can't change the type of other focuses.</p>
<pre><code class="language-hs">element :: Traversable f =&gt; Int -&gt; Traversal' (f a) a
</code></pre>
<pre><code class="language-haskell">-- &gt;&gt;&gt; [0, 1, 2, 3, 4] &amp; element 2 *~ 100
-- [0,1,200,3,4]
</code></pre>
<p>Focus an element of a traversal or a fold</p>
<pre><code class="language-hs">elementOf :: Traversal' s a -&gt; Int -&gt; Traversal' s a
elementOf :: Fold s a       -&gt; Int -&gt; Fold s a
</code></pre>
<pre><code class="language-haskell">-- &gt;&gt;&gt; [[0, 1, 2], [3, 4], [5, 6, 7, 8]] &amp; elementOf (traversed . traversed) 6 *~ 100
-- [[0,1,2],[3,4],[5,600,7,8]]
</code></pre>
<h3 id="73-traversal-composition"><a class="header" href="#73-traversal-composition">7.3 Traversal Composition</a></h3>
<pre><code class="language-haskell">-- Add &quot;Rich &quot; to the names of people with more than $1000
ex53 :: ((String, Integer), (String, Integer), (String, Integer))
ex53 =
  ((&quot;Ritchie&quot;, 100000), (&quot;Archie&quot;, 32), (&quot;Reggie&quot;, 4350))
    &amp; each
      . filtered ((&gt; 1000) . snd)
      . _1
      %~ (&quot;Rich &quot; ++)

-- &gt;&gt;&gt;ex53
-- ((&quot;Rich Ritchie&quot;,100000),(&quot;Archie&quot;,32),(&quot;Rich Reggie&quot;,4350))
</code></pre>
<h4 id="exercises---simple-traversals"><a class="header" href="#exercises---simple-traversals">Exercises - Simple Traversals</a></h4>
<ol>
<li>
<p>What type of optic do you get when you compose a traversal with a fold?</p>
<ul>
<li>
<p>fold</p>
<!-- i 6 -->
<pre><code class="language-haskell">-- &gt;&gt;&gt; [[3 :: Int, 4]] ^.. traversed . folded
-- [3,4]

-- &gt;&gt;&gt; [[3 :: Int, 4]] &amp; traversed . folded .~ 2
-- No instance for (Contravariant Identity)
--   arising from a use of `folded'
-- In the second argument of `(.)', namely `folded'
-- In the first argument of `(.~)', namely `traversed . folded'
-- In the second argument of `(&amp;)', namely `traversed . folded .~ 2'
</code></pre>
</li>
</ul>
</li>
<li>
<p>Which of the optics we've learned can act as a traversal?</p>
<ul>
<li>lens and traversal</li>
</ul>
</li>
<li>
<p>Which of the optics we've learned can act as a fold?</p>
<ul>
<li>lens, traversal, fold</li>
</ul>
</li>
</ol>
<!-- d -->
<pre><code class="language-haskell">-- &gt;&gt;&gt;(&quot;Jurassic&quot;, &quot;Park&quot;) &amp; both .~ &quot;N/A&quot;
-- (&quot;N/A&quot;,&quot;N/A&quot;)

-- &gt;&gt;&gt; (&quot;Jurassic&quot; :: String, &quot;Park&quot;) &amp; both . traversed .~ 'x'
-- (&quot;xxxxxxxx&quot;,&quot;xxxx&quot;)

-- &gt;&gt;&gt;(&quot;Malcolm&quot;, [&quot;Kaylee&quot;, &quot;Inara&quot;, &quot;Jayne&quot;]) &amp; beside id traversed %~ take 3
-- (&quot;Mal&quot;,[&quot;Kay&quot;,&quot;Ina&quot;,&quot;Jay&quot;])

-- &gt;&gt;&gt;(&quot;Malcolm&quot;, [&quot;Kaylee&quot;, &quot;Inara&quot;, &quot;Jayne&quot;]) &amp; _2 . elementOf traversed 1 .~ &quot;River&quot;
-- (&quot;Malcolm&quot;,[&quot;Kaylee&quot;,&quot;River&quot;,&quot;Jayne&quot;])

-- &gt;&gt;&gt; [&quot;Die Another Day&quot;, &quot;Live and Let Die&quot;, &quot;You Only Live Twice&quot;] &amp; traversed . elementOf worded 1 . traversed .~ 'x'
-- [&quot;Die xxxxxxx Day&quot;,&quot;Live xxx Let Die&quot;,&quot;You xxxx Live Twice&quot;]

-- &gt;&gt;&gt;((1, 2), (3, 4)) &amp; both . both +~ 1
-- ((2,3),(4,5))

-- &gt;&gt;&gt;(1, (2, [3, 4])) &amp; beside id (beside id traversed) +~ 1
-- (2,(3,[4,5]))

ex54 = ((True, &quot;Strawberries&quot; :: String), (False, &quot;Blueberries&quot;), (True, &quot;Blackberries&quot;)) &amp; each . filtered fst . _2 . taking 5 traversed %~ toUpper

-- &gt;&gt;&gt; ex54
-- ((True,&quot;STRAWberries&quot;),(False,&quot;Blueberries&quot;),(True,&quot;BLACKberries&quot;))

ex55 = ((True, &quot;Strawberries&quot;), (False, &quot;Blueberries&quot;), (True, &quot;Blackberries&quot; :: String)) &amp; each %~ snd

-- &gt;&gt;&gt; ex55
-- (&quot;Strawberries&quot;,&quot;Blueberries&quot;,&quot;Blackberries&quot;)
</code></pre>
<h3 id="74-traversal-actions"><a class="header" href="#74-traversal-actions">7.4 Traversal Actions</a></h3>
<pre><code class="language-hs">sequenceA :: (Traversable t, Applicative f) =&gt; t (f a) -&gt; f (t a)
</code></pre>
<pre><code class="language-haskell">-- &gt;&gt;&gt;sequenceA $ Just (Left &quot;Whoops&quot;)
-- Left &quot;Whoops&quot;

-- &gt;&gt;&gt;sequenceA $ Just (Right &quot;Whoops&quot;)
-- Right (Just &quot;Whoops&quot;)

-- &gt;&gt;&gt; :t readMaybe
-- readMaybe :: Read a =&gt; String -&gt; Maybe a

-- &gt;&gt;&gt;traverse readMaybe [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;] :: Maybe [Int]
-- Just [1,2,3]

-- &gt;&gt;&gt;traverse readMaybe [&quot;1&quot;, &quot;snark&quot;, &quot;3&quot;] :: Maybe [Int]
-- Nothing
</code></pre>
<h4 id="traverse-on-traversals"><a class="header" href="#traverse-on-traversals">Traverse on Traversals</a></h4>
<p>Can run <code>traverse</code> on arbitrary focuses!</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt;:t traverseOf
-- traverseOf :: LensLike f s t a b -&gt; (a -&gt; f b) -&gt; s -&gt; f t

-- &gt;&gt;&gt; :t traverse
-- traverse :: (Traversable t, Applicative f) =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)

-- &gt;&gt;&gt; :t traverseOf traversed
-- traverseOf traversed
--   :: (Traversable f1, Applicative f2) =&gt;
--      (a -&gt; f2 b) -&gt; f1 a -&gt; f2 (f1 b)

-- &gt;&gt;&gt;traverseOf both readMaybe (&quot;1&quot;, &quot;2&quot;) :: Maybe (Int, Int)
-- Just (1,2)

-- &gt;&gt;&gt; traverseOf both (\c -&gt; [toLower c, toUpper c]) ('a', 'b')
-- [('a','b'),('a','B'),('A','b'),('A','B')]

-- &gt;&gt;&gt; traverseOf (both . traversed) (\c -&gt; [toLower c, toUpper c]) (&quot;ab&quot;, &quot;c&quot;)
-- [(&quot;ab&quot;,&quot;c&quot;),(&quot;ab&quot;,&quot;C&quot;),(&quot;aB&quot;,&quot;c&quot;),(&quot;aB&quot;,&quot;C&quot;),(&quot;Ab&quot;,&quot;c&quot;),(&quot;Ab&quot;,&quot;C&quot;),(&quot;AB&quot;,&quot;c&quot;),(&quot;AB&quot;,&quot;C&quot;)]

validateEmail :: String -&gt; Validation [String] String
validateEmail email
  | elem '@' email = Success email
  | otherwise =
      Failure [&quot;missing '@': &quot; &lt;&gt; email]

-- &gt;&gt;&gt; traverseOf (both . traversed) validateEmail ([&quot;mike@tmnt.io&quot;, &quot;raph@tmnt.io&quot;], [&quot;don@tmnt.io&quot;, &quot;leo@tmnt.io&quot;])
-- Success ([&quot;mike@tmnt.io&quot;,&quot;raph@tmnt.io&quot;],[&quot;don@tmnt.io&quot;,&quot;leo@tmnt.io&quot;])

-- &gt;&gt;&gt; traverseOf (both . traversed) validateEmail ([&quot;mike@tmnt.io&quot;, &quot;raph.io&quot;], [&quot;don@tmnt.io&quot;, &quot;leo.io&quot;])
-- Failure [&quot;missing '@': raph.io&quot;,&quot;missing '@': leo.io&quot;]
</code></pre>
<p>Other functions:</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt;:t forOf
-- forOf :: LensLike f s t a b -&gt; s -&gt; (a -&gt; f b) -&gt; f t

-- &gt;&gt;&gt;:t sequenceAOf
-- sequenceAOf :: LensLike f s t (f b) b -&gt; s -&gt; f t

-- &gt;&gt;&gt; sequenceAOf _1 (Just &quot;Garfield&quot;, &quot;Lasagna&quot;)
-- Just (&quot;Garfield&quot;,&quot;Lasagna&quot;)

-- &gt;&gt;&gt; sequenceAOf (both . traversed) ([Just &quot;apples&quot;], [Just &quot;oranges&quot;])
-- Just ([&quot;apples&quot;],[&quot;oranges&quot;])
</code></pre>
<h4 id="infix-traverseof"><a class="header" href="#infix-traverseof">Infix <code>traverseOf</code></a></h4>
<pre><code class="language-haskell">-- &gt;&gt;&gt; ((&quot;1&quot;, &quot;2&quot;) &amp; both %%~ readMaybe) :: Maybe (Int, Int)
-- Just (1,2)
</code></pre>
<h4 id="use-traversals-directly"><a class="header" href="#use-traversals-directly">Use Traversals directly</a></h4>
<p>Actual definitions:</p>
<pre><code class="language-hs">traverseOf = id
(%%~) = id
</code></pre>
<p>So, we can (but should not!) use <code>Traversal</code>s without <code>traverseOf</code>:</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt;both readMaybe (&quot;1&quot;, &quot;2&quot;) :: Maybe (Int, Int)
-- Just (1,2)
</code></pre>
<h4 id="exercises---traversal-actions"><a class="header" href="#exercises---traversal-actions">Exercises - Traversal Actions</a></h4>
<pre><code class="language-haskell">-- &gt;&gt;&gt; sequenceAOf _1 (Nothing, &quot;Rosebud&quot;)
-- Nothing

-- &gt;&gt;&gt; sequenceAOf (traversed . _1) [(&quot;ab&quot; :: String,1),(&quot;cd&quot;,2)]
-- [[('a',1),('c',2)],[('a',1),('d',2)],[('b',1),('c',2)],[('b',1),('d',2)]]

ex56 :: (([Integer], (Integer, Integer)), Integer)
ex56 = runState result 0
 where
  result = traverseOf (beside traversed both) (\n -&gt; modify (+ n) &gt;&gt; get) ([1, 1, 1], (1, 1))

-- &gt;&gt;&gt;ex56
-- (([1,2,3],(4,5)),5)

ex57 :: [([Char], Bool)]
ex57 =
  (&quot;ab&quot; :: String, True)
    &amp; (_1 . traversed)
      %%~ (\c -&gt; [toLower c, toUpper c])

ex58 :: [[(Char, Bool)]]
ex58 =
  [('a', True), ('b', False)]
    &amp; (traversed . _1)
      %%~ (\c -&gt; [toLower c, toUpper c])

data UserWithAge = UserWithAge
  { _userName :: String
  , _userAge :: Int
  }
  deriving (Show)
makeLenses ''UserWithAge
data Account = Account
  { _accountId :: String
  , _userWithAge :: UserWithAge
  }
  deriving (Show)
makeLenses ''Account

validateAge :: Account -&gt; Validation String Account
validateAge acc
  | age' &lt;= 0 = Failure &quot;Age is below 0&quot;
  | age' &gt;= 150 = Failure &quot;Age is above 150&quot;
  | otherwise = Success acc
 where
  age' = acc ^. userWithAge . userAge
</code></pre>
<h3 id="75-custom-traversals"><a class="header" href="#75-custom-traversals">7.5 Custom traversals</a></h3>
<p>van Laarhoven optics are</p>
<pre><code class="language-hs">type LensLike f s t a b = (a -&gt; f b) -&gt; (s -&gt; f t)
</code></pre>
<p>plus constraints</p>
<pre><code class="language-hs">type Lens s t a b = forall f. Functor f =&gt; (a -&gt; f b) -&gt; (s -&gt; f t)
type Traversal s t a b = forall f. Applicative f =&gt; (a -&gt; f b) -&gt; (s -&gt; f t)
type Fold s a = forall f. (Contravariant f, Applicative f) =&gt; (a -&gt; f a) -&gt; (s -&gt; f s)
</code></pre>
<p>And LensLike is very similar to <code>traverse</code> signature:</p>
<pre><code class="language-hs">traverse :: (Traversable g, Applicative f) =&gt; (a -&gt; f b) -&gt; (g a -&gt; f (g b))
myTraversal :: myTraversal :: (Applicative f) =&gt; (a -&gt; f b) -&gt; (s -&gt; f t)
</code></pre>
<p><strong>Most optics are really just traverse wearing different pants.</strong></p>
<h4 id="our-first-custom-traversal"><a class="header" href="#our-first-custom-traversal">Our first custom traversal</a></h4>
<p><code>traversed</code> for lists</p>
<pre><code class="language-haskell">-- values :: Traversal [a] [b] a b
values :: Applicative f =&gt; (a -&gt; f b) -&gt; [a] -&gt; f [b]
values _ [] = pure []
values handler (a : as) = liftA2 (:) (handler a) (values handler as)

-- &gt;&gt;&gt; [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;] &amp; values %~ length
-- [3,3,5]
</code></pre>
<h4 id="traversals-with-custom-logic"><a class="header" href="#traversals-with-custom-logic">Traversals with custom logic</a></h4>
<p>Some bank software</p>
<pre><code class="language-haskell">data Transaction
  = Withdrawal {_amount :: Int}
  | Deposit {_amount :: Int}
  deriving (Show)
makeLenses ''Transaction

newtype BankAccount = BankAccount
  { _transactions :: [Transaction]
  }
  deriving (Show)
makeLenses ''BankAccount

aliceAccount :: BankAccount
aliceAccount = BankAccount [Deposit 100, Withdrawal 20, Withdrawal 10]

-- &gt;&gt;&gt;aliceAccount ^.. transactions . traversed . amount
-- [100,20,10]
</code></pre>
<h4 id="case-study-transaction-traversal"><a class="header" href="#case-study-transaction-traversal">Case study: Transaction Traversal</a></h4>
<p>Need a traversal which focuses on only the dollar amounts of <strong>deposits</strong> within a given account.</p>
<pre><code class="language-haskell">-- deposits :: Traversal' [Transaction] Int
-- deposits :: Traversal [Transaction] [Transaction] Int Int
deposits :: Applicative f =&gt; (Int -&gt; f Int) -&gt; [Transaction] -&gt; f [Transaction]
deposits _ [] = pure []
deposits handler (Withdrawal amt : rest) = fmap (Withdrawal amt :) (deposits handler rest)
deposits handler (Deposit amt : rest) = liftA2 (:) (Deposit &lt;$&gt; handler amt) (deposits handler rest)

-- &gt;&gt;&gt;[Deposit 10, Withdrawal 20, Deposit 30] &amp; deposits *~ 10
-- [Deposit {_amount = 100},Withdrawal {_amount = 20},Deposit {_amount = 300}]

deposits' :: Traversal' [Transaction] Int
deposits' = traversed . filtered (\case Deposit _ -&gt; True; _ -&gt; False) . amount
</code></pre>
<h4 id="exercises---custom-traversals"><a class="header" href="#exercises---custom-traversals">Exercises - Custom traversals</a></h4>
<ol>
<li>
<p>custom traversal</p>
<!-- i 4 -->
<pre><code class="language-haskell">-- amountT :: Traversal' Transaction Int
amountT :: Applicative f =&gt; (Int -&gt; f Int) -&gt; Transaction -&gt; f Transaction
amountT f = \case Deposit am -&gt; Deposit &lt;$&gt; f am; Withdrawal am -&gt; Withdrawal &lt;$&gt; f am
</code></pre>
</li>
<li>
<p>custom <code>both</code></p>
<pre><code class="language-haskell">both' :: Traversal (a, a) (b, b) a b
both' f (x, y) = liftA2 (,) (f x) (f y)
</code></pre>
</li>
<li>
<p>delta - Similar to change of coordinates via matrix pre- and post-multiplication</p>
<pre><code class="language-haskell">transactionDelta :: Traversal' Transaction Int
transactionDelta f = \case Deposit amt -&gt; Deposit &lt;$&gt; f amt; Withdrawal amt -&gt; Withdrawal . negate &lt;$&gt; f (negate amt)

-- &gt;&gt;&gt; Deposit 10 ^? transactionDelta
-- Just 10

-- Withdrawal's delta is negative
-- &gt;&gt;&gt; Withdrawal 10 ^? transactionDelta
-- Just (-10)
-- &gt;&gt;&gt; Deposit 10 &amp; transactionDelta .~ 15
-- Deposit {_amount = 15}
-- &gt;&gt;&gt; Withdrawal 10 &amp; transactionDelta .~ (-15)
-- Withdrawal {_amount = 15}
-- &gt;&gt;&gt; Deposit 10 &amp; transactionDelta +~ 5
-- Deposit {_amount = 15}
-- &gt;&gt;&gt; Withdrawal 10 &amp; transactionDelta +~ 5
-- Withdrawal {_amount = 5}
</code></pre>
</li>
</ol>
<!-- d -->
<pre><code class="language-haskell">left' :: Traversal (Either a b) (Either a' b) a a'
left' f = \case Left e -&gt; Left &lt;$&gt; f e; Right x -&gt; pure $ Right x

beside' :: Traversal s t a b -&gt; Traversal s' t' a b -&gt; Traversal (s, s') (t, t') a b
beside' l r f (l1, r1) = liftA2 (,) (l f l1) (r f r1)
</code></pre>
<h3 id="76-traversal-laws"><a class="header" href="#76-traversal-laws">7.6 Traversal Laws</a></h3>
<h4 id="law-one-respect-purity"><a class="header" href="#law-one-respect-purity">Law One: Respect Purity</a></h4>
<p>Running the pure handler (which has no effects) using our traversal should be exactly
the same as running <code>pure</code> on the original structure without using the traversal at all.</p>
<pre><code class="language-hs">traverseOf myTraversal pure x == pure x
</code></pre>
<pre><code class="language-haskell">badTupleSnd :: Traversal (Int, a) (Int, b) a b
badTupleSnd handler (n, a) = (n + 1,) &lt;$&gt; handler a

-- &gt;&gt;&gt; traverseOf badTupleSnd pure (10, &quot;Yo&quot;)
-- (11,&quot;Yo&quot;)
</code></pre>
<h4 id="law-two-consistent-focuses"><a class="header" href="#law-two-consistent-focuses">Law Two: Consistent Focuses</a></h4>
<p>Running a traversal twice in a row with <strong>different</strong> handlers should be equivalent
to running it <strong>once</strong> with the composition of those handlers.</p>
<pre><code class="language-hs">x &amp; myTraversal %~ f
  &amp; myTraversal %~ g
==
x &amp; myTraversal %~ (g . f)
</code></pre>
<p>The traversal should never change which elements it focuses due to
alterations on those elements.</p>
<p><code>filtered</code> breaks this law!</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt; 2 &amp; filtered even %~ (+1) &amp; filtered even %~ (*10)
-- 3

-- &gt;&gt;&gt; 2 &amp; filtered even %~ (*10) . (+1)
-- 30
</code></pre>
<h4 id="exercises---traversal-laws"><a class="header" href="#exercises---traversal-laws">Exercises - Traversal Laws</a></h4>
<ol>
<li>
<p><code>worded</code> violates the Law Two</p>
<!-- i 4 -->
<pre><code class="language-haskell">-- &gt;&gt;&gt;(&quot;hit the road, jack&quot; :: String) &amp; worded %~ take 3 &amp; worded %~ drop 2
-- &quot;t e a c&quot;

-- &gt;&gt;&gt;(&quot;hit the road, jack&quot; :: String) &amp; worded %~ (take 3 . drop 2)
-- &quot;t e ad, ck&quot;
</code></pre>
</li>
<li>
<p>Break the Law One</p>
<pre><code class="language-haskell">myTraversal :: Traversal Int Int Int Int
myTraversal f _ = f 1

-- &gt;&gt;&gt;(traverseOf myTraversal pure 6) :: Identity Int
-- Identity 1

-- &gt;&gt;&gt;pure 6 :: Identity Int
-- Identity 6
</code></pre>
</li>
<li>
<p>Break the Law Two</p>
<pre><code class="language-haskell">ex60 :: Traversal' [Int] Int
ex60 = traversed . filtered even

-- &gt;&gt;&gt; [1, 2, 3] &amp; ex60 %~ (+ 1) &amp; ex60 %~ (+ 2)
-- [1,3,3]

-- &gt;&gt;&gt; [1, 2, 3] &amp; ex60 %~ (+ 1) . (+ 2)
-- [1,5,3]
</code></pre>
</li>
<li>
<p>Check lawful</p>
</li>
</ol>
<ul>
<li>
<p><code>taking</code> is lawful</p>
</li>
<li>
<p><code>beside</code> is lawful</p>
</li>
<li>
<p><code>each</code> is lawful</p>
</li>
<li>
<p><code>lined</code> is unlawful</p>
</li>
<li>
<p><code>traversed</code> is lawful</p>
<!-- i 2 -->
<pre><code class="language-haskell">-- &gt;&gt;&gt;(&quot;hit\nthe\nroad,\njack&quot; :: String) &amp; lined %~ take 3 &amp; lined %~ drop 2
-- &quot;t\ne\na\nc&quot;

-- &gt;&gt;&gt;(&quot;hit\nthe\nroad,\njack&quot; :: String) &amp; lined %~ (take 3 . drop 2)
-- &quot;t\ne\nad,\nck&quot;
</code></pre>
</li>
</ul>
<p>update function can insert newlines</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt;(&quot;hit\nthe\nroad,\njack&quot; :: String) &amp; lined %~ (\(x:y:xs) -&gt; (x:y:'\n':xs)) &amp; lined %~ take 2
-- &quot;hi\nt\nth\ne\nro\nad\nja\nck&quot;

-- &gt;&gt;&gt;(&quot;hit\nthe\nroad,\njack&quot; :: String) &amp; lined %~ (take 2 . \(x:y:xs) -&gt; (x:y:'\n':xs))
-- &quot;hi\nth\nro\nja&quot;
</code></pre>
<!-- d -->
<h3 id="77-advanced-manipulation"><a class="header" href="#77-advanced-manipulation">7.7 Advanced manipulation</a></h3>
<h4 id="partsof"><a class="header" href="#partsof">partsOf</a></h4>
<p>Real:</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt;:t partsOf
-- partsOf :: Functor f =&gt; Traversing (-&gt;) f s t a a -&gt; LensLike f s t [a] [a]
</code></pre>
<p>Book:</p>
<ul>
<li>
<p>Make a lens whose focuses are focuses of a provided traversal</p>
<pre><code class="language-hs">partsOf :: Traversal' s a -&gt; Lens' s [a]
</code></pre>
</li>
</ul>
<pre><code class="language-haskell">-- &gt;&gt;&gt; [('a', 1 :: Int), ('b', 2), ('c', 3)] &amp; partsOf (traversed . _2) .~ [4]
-- [('a',4),('b',2),('c',3)]

-- &gt;&gt;&gt; [('a', 1 :: Int), ('b', 2), ('c', 3)] &amp; partsOf (traversed . _2) .~ [4,5,6,7,8]
-- [('a',4),('b',5),('c',6)]
</code></pre>
<p>Cool example:</p>
<ol>
<li>focus all characters in strings</li>
<li>concatenate, split into words, sort words, concatenate back</li>
<li>place on corresponding places</li>
</ol>
<pre><code class="language-haskell">-- &gt;&gt;&gt; (&quot;how is a raven &quot;, &quot;like a &quot;, &quot;writing desk&quot;) &amp; partsOf (each . traversed) %~ unwords . sort . words
-- (&quot;a a desk how is&quot;,&quot; like r&quot;,&quot;aven writing&quot;)
</code></pre>
<p>Placement matters</p>
<pre><code class="language-haskell">-- Collect 'each' tuple element into a list, then traverse that list
-- &gt;&gt;&gt; (&quot;abc&quot;, &quot;def&quot;) ^.. partsOf each . traversed
-- [&quot;abc&quot;,&quot;def&quot;]

-- Collect each tuple element, then traverse those strings collecting each character into a list.
-- &gt;&gt;&gt; ((&quot;abc&quot;, &quot;def&quot;) ^.. partsOf (each . traversed)) :: [String]
-- [&quot;abcdef&quot;]
</code></pre>
<p>Can use other focuses for calculating each</p>
<pre><code class="language-haskell">ex61 :: [(Char, Double)]
ex61 =
  [('a', 1), ('b', 2), ('c', 3)]
    &amp; partsOf (traversed . _2)
      %~ \xs -&gt; (/ sum xs) &lt;$&gt; xs

-- &gt;&gt;&gt;ex61
-- [('a',0.16666666666666666),('b',0.3333333333333333),('c',0.5)]
</code></pre>
<h4 id="polymorphic-partsof"><a class="header" href="#polymorphic-partsof">Polymorphic partsOf</a></h4>
<p>We can change type of focuses if supply enough elements</p>
<pre><code class="language-hs">unsafePartsOf :: Traversal s t a b -&gt; Lens s t [a] [b]
</code></pre>
<pre><code class="language-haskell">-- &gt;&gt;&gt;[('a', 1), ('b', 2), ('c', 3)] &amp; unsafePartsOf (traversed . _1) .~ [True, False]
-- unsafePartsOf': not enough elements were supplied

ex62 :: [((Char, Maybe Char), Integer)]
ex62 =
  [('a', 1), ('b', 2), ('c', 3)]
    &amp; unsafePartsOf (traversed . _1)
      %~ \xs -&gt; zip xs ((Just &lt;$&gt; tail xs) ++ [Nothing])

-- &gt;&gt;&gt;ex62
-- [(('a',Just 'b'),1),(('b',Just 'c'),2),(('c',Nothing),3)]
</code></pre>
<h4 id="partsof-and-other-data-structures"><a class="header" href="#partsof-and-other-data-structures">partsOf and other data structures</a></h4>
<p>Replace each ID in a Tree with a User</p>
<pre><code class="language-hs">userIds :: Tree UserId
lookupUsers :: [UserId] -&gt; IO [User]
treeLookup :: Tree UserId -&gt; IO (Tree User)
treeLookup = traverseOf (unsafePartsOf traversed) lookupUsers
</code></pre>
<h4 id="exercises---partsof"><a class="header" href="#exercises---partsof">Exercises - partsOf</a></h4>
<pre><code class="language-haskell">-- &gt;&gt;&gt; [1, 2, 3, 4] ^. partsOf (traversed . filtered even)
-- [2,4]

-- &gt;&gt;&gt; [&quot;Aardvark&quot; :: String, &quot;Bandicoot&quot;, &quot;Capybara&quot;] ^. traversed . partsOf (taking 3 traversed)
-- &quot;AarBanCap&quot;

ex63 :: [Int]
ex63 = ([1, 2], M.fromList [('a', 3), ('b', 4)]) ^. partsOf (beside traversed traversed)

-- &gt;&gt;&gt; ex63
-- [1,2,3,4]

-- &gt;&gt;&gt; [1, 2, 3, 4] &amp; partsOf (traversed . filtered even) .~ [20, 40]
-- [1,20,3,40]

-- &gt;&gt;&gt; [&quot;Aardvark&quot;, &quot;Bandicoot&quot;, &quot;Capybara&quot;] &amp; partsOf (traversed . traversed) .~ &quot;Kangaroo&quot;
-- [&quot;Kangaroo&quot;,&quot;Bandicoot&quot;,&quot;Capybara&quot;]

-- &gt;&gt;&gt; [&quot;Aardvark&quot;, &quot;Bandicoot&quot;, &quot;Capybara&quot;] &amp; partsOf (traversed . traversed) .~ &quot;Ant&quot;
-- [&quot;Antdvark&quot;,&quot;Bandicoot&quot;,&quot;Capybara&quot;]

-- Modifying
-- Tip: Map values are traversed in order by KEY
-- &gt;&gt;&gt; M.fromList [('a', 'a'), ('b', 'b'), ('c', 'c')] &amp; partsOf traversed %~ \(x:xs) -&gt; xs ++ [x]
-- fromList [('a','b'),('b','c'),('c','a')]

-- &gt;&gt;&gt; ('a', 'b', 'c') &amp; partsOf each %~ reverse
-- ('c','b','a')

-- &gt;&gt;&gt; [1, 2, 3, 4, 5, 6] &amp; partsOf (taking 3 traversed) %~ reverse
-- [3,2,1,4,5,6]

-- &gt;&gt;&gt; ('a', 'b', 'c') &amp; unsafePartsOf each %~ \xs -&gt; fmap ((,) xs) xs
-- ((&quot;abc&quot;,'a'),(&quot;abc&quot;,'b'),(&quot;abc&quot;,'c'))
</code></pre>
<h2 id="8-indexable-structures"><a class="header" href="#8-indexable-structures">8. Indexable Structures</a></h2>
<h3 id="81-whats-an-indexable-structure"><a class="header" href="#81-whats-an-indexable-structure">8.1 What's an &quot;indexable&quot; structure?</a></h3>
<p><strong>Indexable</strong> structures store values at <strong>named locations</strong> which can be identified by some <strong>index</strong>.
That is, an <strong>index</strong> represents a <strong>specific location</strong> within a data structure where a value <strong>might</strong> be stored.</p>
<p>Data structures have different interfaces (lists, dicts)</p>
<h3 id="82-accessing-and-updating-values-with-ixed"><a class="header" href="#82-accessing-and-updating-values-with-ixed">8.2 Accessing and updating values with 'Ixed'</a></h3>
<h4 id="the-ixed-class"><a class="header" href="#the-ixed-class">The Ixed Class</a></h4>
<p>Unifies the interface to all data structures.</p>
<pre><code class="language-hs">class Ixed m where
  ix :: Index m -&gt; Traversal' m (IxValue m)
</code></pre>
<p>makes a Traversal because an Index at a specified location may be missing.</p>
<p>These are Type Families that calculate an index an a value types for a data structure.</p>
<pre><code class="language-hs">type instance Index [a] = Int
type instance IxValue [a] = a

type instance Index (Map k a) = k
type instance IxValue (Map k a) = a

type instance Index Text = Int
type instance IxValue Text = Char

type instance Index ByteString = Int
type instance IxValue ByteString = Word8
</code></pre>
<h4 id="accessing-and-setting-values-with-ix"><a class="header" href="#accessing-and-setting-values-with-ix">Accessing and setting values with ix</a></h4>
<p>Can't add or remove focuses.</p>
<p>Lists:</p>
<pre><code class="language-haskell">humanoids :: [String]
humanoids = [&quot;Borg&quot;, &quot;Cardassian&quot;, &quot;Talaxian&quot;]

-- &gt;&gt;&gt; -- Get the value at index 1:
-- &gt;&gt;&gt; humanoids &amp; ix 1 .~ &quot;Vulcan&quot;
-- [&quot;Borg&quot;,&quot;Vulcan&quot;,&quot;Talaxian&quot;]
-- &gt;&gt;&gt; -- There's no value at index 10 so the traversal doesn't focus anything
-- &gt;&gt;&gt; humanoids &amp; ix 10 .~ &quot;Romulan&quot;
-- [&quot;Borg&quot;,&quot;Cardassian&quot;,&quot;Talaxian&quot;]
</code></pre>
<p>Maps:</p>
<pre><code class="language-haskell">benders :: M.Map String String
benders = M.fromList [(&quot;Katara&quot;, &quot;Water&quot;), (&quot;Toph&quot;, &quot;Earth&quot;), (&quot;Zuko&quot;, &quot;Fire&quot;)]

-- Get the value at key &quot;Zuko&quot;
-- &gt;&gt;&gt; benders ^? ix &quot;Zuko&quot;
-- Just &quot;Fire&quot;

-- If there's no value at a key, the traversal returns zero elements
-- &gt;&gt;&gt; benders ^? ix &quot;Sokka&quot;
-- Nothing

-- We can set the value at a key, but only if that key already exists
-- &gt;&gt;&gt; benders &amp; ix &quot;Toph&quot; .~ &quot;Metal&quot;
-- fromList [(&quot;Katara&quot;,&quot;Water&quot;),(&quot;Toph&quot;,&quot;Metal&quot;),(&quot;Zuko&quot;,&quot;Fire&quot;)]

-- Setting a non-existent element of a Map does NOT insert it.
-- &gt;&gt;&gt; benders &amp; ix &quot;Iroh&quot; .~ &quot;Lightning&quot;
-- fromList [(&quot;Katara&quot;,&quot;Water&quot;),(&quot;Toph&quot;,&quot;Earth&quot;),(&quot;Zuko&quot;,&quot;Fire&quot;)]
</code></pre>
<h4 id="indexed-structures"><a class="header" href="#indexed-structures">Indexed Structures</a></h4>
<pre><code class="language-haskell">-- &gt;&gt;&gt; :kind! forall a. Index [a]
-- forall a. Index [a] :: *
-- = Int

-- &gt;&gt;&gt; :kind! forall a. IxValue [a]
-- forall a. IxValue [a] :: *
-- = a
</code></pre>
<h4 id="indexing-monomorphic-types"><a class="header" href="#indexing-monomorphic-types">Indexing monomorphic types</a></h4>
<pre><code class="language-haskell">-- &gt;&gt;&gt;(&quot;hello&quot; :: T.Text) ^? ix 0
-- Just 'h'

-- We can edit a Word8 within a ByteString as though it's an integer.
-- &gt;&gt;&gt; (&quot;hello&quot; :: BS.ByteString) &amp; ix 0 +~ 2
-- &quot;jello&quot;
</code></pre>
<p>Cool example:</p>
<pre><code class="language-haskell">ex64 :: [T.Text]
ex64 = (&quot;hello&quot; :: T.Text) &amp; ix 1 %%~ const (&quot;aeiou&quot; :: [Char])
</code></pre>
<p>Explanation:</p>
<pre><code class="language-hs">type instance IxValue [a] = a
instance Ixed [a] where
  ix k f xs0 | k &lt; 0     = pure xs0
             | otherwise = go xs0 k where
    go [] _ = pure []
    go (a:as) 0 = f a &lt;&amp;&gt; (:as)
    go (a:as) i = (a:) &lt;$&gt; (go as $! i - 1)
  {-# INLINE ix #-}
</code></pre>
<p>So, we'll pre- and append the not-focused parts inside the Functorial context.</p>
<pre><code class="language-haskell">ex64' :: [String]
ex64' = ('h' :) &lt;$&gt; (const &quot;aeiou&quot; 'e' &lt;&amp;&gt; (: &quot;llo&quot;))

-- &gt;&gt;&gt;ex64'
-- [&quot;hallo&quot;,&quot;hello&quot;,&quot;hillo&quot;,&quot;hollo&quot;,&quot;hullo&quot;]
</code></pre>
<h4 id="indexing-stranger-structures"><a class="header" href="#indexing-stranger-structures">Indexing stranger structures</a></h4>
<p>Numbers denote node children</p>
<pre><code class="language-haskell">tree :: Tree Int
tree = Node 1 [Node 2 [Node 4 []], Node 3 [Node 5 [], Node 6 []]]

-- &gt;&gt;&gt; tree ^? ix [1, 1]
-- Just 6

-- &gt;&gt;&gt; tree ^? ix [5, 6]
-- Nothing
</code></pre>
<p>Functions:</p>
<blockquote>
<p>We can &quot;set&quot; or traverse individual results of a function!
Here we overwrite the function's output at the input value &quot;password&quot;
so it instead returns a new value.</p>
</blockquote>
<pre><code class="language-haskell">-- &gt;&gt;&gt; myPass = (reverse &amp; ix &quot;password&quot; .~ &quot;You found the secret!&quot;)
-- &gt;&gt;&gt; &quot;pass&quot; &amp; myPass
-- &quot;ssap&quot;
-- &gt;&gt;&gt; &quot;password&quot; &amp; myPass
-- &quot;You found the secret!&quot;
</code></pre>
<h3 id="83-inserting--deleting-with-at"><a class="header" href="#83-inserting--deleting-with-at">8.3 Inserting &amp; Deleting with 'At'</a></h3>
<h4 id="map-like-structures"><a class="header" href="#map-like-structures">Map-like structures</a></h4>
<p>Can be used with structures that support inserts by an arbitrary index.</p>
<ul>
<li><code>Map k v</code></li>
<li><code>Set k</code> (~ <code>Map k ()</code>)
Lists don't support that. E.g., can't insert 10th element without having 9th.</li>
</ul>
<pre><code class="language-hs">class At where
  at :: Index m -&gt; Lens' m (Maybe (IxValue m))

ix :: Index m -&gt; Traversal' m (IxValue m)
at :: Index m -&gt; Lens' m (Maybe (IxValue m))

(?~) :: Traversal s t a (Maybe b) -&gt; b -&gt; s -&gt; t
</code></pre>
<pre><code class="language-haskell">-- &gt;&gt;&gt;benders &amp; at &quot;Iroh&quot; ?~ &quot;Lightning&quot;
-- fromList [(&quot;Iroh&quot;,&quot;Lightning&quot;),(&quot;Katara&quot;,&quot;Water&quot;),(&quot;Toph&quot;,&quot;Earth&quot;),(&quot;Zuko&quot;,&quot;Fire&quot;)]
</code></pre>
<pre><code class="language-hs">sans :: At m =&gt; Index m -&gt; m -&gt; m
sans k = at k .~ Nothing
</code></pre>
<pre><code class="language-haskell">-- &gt;&gt;&gt; sans &quot;Katara&quot; benders
-- fromList [(&quot;Toph&quot;,&quot;Earth&quot;),(&quot;Zuko&quot;,&quot;Fire&quot;)]

ps :: [Int]
ps = foldl (\acc x -&gt; acc &lt;&gt; check acc x) [2] [3 .. 100]
 where
  check (a : as) x
    | a * a &gt; x = [x]
    | x `mod` a == 0 = []
    | otherwise = check as x
  check [] x = [x]

-- &gt;&gt;&gt; ps
-- [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]

primes :: S.Set Int
primes = S.fromList (ps ^.. taking 5 traversed)

-- &gt;&gt;&gt; primes &amp; at 17 ?~ ()
-- fromList [2,3,5,7,11,17]
</code></pre>
<h4 id="exercises---indexable-structuresm"><a class="header" href="#exercises---indexable-structuresm">Exercises - Indexable Structuresm</a></h4>
<ol>
<li>fill in blanks</li>
</ol>
<pre><code class="language-haskell">-- &gt;&gt;&gt; [&quot;Larry&quot;, &quot;Curly&quot;, &quot;Moe&quot;] &amp; ix 1 .~ &quot;Wiggly&quot;
-- [&quot;Larry&quot;,&quot;Wiggly&quot;,&quot;Moe&quot;]

heroesAndVillains :: M.Map String String
heroesAndVillains = M.fromList [(&quot;Superman&quot;, &quot;Lex&quot;), (&quot;Batman&quot;, &quot;Joker&quot;)]

-- &gt;&gt;&gt; heroesAndVillains &amp; at &quot;Spiderman&quot; .~ Just &quot;Goblin&quot;
-- fromList [(&quot;Batman&quot;,&quot;Joker&quot;),(&quot;Spiderman&quot;,&quot;Goblin&quot;),(&quot;Superman&quot;,&quot;Lex&quot;)]

-- &gt;&gt;&gt; sans &quot;Superman&quot; heroesAndVillains
-- fromList [(&quot;Batman&quot;,&quot;Joker&quot;)]

-- &gt;&gt;&gt; S.fromList ['a', 'e', 'i', 'o', 'u'] &amp; at 'y' .~ Just () &amp; at 'i' .~ Nothing
-- fromList &quot;aeouy&quot;
</code></pre>
<ol>
<li>input -&gt; output</li>
</ol>
<pre><code class="language-haskell">input :: M.Map String Integer
input = M.fromList [(&quot;candy bars&quot;, 13), (&quot;gum&quot;, 7), (&quot;soda&quot;, 34)]

output :: M.Map String Integer
output = M.fromList [(&quot;candy bars&quot;, 13), (&quot;ice cream&quot;, 5), (&quot;soda&quot;, 37)]

-- &gt;&gt;&gt; input &amp; at &quot;soda&quot; %~ ((+ 3) &lt;$&gt;) &amp; sans &quot;gum&quot; &amp; at &quot;ice cream&quot; ?~ 5
-- fromList [(&quot;candy bars&quot;,13),(&quot;ice cream&quot;,5),(&quot;soda&quot;,37)]

-- TODO find 8.5 + and prisms and
</code></pre>
<h2 id="10-isos"><a class="header" href="#10-isos">10. Isos</a></h2>
<ul>
<li>isomorphism - a completely <strong>reversible transformation</strong> between two types or formats.</li>
<li>every iso MUST succeed for all inputs.</li>
</ul>
<p><img src="haskell/optics-by-example/./README/tableIsos.png" alt="isos" /></p>
<p>Example: converting <code>Text</code> to <code>String</code>:</p>
<pre><code class="language-hs">T.pack . T.unpack = id
T.unpack . T.pack = id
</code></pre>
<p>Construct an <code>Iso</code>:</p>
<pre><code class="language-hs">iso :: (s -&gt; a) -&gt; (b -&gt; t) -&gt; Iso s t a b
</code></pre>
<pre><code class="language-haskell">packed :: Iso' String T.Text
packed = iso to' from'
 where
  to' :: String -&gt; T.Text
  to' = T.pack
  from' :: T.Text -&gt; String
  from' = T.unpack

-- &gt;&gt;&gt; (&quot;Ay, caramba!&quot; :: String) ^. packed
-- &quot;Ay, caramba!&quot;

-- Use isos as prisms
-- &gt;&gt;&gt; packed # (&quot;Sufferin' Succotash&quot; :: T.Text)
-- &quot;Sufferin' Succotash&quot;
</code></pre>
<h3 id="103-flipping-isos-with-from"><a class="header" href="#103-flipping-isos-with-from">10.3 Flipping isos with from</a></h3>
<pre><code class="language-hs">from :: Iso s t a b -&gt; Iso b a t s
from :: Iso' s a -&gt; Iso' a s
</code></pre>
<pre><code class="language-haskell">-- &gt;&gt;&gt; (&quot;Good grief&quot; :: T.Text) ^. from packed
-- &quot;Good grief&quot;
</code></pre>
<p>Reversing again.</p>
<pre><code class="language-hs">unpacked :: Iso' T.Text String
unpacked = from packed
</code></pre>
<h3 id="104-modification-under-isomorphism"><a class="header" href="#104-modification-under-isomorphism">10.4 Modification under isomorphism</a></h3>
<p>Example: focus on <code>Text</code> (to use functions existing for <code>Text</code>), then convert back to a <code>String</code>.</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt; let str = &quot;Idol on a pedestal&quot; :: String
-- &gt;&gt;&gt; over packed (T.replace &quot;Idol&quot; &quot;Sand&quot;) str
-- &quot;Sand on a pedestal&quot;

-- Combining with other optics
-- &gt;&gt;&gt; import Data.Char (toUpper)
-- &gt;&gt;&gt; let txt = &quot;Lorem ipsum&quot; :: T.Text
-- &gt;&gt;&gt; txt &amp; from packed . traversed %~ toUpper
-- &quot;LOREM IPSUM&quot;
</code></pre>
<h3 id="105-varieties-of-isomorphisms"><a class="header" href="#105-varieties-of-isomorphisms">10.5 Varieties of isomorphisms</a></h3>
<p>Isos for the same type</p>
<pre><code class="language-hs">reversed :: Iso' [a] [a]
reversed = iso reverse reverse

involuted :: (a -&gt; a) -&gt; Iso' a a
involuted f = iso f f

reversed :: Iso' [a] [a]
reversed = involuted reverse
</code></pre>
<pre><code class="language-haskell">-- &gt;&gt;&gt; &quot;Blue suede shoes&quot; &amp; reversed . taking 1 worded . reversed .~ &quot;gloves&quot;
-- &quot;Blue suede gloves&quot;
</code></pre>
<p>Rearrange pairs</p>
<pre><code class="language-hs">swapped :: Iso (s, s') (t, t') (a, a') (b, b')

swapped :: (Bifunctor p, Swapped p) =&gt; Iso (p a b) (p c d) (p b a) (p d c)
</code></pre>
<pre><code class="language-haskell">-- &gt;&gt;&gt; (&quot;Fall&quot;,&quot;Pride&quot;) ^. swapped
-- (&quot;Pride&quot;,&quot;Fall&quot;)

-- &gt;&gt;&gt; Right &quot;Field&quot; ^. swapped
-- Left &quot;Field&quot;
</code></pre>
<p>Isos for functions</p>
<pre><code class="language-hs">flipped :: Iso' (a -&gt; b -&gt; c) (b -&gt; a -&gt; c)
</code></pre>
<pre><code class="language-haskell">-- &gt;&gt;&gt; let (++?) = (++) ^. flipped
-- &gt;&gt;&gt; &quot;A&quot; ++? &quot;B&quot;
-- &quot;BA&quot;
</code></pre>
<p>more</p>
<pre><code class="language-hs">curried :: Iso' ((a, b) -&gt; c) (a -&gt; b -&gt; c)
uncurried :: Iso' (a -&gt; b -&gt; c) ((a, b) -&gt; c)
</code></pre>
<pre><code class="language-haskell">-- &gt;&gt;&gt; let addTuple = (+) ^. uncurried
-- &gt;&gt;&gt; addTuple (1, 2)
-- 3
</code></pre>
<p>Isos for numbers</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt; 100 ^. adding 50
-- 150
</code></pre>
<h4 id="composing-isos"><a class="header" href="#composing-isos">Composing isos</a></h4>
<pre><code class="language-haskell">-- &gt;&gt;&gt; import Numeric.Lens
-- &gt;&gt;&gt; 30 &amp; dividing 10 . multiplying 2 +~ 1
-- 35.0

-- 30 -&gt; 30/10 = 3 -&gt; 3 * 2 = 6 -&gt; 6 + 1 = 7 -&gt; 7 / 2 = 3.5 -&gt; 3.5 * 10 = 35
</code></pre>
<h4 id="exercises---intro-to-isos"><a class="header" href="#exercises---intro-to-isos">Exercises - Intro to Isos</a></h4>
<ol>
<li>
<p>Choose the best optic:</p>
<ul>
<li>Focus a Celsius temperature in Fahrenheit - Iso - reversible</li>
<li>Focus the last element of a list - Traversal - the element may be missing</li>
<li>View a JSON object as its corresponding Haskell Record - Prism - may fail to parse</li>
<li>Rotate the elements of a three-tuple one to the right - Iso - rotation is reversible</li>
<li>Focus on the 'bits' of an Int as Bools - Traversal or Prism - multiple focuses</li>
<li>Focusing an IntSet from a Set Int - Iso - reversible</li>
</ul>
</li>
<li>
<p>Fill in the blank</p>
</li>
</ol>
<pre><code class="language-haskell">-- &gt;&gt;&gt; (&quot;Beauty&quot;, &quot;Age&quot;) ^. swapped
-- (&quot;Age&quot;,&quot;Beauty&quot;)

-- &gt;&gt;&gt; 50 ^. adding 10
-- 60

-- &gt;&gt;&gt; 50 ^. from (adding 10)
-- 40

-- &gt;&gt;&gt; 0 &amp; multiplying 4 +~ 12
-- 3.0

-- &gt;&gt;&gt; 0 &amp; adding 10 . multiplying 2 .~ _
-- 2

-- Note: transpose flips the rows and columns of a nested list:
-- &gt;&gt;&gt; import Data.List (transpose)
-- &gt;&gt;&gt; transpose [[1, 2, 3], [10, 20, 30]]
-- [[1,10],[2,20],[3,30]]
-- &gt;&gt;&gt; [[1, 2, 3], [10, 20, 30]] &amp; involuted transpose %~ drop 1
-- [[2,3],[20,30]]

-- Extra hard: use `switchCase` somehow to make this statement work:
ex65 :: (Integer, String)
ex65 = (32, &quot;Hi&quot;) &amp; _2 . involuted (map switchCase) .~ (&quot;hELLO&quot; :: String)
 where
  switchCase c = if isUpper c then toLower c else toUpper c

-- &gt;&gt;&gt; ex65
-- (32,&quot;Hello&quot;)
</code></pre>
<ol>
<li>Conversion</li>
</ol>
<pre><code class="language-haskell">celsiusToF :: Double -&gt; Double
celsiusToF c = (c * (9 / 5)) + 32

fToCelsius :: Double -&gt; Double
fToCelsius f = (f - 32) * 5 / 9

fahrenheit' :: Iso' Double Double
fahrenheit' = iso fToCelsius celsiusToF

-- &gt;&gt;&gt; 0 &amp; fahrenheit' .~ 100
-- 212.0
</code></pre>
<!-- d -->
<h3 id="106-projecting-isos"><a class="header" href="#106-projecting-isos">10.6 Projecting Isos</a></h3>
<p>We can lift Isos into other structures.</p>
<pre><code class="language-hs">mapping :: (Functor f, Functor g) =&gt; Iso s t a b -&gt; Iso (f s) (g t) (f a) (g b)
</code></pre>
<pre><code class="language-haskell">toYamlList :: [String] -&gt; String
toYamlList xs = &quot;- &quot; &lt;&gt; intercalate &quot;\n- &quot; xs

shoppingList :: [T.Text]
shoppingList = [&quot;Milk&quot;, &quot;Eggs&quot;, &quot;Flour&quot;] :: [T.Text]

-- &gt;&gt;&gt; shoppingList ^. mapping unpacked . to toYamlList
-- &quot;- Milk\n- Eggs\n- Flour&quot;
</code></pre>
<p>There's more:</p>
<pre><code class="language-hs">contramapping :: Contravariant f =&gt; Iso s t a b -&gt; Iso (f a) (f b) (f s) (f t)
bimapping :: (Bifunctor f, Bifunctor g) =&gt; Iso s t a b -&gt; Iso s' t' a' b' -&gt; Iso (f s s') (g t t') (f a a') (g b b')
dimapping :: (Profunctor p, Profunctor q) =&gt; Iso s t a b -&gt; Iso s' t' a' b' -&gt; Iso (p a s') (q b t') (p s a') (q t b')
</code></pre>
<pre><code class="language-haskell">textToYamlList :: [T.Text] -&gt; T.Text
textToYamlList = (toYamlList :: [String] -&gt; String) ^. dimapping (mapping unpacked :: Iso' [T.Text] [String]) (packed :: Iso' String T.Text)

-- much more readable
textToYamlList' :: [T.Text] -&gt; T.Text
textToYamlList' = T.pack . toYamlList . fmap T.unpack
</code></pre>
<h4 id="exercises---projected-isos"><a class="header" href="#exercises---projected-isos">Exercises - Projected Isos</a></h4>
<ol>
<li>
<p>Fill in the blank</p>
<!-- i 4 -->
<pre><code class="language-haskell">-- &gt;&gt;&gt; (&quot;Beauty&quot;, &quot;Age&quot;) ^. mapping reversed . swapped
-- (&quot;egA&quot;,&quot;Beauty&quot;)

-- &gt;&gt;&gt; [True, False, True] ^. mapping (involuted not)
-- [False,True,False]

-- &gt;&gt;&gt; [True, False, True] &amp; mapping (involuted not) %~ filter id
-- [False]

-- &gt;&gt;&gt; (show ^. mapping reversed) 1234
-- &quot;4321&quot;
</code></pre>
</li>
<li>
<p>Using <code>enum :: Enum a =&gt; Iso' Int a</code> implement the <code>intNot</code>.</p>
<pre><code class="language-haskell">intNot :: Int -&gt; Int
intNot = not ^. dimapping enum (from enum)

-- &gt;&gt;&gt; intNot 0
-- 1

-- &gt;&gt;&gt; intNot 1
-- 0

-- &gt;&gt;&gt; intNot 2
-- Prelude.Enum.Bool.toEnum: bad argument

intNot' :: Int -&gt; Int
intNot' = fromEnum . not . toEnum @Bool

-- &gt;&gt;&gt; intNot' 0
-- 1

-- &gt;&gt;&gt; intNot' 1
-- 0

-- &gt;&gt;&gt; intNot' 2
-- Prelude.Enum.Bool.toEnum: bad argument
</code></pre>
</li>
</ol>
<!-- d -->
<h3 id="107-isos-and-newtypes"><a class="header" href="#107-isos-and-newtypes">10.7 Isos and newtypes</a></h3>
<h4 id="coercing-with-isos"><a class="header" href="#coercing-with-isos">Coercing with isos</a></h4>
<ul>
<li>Coercible is derived for newtypes by the compiler</li>
<li>Can coerce between newtypes</li>
</ul>
<pre><code class="language-hs">coerced :: (Coercible s a, Coercible t b) =&gt; Iso s t a b
</code></pre>
<pre><code class="language-haskell">newtype Email = Email {_email :: String} deriving (Show)

-- &gt;&gt;&gt; Email &quot;hi\nu&quot;
-- Email {_email = &quot;hi\nu&quot;}

-- &gt;&gt;&gt; over coerced (reverse :: String -&gt; String) (Email &quot;joe@example.com&quot;) :: Email
-- Email {_email = &quot;moc.elpmaxe@eoj&quot;}

email :: Iso' Email String
email = coerced

ex66 :: String
ex66 = Email &quot;joe@example.com&quot; ^. email . reversed
</code></pre>
<h4 id="newtype-wrapper-isos"><a class="header" href="#newtype-wrapper-isos">Newtype wrapper isos</a></h4>
<ul>
<li><code>makeLenses</code> derives isos</li>
</ul>
<pre><code class="language-hs">_Wrapped' :: Wrapped s =&gt; Iso' s (Unwrapped s)
_Unwrapped' :: Wrapped s =&gt; Iso' (Unwrapped s) s
</code></pre>
<ul>
<li>map <strong>only</strong> between types and their newtype wrappers.</li>
<li>can be generated via <code>makeWrapped</code></li>
</ul>
<pre><code class="language-haskell">makeWrapped ''Email

ex67 :: Email
ex67 = Email &quot;joe@example.com&quot; &amp; _Wrapped' @Email %~ reverse

-- &gt;&gt;&gt; ex67
-- Email {_email = &quot;moc.elpmaxe@eoj&quot;}
</code></pre>
<!-- d -->
<h3 id="108-laws"><a class="header" href="#108-laws">10.8 Laws</a></h3>
<h3 id="reversibility"><a class="header" href="#reversibility">Reversibility</a></h3>
<pre><code class="language-hs">myIso . from myIso == id
from myIso . myIso == id
</code></pre>
<pre><code class="language-haskell">-- &gt;&gt;&gt; view (from reversed . reversed) (&quot;Testing one two three&quot;)
-- &quot;Testing one two three&quot;
</code></pre>
<h4 id="exercises---iso-laws"><a class="header" href="#exercises---iso-laws">Exercises - Iso Laws</a></h4>
<ol>
<li>
<p>The following iso is unlawful; provide a counter example which shows that it breaks the law.</p>
<!-- i 4 -->
<pre><code class="language-haskell">mapList :: Ord k =&gt; Iso' (M.Map k v) [(k, v)]
mapList = iso M.toList M.fromList

kvInts :: [(Int, Int)]
kvInts = [(2 :: Int, 1 :: Int), (1, 2)]

ex68 :: [(Int, Int)]
ex68 = kvInts ^. from mapList . mapList

-- &gt;&gt;&gt; ex68
-- [(1,2),(2,1)]

-- &gt;&gt;&gt; ex68 == kvInts
-- False
</code></pre>
</li>
<li>
<p>Is there a lawful implementation of the following iso? If so, implement it, if not, why not?</p>
<ul>
<li>Yes, there is one.</li>
</ul>
<pre><code class="language-haskell">nonEmptyList :: Iso [a] [b] (Maybe (NonEmpty a)) (Maybe (NonEmpty b))
nonEmptyList = iso nonEmpty (maybe [] Data.List.NonEmpty.toList)

-- &gt;&gt;&gt; [] ^. nonEmptyList . from nonEmptyList
-- []

-- &gt;&gt;&gt; Nothing ^. from nonEmptyList . nonEmptyList
-- Nothing

-- &gt;&gt;&gt; [1] ^. nonEmptyList . from nonEmptyList
-- [1]

-- &gt;&gt;&gt; (Just (1 :| [])) ^. from nonEmptyList . nonEmptyList
-- Just (1 :| [])
</code></pre>
</li>
<li>
<p>Is there a lawful implementation of an iso which 'sorts' a list of elements? If so, implement it, if
not, why not?</p>
<pre><code class="language-hs">sorted :: Ord a =&gt; Iso' [a] [a]
</code></pre>
<ul>
<li>There's no implementation for this iso because it loses the info about the initial element order.</li>
</ul>
</li>
<li>
<p>What about the following iso which pairs each element with an Int which remembers its original
position in the list. Is this a lawful iso? Why or why not? If not, try to find a counter-example.</p>
<pre><code class="language-haskell">sorted :: (Ord a) =&gt; Iso' [a] [(Int, a)]
sorted = iso to' from'
 where
  to' xs = L.sortOn snd $ zip [0 ..] xs
  from' xs = snd &lt;$&gt; L.sortOn fst xs

-- &gt;&gt;&gt; [2, 1] ^. sorted . from sorted
-- [2,1]

-- &gt;&gt;&gt; [(1, 1), (0, 2)] ^. from sorted . sorted
-- [(1,1),(0,2)]
</code></pre>
</li>
</ol>
<!-- d -->
<h2 id="11-indexed-optics"><a class="header" href="#11-indexed-optics">11. Indexed Optics</a></h2>
<h3 id="111-what-are-indexed-optics"><a class="header" href="#111-what-are-indexed-optics">11.1 What are indexed optics?</a></h3>
<p>Let <strong>accumulate information</strong> about the <strong>current focus</strong>.</p>
<pre><code class="language-hs">itraversed :: TraversableWithIndex i t =&gt; IndexedTraversal i (t a) (t b) a b
</code></pre>
<p>There are instances of <code>TraversableWithIndex</code> for most data structures. Like <code>Ixed</code> and <code>At</code>.</p>
<pre><code class="language-hs">itoListOf :: IndexedGetting i (Endo [(i, a)]) s a -&gt; s -&gt; [(i, a)]
(^@..) :: s -&gt; IndexedGetting i (Endo [(i, a)]) s a -&gt; [(i, a)]
</code></pre>
<pre><code class="language-haskell">-- &gt;&gt;&gt; itoListOf itraversed [&quot;Summer&quot;, &quot;Fall&quot;, &quot;Winter&quot;, &quot;Spring&quot;]
-- [(0,&quot;Summer&quot;),(1,&quot;Fall&quot;),(2,&quot;Winter&quot;),(3,&quot;Spring&quot;)]
</code></pre>
<p>Indices are added by <code>actions</code>.
<code>Indexed action</code> accepts an <code>indexed optic</code></p>
<p><img src="haskell/optics-by-example/README/iActions.png" alt="actions" /></p>
<p>There are actions for: <code>Lens</code>, <code>Traversal</code>, <code>Fold</code>, <code>Getter</code>, <code>Setter</code>.</p>
<p>No actions for: <code>Prisms</code>, <code>Isos</code>.</p>
<p>Usually used for Folds or Traversals.</p>
<pre><code class="language-haskell">-- The index type of maps is the key,
-- so we can get a list of all elements and their key:
-- &gt;&gt;&gt; let agenda = M.fromList [(&quot;Monday&quot;, &quot;Shopping&quot;), (&quot;Tuesday&quot;, &quot;Swimming&quot;)]
-- &gt;&gt;&gt; agenda ^@.. itraversed
-- [(&quot;Monday&quot;,&quot;Shopping&quot;),(&quot;Tuesday&quot;,&quot;Swimming&quot;)]

-- The index type of trees is a list of int's
-- which indicates their location in the tree
-- (See the section on indexed data structures)
-- &gt;&gt;&gt; import Data.Tree
-- &gt;&gt;&gt; let t = Node &quot;top&quot; [Node &quot;left&quot; [], Node &quot;right&quot; []]
-- &gt;&gt;&gt; t ^@.. itraversed
-- [([],&quot;top&quot;),([0],&quot;left&quot;),([1],&quot;right&quot;)]
</code></pre>
<h3 id="112-index-composition"><a class="header" href="#112-index-composition">11.2 Index Composition</a></h3>
<p>Index of a path will be the index of the <strong>last</strong> indexed optic in the path.</p>
<pre><code class="language-haskell">agenda :: M.Map String [String]
agenda = M.fromList [(&quot;Monday&quot;, [&quot;Shopping&quot;, &quot;Yoga&quot;]), (&quot;Saturday&quot;, [&quot;Brunch&quot;, &quot;Food coma&quot;])]

-- &gt;&gt;&gt; agenda ^@.. itraversed . itraversed
-- [(0,&quot;Shopping&quot;),(1,&quot;Yoga&quot;),(0,&quot;Brunch&quot;),(1,&quot;Food coma&quot;)]
</code></pre>
<ul>
<li><code>(&lt;.)</code>: Use the index of the optic to the left</li>
<li><code>(.&gt;)</code>: Use the index of the optic to the right (This is how . already behaves)</li>
<li><code>(&lt;.&gt;)</code>: Combine the indices of both sides as a tuple</li>
</ul>
<p>Use map key as an index</p>
<pre><code class="language-haskell">-- &gt;&gt;&gt; agenda ^@.. itraversed &lt;. itraversed
-- [(&quot;Monday&quot;,&quot;Shopping&quot;),(&quot;Monday&quot;,&quot;Yoga&quot;),(&quot;Saturday&quot;,&quot;Brunch&quot;),(&quot;Saturday&quot;,&quot;Food coma&quot;)]

-- &gt;&gt;&gt; agenda ^@.. itraversed &lt;.&gt; itraversed
-- [((&quot;Monday&quot;,0),&quot;Shopping&quot;),((&quot;Monday&quot;,1),&quot;Yoga&quot;),((&quot;Saturday&quot;,0),&quot;Brunch&quot;),((&quot;Saturday&quot;,1),&quot;Food coma&quot;)]
</code></pre>
<h4 id="custom-index-composition"><a class="header" href="#custom-index-composition">Custom index composition</a></h4>
<p><code>icompose</code> Composition of Indexed functions with a user supplied function for combining indices.</p>
<pre><code class="language-hs">icompose :: Indexable p c
         =&gt; (i -&gt; j -&gt; p)
         -&gt; (Indexed i s t -&gt; r)
         -&gt; (Indexed j a b -&gt; s -&gt; t)
         -&gt; c a b
         -&gt; r
</code></pre>
<pre><code class="language-haskell">showDayAndNumber :: String -&gt; Int -&gt; String
showDayAndNumber a b = a &lt;&gt; &quot;: &quot; &lt;&gt; show b

-- &gt;&gt;&gt; agenda ^@.. icompose showDayAndNumber itraversed itraversed
-- [(&quot;Monday: 0&quot;,&quot;Shopping&quot;),(&quot;Monday: 1&quot;,&quot;Yoga&quot;),(&quot;Saturday: 0&quot;,&quot;Brunch&quot;),(&quot;Saturday: 1&quot;,&quot;Food coma&quot;)]
</code></pre>
<p>custom operator</p>
<pre><code class="language-hs">(&lt;symbols&gt;) :: (Indexed &lt;indexTypeA&gt; s t -&gt; r)
            -&gt; (Indexed &lt;indexTypeB&gt; a b -&gt; s -&gt; t)
            -&gt; (Indexed &lt;combinedType&gt; a b -&gt; r)
(&lt;symbols&gt;) = icompose &lt;combinationFunction&gt;
</code></pre>
<pre><code class="language-haskell">(.++) :: (Indexed String s t -&gt; r) -&gt; (Indexed String a b -&gt; s -&gt; t) -&gt; Indexed String a b -&gt; r
(.++) = icompose (\a b -&gt; a ++ &quot;, &quot; ++ b)

populationMap :: M.Map String (M.Map String Int)
populationMap =
  M.fromList
    [ (&quot;Canada&quot;, M.fromList [(&quot;Ottawa&quot;, 994837), (&quot;Toronto&quot;, 2930000)])
    , (&quot;Germany&quot;, M.fromList [(&quot;Berlin&quot;, 3748000), (&quot;Munich&quot;, 1456000)])
    ]

-- &gt;&gt;&gt; populationMap ^@.. itraversed .++ itraversed
-- [(&quot;Canada, Ottawa&quot;,994837),(&quot;Canada, Toronto&quot;,2930000),(&quot;Germany, Berlin&quot;,3748000),(&quot;Germany, Munich&quot;,1456000)]
</code></pre>
<h4 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h4>
<pre><code class="language-haskell">-- &gt;&gt;&gt; M.fromList [(&quot;streamResponse&quot;, False), (&quot;useSSL&quot;, True)] ^@.. itraversed
-- [(&quot;streamResponse&quot;,False),(&quot;useSSL&quot;,True)]

-- &gt;&gt;&gt; (M.fromList [('a', 1), ('b', 2)], M.fromList [('c', 3), ('d', 4)]) ^@.. both . itraversed
-- [('a',1),('b',2),('c',3),('d',4)]

ex69 :: [(Char, Bool)]
ex69 = M.fromList [('a', (True, 1)), ('b', (False, 2))] ^@.. itraversed &lt;. _1

-- &gt;&gt;&gt; ex69
-- [('a',True),('b',False)]

-- &gt;&gt;&gt; [M.fromList [(&quot;Tulips&quot;, 5), (&quot;Roses&quot;, 3)] , M.fromList [(&quot;Goldfish&quot;, 11), (&quot;Frogs&quot;, 8)]] ^@.. itraversed &lt;.&gt; itraversed
-- [((0,&quot;Roses&quot;),3),((0,&quot;Tulips&quot;),5),((1,&quot;Frogs&quot;),8),((1,&quot;Goldfish&quot;),11)]

ex70 :: [Int]
ex70 = [10 :: Int, 20, 30] &amp; itraversed %@~ (+)

-- &gt;&gt;&gt; ex70
-- [10,21,32]

ex71 :: IO [String]
ex71 = itraverseOf itraversed (\i s -&gt; pure (replicate i ' ' &lt;&gt; s)) [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]

-- &gt;&gt;&gt; ex71
-- [&quot;one&quot;,&quot; two&quot;,&quot;  three&quot;]

-- &gt;&gt;&gt; itraverseOf itraversed (\n s -&gt; pure (show n &lt;&gt; &quot;: &quot; &lt;&gt; s)) [&quot;Go shopping&quot;, &quot;Eat lunch&quot;, &quot;Take a nap&quot;]
-- [&quot;0: Go shopping&quot;,&quot;1: Eat lunch&quot;,&quot;2: Take a nap&quot;]
</code></pre>
<h3 id="113-filtering-by-index"><a class="header" href="#113-filtering-by-index">11.3 Filtering by index</a></h3>
<pre><code class="language-hs">indices :: (Indexable i p, Applicative f) =&gt; (i -&gt; Bool) -&gt; Optical' p (Indexed i) f a a
</code></pre>
<pre><code class="language-haskell">-- Get list elements with an 'even' list-index:
-- &gt;&gt;&gt; ['a'..'z'] ^.. itraversed . indices even
-- &quot;acegikmoqsuwy&quot;

ratings :: M.Map String Integer
ratings =
  M.fromList
    [ (&quot;Dark Knight&quot;, 94)
    , (&quot;Dark Knight Rises&quot;, 87)
    , (&quot;Death of Superman&quot;, 92)
    ]

-- &gt;&gt;&gt; ratings ^.. itraversed . indices (has (prefixed &quot;Dark&quot;))
-- [94,87]
</code></pre>
<p>Target a single index</p>
<pre><code class="language-hs">index :: (Indexable i p, Eq i, Applicative f) =&gt; i -&gt; Optical' p (Indexed i) f a a
</code></pre>
<pre><code class="language-haskell">-- &gt;&gt;&gt; ratings ^? itraversed . index &quot;Death of Superman&quot;
-- Just 92
</code></pre>
<h4 id="exercises-2"><a class="header" href="#exercises-2">Exercises</a></h4>
<ol>
<li>
<p>Exercises schedule</p>
<ul>
<li>
<p>data</p>
<!-- i 8 -->
<pre><code class="language-haskell">exercises :: M.Map String (M.Map String Int)
exercises =
  M.fromList
    [ (&quot;Monday&quot;, M.fromList [(&quot;pushups&quot;, 10), (&quot;crunches&quot;, 20)])
    , (&quot;Wednesday&quot;, M.fromList [(&quot;pushups&quot;, 15), (&quot;handstands&quot;, 3)])
    , (&quot;Friday&quot;, M.fromList [(&quot;crunches&quot;, 25), (&quot;handstands&quot;, 5)])
    ]

-- &gt;&gt;&gt; exercises
-- fromList [(&quot;Friday&quot;,fromList [(&quot;crunches&quot;,25),(&quot;handstands&quot;,5)]),(&quot;Monday&quot;,fromList [(&quot;crunches&quot;,20),(&quot;pushups&quot;,10)]),(&quot;Wednesday&quot;,fromList [(&quot;handstands&quot;,3),(&quot;pushups&quot;,15)])]
</code></pre>
</li>
<li>
<p>Compute the total number of &quot;crunches&quot; you should do this week.</p>
<pre><code class="language-haskell">ex72 :: Int
ex72 = sumOf (traversed . itraversed . indices (has (only &quot;crunches&quot;))) exercises

-- &gt;&gt;&gt; ex72
-- 45
</code></pre>
</li>
<li>
<p>Compute the number of reps you need to do across all exercise types on Wednesday.</p>
<pre><code class="language-haskell">ex73 :: Int
ex73 = sumOf (itraversed . indices (has (only &quot;Wednesday&quot;)) . traversed) exercises

-- &gt;&gt;&gt; ex73
-- 18
</code></pre>
</li>
<li>
<p>List out the number of pushups you need to do each day, you can use ix to help this time if you wish.</p>
<pre><code class="language-haskell">ex74 :: [Int]
ex74 = exercises ^.. traversed . at &quot;pushups&quot; . non 0

-- &gt;&gt;&gt; ex74
-- [0,10,15]
</code></pre>
</li>
</ul>
</li>
<li>
<p>Board</p>
<ul>
<li>
<p>data</p>
<!-- i 8 -->
<pre><code class="language-haskell">board :: [String]
board =
  [ &quot;XOO&quot;
  , &quot;.XO&quot;
  , &quot;X..&quot;
  ]
</code></pre>
</li>
<li>
<p>Generate a list of positions alongside their (row, column) coordinates.</p>
<pre><code class="language-haskell">ex75 :: [((Int, Int), Char)]
ex75 = board ^@.. itraversed &lt;.&gt; itraversed

-- &gt;&gt;&gt; ex75
-- [((0,0),'X'),((0,1),'O'),((0,2),'O'),((1,0),'.'),((1,1),'X'),((1,2),'O'),((2,0),'X'),((2,1),'.'),((2,2),'.')]
</code></pre>
</li>
<li>
<p>Set the empty square at (1, 0) to an 'X'. HINT: When using the custom composition operators you'll often need to introduce parenthesis to get the right precedence.</p>
<pre><code class="language-haskell">ex76 :: [String]
ex76 = board &amp; ix 1 . ix 0 .~ 'X'

-- &gt;&gt;&gt; ex76
-- [&quot;XOO&quot;,&quot;XXO&quot;,&quot;X..&quot;]
</code></pre>
</li>
<li>
<p>Get the 2nd <em>column</em> as a list (e.g. &quot;OX.&quot;). Try to do it using index instead of indices!</p>
<pre><code class="language-haskell">ex77 :: [Char]
ex77 = board ^.. itraversed . itraversed . index 1

-- &gt;&gt;&gt; ex77
-- &quot;OX.&quot;
</code></pre>
</li>
<li>
<p>Get the 3rd row as a list (e.g. &quot;X..&quot;). Try to do it using index instead of indices! HINT: The precedence for this one can be tricky too.</p>
<pre><code class="language-haskell">ex78 :: [String]
ex78 = board ^.. itraversed . index 2

-- &gt;&gt;&gt; ex78
-- [&quot;X..&quot;]
</code></pre>
</li>
</ul>
</li>
</ol>
<!-- d -->
<h3 id="114-custom-indexed-optics"><a class="header" href="#114-custom-indexed-optics">11.4 Custom indexed optics</a></h3>
<p>Tic-Tac-Toe</p>
<pre><code class="language-haskell">data Board a = Board a a a a a a a a a deriving (Show, Foldable)

data Position = I | II | III deriving (Show, Eq, Ord)

testBoard :: Board Char
testBoard = Board 'X' 'O' 'X' '.' 'X' 'O' '.' 'O' 'X'
</code></pre>
<p>Want to access positions in grid. Need to index.</p>
<pre><code class="language-hs">ifolding :: (Foldable f, Indexable i p, Contravariant g, Applicative g) =&gt; (s -&gt; f (i, a)) -&gt; Over p g s t a b
</code></pre>
<pre><code class="language-haskell">slotsFold :: IndexedFold (Position, Position) (Board a) a
slotsFold =
  ifolding $ \board_ -&gt;
    -- Use a list comprehension to get the list of all coordinate pairs
    -- in the correct order, then zip them with all the slots in our board
    zip
      [(x, y) | y &lt;- [I, II, III], x &lt;- [I, II, III]]
      (Foldable.toList board_)

-- &gt;&gt;&gt; testBoard ^@.. slotsFold
-- [((I,I),'X'),((II,I),'O'),((III,I),'X'),((I,II),'.'),((II,II),'X'),((III,II),'O'),((I,III),'.'),((II,III),'O'),((III,III),'X')]

-- Filter indices where the Y coord is 'II'
-- &gt;&gt;&gt; testBoard ^@.. slotsFold . indices ((== II) . snd)
-- [((I,II),'.'),((II,II),'X'),((III,II),'O')]
</code></pre>
<h4 id="custom-indexedtraversals"><a class="header" href="#custom-indexedtraversals">Custom IndexedTraversals</a></h4>
<pre><code class="language-haskell">-- define a polymorphic indexed traversal with a tuple of positions as the index:
slotsTraversal :: IndexedTraversal (Position, Position) (Board a) (Board b) a b
slotsTraversal p (Board a1 b1 c1 a2 b2 c2 a3 b3 c3) =
  Board
    &lt;$&gt; indexed p (I, I) a1
    &lt;*&gt; indexed p (II, I) b1
    &lt;*&gt; indexed p (III, I) c1
    &lt;*&gt; indexed p (I, II) a2
    &lt;*&gt; indexed p (II, II) b2
    &lt;*&gt; indexed p (III, II) c2
    &lt;*&gt; indexed p (I, III) a3
    &lt;*&gt; indexed p (II, III) b3
    &lt;*&gt; indexed p (III, III) c3

-- &gt;&gt;&gt; testBoard ^@.. slotsTraversal
-- [((I,I),'X'),((II,I),'O'),((III,I),'X'),((I,II),'.'),((II,II),'X'),((III,II),'O'),((I,III),'.'),((II,III),'O'),((III,III),'X')]

-- &gt;&gt;&gt; testBoard &amp; slotsTraversal . indices ((== II) . snd) .~ '?'
-- Board 'X' 'O' 'X' '?' '?' '?' '.' 'O' 'X'

printBoard :: Board Char -&gt; String
printBoard = execWriter . itraverseOf slotsTraversal printSlot
 where
  printSlot (III, _) c = tell ([c] &lt;&gt; &quot;\n&quot;) &gt;&gt; pure [c]
  printSlot (_, _) c = tell [c] &gt;&gt; pure [c]

-- &gt;&gt;&gt; printBoard testBoard
-- &quot;XOX\n.XO\n.OX\n&quot;
</code></pre>
<pre><code class="language-hs">type IndexedTraversal i s t a b = forall p f. (Indexable i p, Applicative f) =&gt; p a (f b) -&gt; s -&gt; f t
</code></pre>
<p><code>p</code> is a <code>Profunctor</code>.</p>
<p><code>indexed p</code> reduces it to a function</p>
<pre><code class="language-hs">indexed :: Indexable i p =&gt; p a b -&gt; i -&gt; a -&gt; b
</code></pre>
<p>There's also <code>ilens</code>:</p>
<pre><code class="language-hs">ilens :: (s -&gt; (i, a)) -&gt; (s -&gt; b -&gt; t) -&gt; IndexedLens i s t a b
</code></pre>
<h4 id="index-helpers"><a class="header" href="#index-helpers">Index helpers</a></h4>
<p>Add numeric index alongside elements of an optic.</p>
<pre><code class="language-hs">indexing :: Traversal s t a b -&gt; IndexedTraversal Int s t a b
</code></pre>
<pre><code class="language-haskell">-- &gt;&gt;&gt; (&quot;hello&quot; :: T.Text) ^@.. indexing each
-- [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
</code></pre>
<p>Re-map or edit the indexes of an optic</p>
<pre><code class="language-hs">reindexed :: Indexable j p =&gt; (i -&gt; j) -&gt; (Indexed i a b -&gt; r) -&gt; p a b -&gt; r
</code></pre>
<pre><code class="language-haskell">-- &gt;&gt;&gt; ['a'..'c'] ^@.. itraversed
-- [(0,'a'),(1,'b'),(2,'c')]

-- &gt;&gt;&gt; ['a'..'c'] ^@.. reindexed (*10) itraversed
-- [(0,'a'),(10,'b'),(20,'c')]
</code></pre>
<p>Set the index of the path to the current value.
This is to bring the upper context to lower path sections.
Useful for JSON.</p>
<pre><code class="language-hs">selfIndex :: Indexable a p =&gt; p a fb -&gt; a -&gt; fb
</code></pre>
<pre><code class="language-haskell">-- &gt;&gt;&gt; [(&quot;Betty&quot;, 37), (&quot;Veronica&quot;, 12)] ^.. itraversed . selfIndex &lt;. _2
-- [((&quot;Betty&quot;,37),37),((&quot;Veronica&quot;,12),12)]
</code></pre>
<h4 id="exercises---custom-indexed-optics"><a class="header" href="#exercises---custom-indexed-optics">Exercises - Custom Indexed Optics</a></h4>
<ol>
<li>Write an indexed Traversal</li>
</ol>
<!-- i 2 -->
<pre><code class="language-haskell">-- pair :: IndexedFold Bool (a, a) a
pair :: IndexedTraversal Bool (a, a) (b, b) a b
pair p (x, y) = (,) &lt;$&gt; indexed p False x &lt;*&gt; indexed p True y

-- &gt;&gt;&gt; ('a', 'b') ^@.. pair
-- [(False,'a'),(True,'b')]
</code></pre>
<ol>
<li>
<p>Use <code>reindexed</code> to provide an indexed list traversal which starts at <code>1</code> instead of <code>0</code>.</p>
<!-- i 6 -->
<ul>
<li>
<p><code>oneIndexed</code></p>
<pre><code class="language-haskell">oneIndexed :: IndexedTraversal Int [a] [b] a b
oneIndexed = reindexed (+ 1) itraversed

-- &gt;&gt;&gt; ['a'..'d'] ^@.. oneIndexed
-- [(1,'a'),(2,'b'),(3,'c'),(4,'d')]
</code></pre>
</li>
<li>
<p>Use <code>reindexed</code> to write a traversal indexed by the distance to the end of the list.</p>
<pre><code class="language-haskell">invertedIndex :: IndexedTraversal Int [a] [b] a b
invertedIndex p x = reindexed ((length x - 1) -) itraversed p x

-- &gt;&gt;&gt; ['a'..'d'] ^@.. invertedIndex
-- [(3,'a'),(2,'b'),(1,'c'),(0,'d')]
</code></pre>
</li>
</ul>
</li>
<li>
<p>Build the following combinators using only compositions of other optics.</p>
<!-- i 4 -->
<pre><code class="language-haskell">chars :: IndexedTraversal Int T.Text T.Text Char Char
chars p x = T.pack &lt;$&gt; itraversed p (T.unpack x)

-- &gt;&gt;&gt; (&quot;banana&quot; :: T.Text) ^@.. chars
-- [(0,'b'),(1,'a'),(2,'n'),(3,'a'),(4,'n'),(5,'a')]

-- charCoords :: IndexedTraversal (Int, Int) String String Char Char
-- charCoords p x = itraversed p (itraversed p (lines x))

chc :: [((Int, Int), Char)]
chc = &quot;line\nby\nline&quot; ^@.. indexing lined &lt;.&gt; itraversed

-- &gt;&gt;&gt; chc
-- [((0,0),'l'),((0,1),'i'),((0,2),'n'),((0,3),'e'),((1,0),'b'),((1,1),'y'),((2,0),'l'),((2,1),'i'),((2,2),'n'),((2,3),'e')]
</code></pre>
</li>
</ol>
<!-- d -->
<h3 id="115-index-preserving-optics"><a class="header" href="#115-index-preserving-optics">11.5 Index-preserving optics</a></h3>
<p>Some optics forget the index. Can make existing optics index-preserving.</p>
<pre><code class="language-hs">cloneIndexPreservingLens :: Lens s t a b -&gt; IndexPreservingLens s t a b
cloneIndexPreservingTraversal :: Traversal s t a b -&gt; IndexPreservingTraversal s t a b
cloneIndexPreservingSetter :: Setter s t a b -&gt; IndexPreservingSetter s t a b
</code></pre>
<pre><code class="language-haskell">-- Now the index 'passes-through' `_1'` to the end.
-- &gt;&gt;&gt; let _1' = cloneIndexPreservingLens _1
-- &gt;&gt;&gt; [('a', True), ('b', False), ('c', True)] ^@.. itraversed . _1'
-- [(0,'a'),(1,'b'),(2,'c')]
</code></pre>
<p>Or, make lens index-preserving initially.</p>
<pre><code class="language-hs">iplens :: (s -&gt; a) -&gt; (s -&gt; b -&gt; t) -&gt; IndexPreservingLens s t a b
</code></pre>
<h3 id="13-optics-and-monads"><a class="header" href="#13-optics-and-monads">13. Optics and Monads</a></h3>
<h4 id="131-reader-monad-and-view"><a class="header" href="#131-reader-monad-and-view">13.1 Reader Monad and View</a></h4>
<pre><code class="language-hs">view :: MonadReader s m =&gt; Getting a s a -&gt; m a
</code></pre>
<p><code>s -&gt; a</code> is a valid <code>MonadReader s m =&gt; m a</code> where <code>m ~ (-&gt;) s</code></p>
<pre><code class="language-hs">instance Monad ((-&gt;) r) where
  return = const
  f &gt;&gt;= k = \r -&gt; k (f r) r
</code></pre>
<pre><code class="language-haskell">type UserName = String
type Password = String
data Env = Env
  { _currentUser :: UserName
  , _users :: M.Map UserName Password
  }
  deriving (Show)

makeLenses ''Env

getUserPassword :: ReaderT Env IO (Maybe String)
getUserPassword = do
  userName_ &lt;- view currentUser
  maybePassword &lt;- preview (users . ix userName_)
  liftIO $ pure maybePassword

-- &gt;&gt;&gt; flip runReaderT (Env &quot;Hey&quot; (M.fromList [(&quot;Hey&quot;, &quot;password&quot;)])) getUserPassword
-- Just &quot;password&quot;

-- st :: String
st2 :: [Char]
st2 = (&quot;optics by fun&quot; :: String) &amp; itraversed %@~ \i c -&gt; chr (ord c + i)

-- &gt;&gt;&gt; st2
-- &quot;oqvlgx&amp;i\129)p\128z&quot;

st :: String
st = &quot;oqvlgx&amp;i\129)p\128z&quot; &amp; itraversed %@~ \i c -&gt; chr (ord c - i)

-- &gt;&gt;&gt; st
-- &quot;optics by fun&quot;
</code></pre>
<h3 id="132-state-monad-combinators"><a class="header" href="#132-state-monad-combinators">13.2 State Monad Combinators</a></h3>
<ul>
<li>till calculator for recording the sale of a couple beers</li>
</ul>
<pre><code class="language-haskell">data Till = Till
  { _total :: Double
  , _sales :: [Double]
  , _taxRate :: Double
  }
  deriving (Show)

makeLenses ''Till
</code></pre>
<pre><code class="language-hs">(.=) :: MonadState s m =&gt; Lens s s a b -&gt; b -&gt; m ()
</code></pre>
<pre><code class="language-haskell">saleCalculation :: StateT Till IO ()
saleCalculation = do
  total .= 0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# LANGUAGE BlockArguments #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeFamilies #-}

module Extra where

import Control.Lens
import Control.Monad.State (execState, modify)
import Data.Generics.Labels ()
import Data.Map (fromList)
import Data.Map qualified as Map
import Data.Text qualified as Text
import Data.Traversable (for)
</code></pre>
<h2 id="non"><a class="header" href="#non"><code>non</code></a></h2>
<pre><code class="language-haskell">ex1 :: Map.Map Text.Text Int
ex1 = fromList [(&quot;WORLD&quot;, 456)]

ex2 :: Map.Map Text.Text Int
ex2 = ex1 &amp; at &quot;HELLO&quot; . non 678 .~ 3

-- &gt;&gt;&gt; x1
-- fromList [(&quot;HELLO&quot;,3),(&quot;WORLD&quot;,456)]
</code></pre>
<h2 id="update-at-multiple-indices"><a class="header" href="#update-at-multiple-indices">update at multiple indices</a></h2>
<pre><code class="language-haskell">ex3 :: [Text.Text] -&gt; Int -&gt; Map.Map Text.Text Int -&gt; Map.Map Text.Text Int
ex3 ks val = execState (traverse (\k -&gt; modify (at k ?~ val)) ks)

ex4 :: Map.Map Text.Text Int
ex4 = Map.empty &amp; ex3 [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] 4

-- &gt;&gt;&gt; ex4
-- fromList [(&quot;a&quot;,4),(&quot;b&quot;,4),(&quot;c&quot;,4)]

ex5 :: Map.Map String Integer
ex5 = Map.empty &amp;~ for [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;] (\k -&gt; at k ?= 10)

-- &gt;&gt;&gt; ex5
-- fromList [(&quot;b&quot;,10),(&quot;c&quot;,10),(&quot;d&quot;,10)]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-2"><a class="header" href="#chapter-2">Chapter 2</a></h1>
<pre><code class="language-haskell">{-# LANGUAGE DataKinds #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# OPTIONS_GHC -Wno-unused-imports #-}

module Chapter02 where

import Control.Monad.Trans.Class (MonadTrans)
import GHC.TypeLits
</code></pre>
<h2 id="232"><a class="header" href="#232">2.3.2</a></h2>
<pre><code class="language-haskell">-- &gt;&gt;&gt;:kind! (1 + 17) - 3
-- (1 + 17) - 3 :: Natural
-- = 15

-- &gt;&gt;&gt;:kind! (Div 128 8) ^ 2
-- (Div 128 8) ^ 2 :: Natural
-- = 256
</code></pre>
<h2 id="233"><a class="header" href="#233">2.3.3</a></h2>
<h3 id="233-i"><a class="header" href="#233-i">2.3.3-i</a></h3>
<pre><code class="language-haskell">-- &gt;&gt;&gt;:kind! Show
-- Show :: * -&gt; Constraint
-- = Show
</code></pre>
<h3 id="233-ii"><a class="header" href="#233-ii">2.3.3-ii</a></h3>
<pre><code class="language-haskell">-- &gt;&gt;&gt;:kind! Functor
-- Functor :: (* -&gt; *) -&gt; Constraint
-- = Functor
</code></pre>
<h3 id="233-iv"><a class="header" href="#233-iv">2.3.3-iv</a></h3>
<pre><code class="language-haskell">-- &gt;&gt;&gt;:kind! Monad
-- Monad :: (* -&gt; *) -&gt; Constraint
-- = Monad
</code></pre>
<h3 id="233-v"><a class="header" href="#233-v">2.3.3-v</a></h3>
<pre><code class="language-haskell">-- &gt;&gt;&gt;:kind! MonadTrans
-- MonadTrans :: ((* -&gt; *) -&gt; * -&gt; *) -&gt; Constraint
-- = MonadTrans
</code></pre>
<h3 id="241"><a class="header" href="#241">2.4.1</a></h3>
<pre><code class="language-haskell">type family Not (x :: Bool) :: Bool where
  Not 'True = 'False
  Not 'False = 'True

type family Foo1 (x :: Bool) (y :: Bool) :: Bool
type family Bar1 x y :: Bool -&gt; Bool -&gt; Bool

-- &gt;&gt;&gt;:kind Foo1
-- Foo1 :: Bool -&gt; Bool -&gt; Bool

-- &gt;&gt;&gt;:kind Bar1
-- Bar1 :: * -&gt; * -&gt; Bool -&gt; Bool -&gt; Bool
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-3"><a class="header" href="#chapter-3">Chapter 3</a></h1>
<pre><code class="language-haskell">{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE UndecidableInstances #-}

module Chapter03 where
</code></pre>
<p>Variance</p>
<pre><code class="language-haskell">newtype T1 a = T1 (Int -&gt; a)
newtype T2 a = T2 (a -&gt; Int)
newtype T3 a = T3 (a -&gt; a)
newtype T4 a = T4 ((Int -&gt; a) -&gt; a)
newtype T5 a = T5 ((a -&gt; Int) -&gt; Int)
</code></pre>
<h2 id="3-is"><a class="header" href="#3-is">3-is</a></h2>
<pre><code class="language-haskell">instance Functor T1 where
  fmap f (T1 g) = T1 $ f . g

instance Functor T5 where
  fmap f (T5 g) = T5 $ \b -&gt; g (b . f)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-4"><a class="header" href="#chapter-4">Chapter 4</a></h1>
<!-- FOURMOLU_DISABLE -->
<pre><code class="language-haskell">{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE UndecidableInstances #-}
{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}
{-# HLINT ignore &quot;Unused LANGUAGE pragma&quot; #-}

module Chapter04 where

import Data.Typeable (Proxy (..), typeRep)

tr = typeRep (Proxy :: Proxy (Maybe Int))

-- &gt;&gt;&gt; tr
-- Maybe Int

-- &gt;&gt;&gt;:t fmap @Maybe
-- fmap @Maybe :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b
-- &gt;&gt;&gt;:t fmap @_ @Int @Bool
-- fmap @_ @Int @Bool :: Functor _ =&gt; (Int -&gt; Bool) -&gt; _ Int -&gt; _ Bool

-- sugar for
-- p' :: forall a. a -&gt; a
p' :: a -&gt; a
p' = id

p :: forall a b c d. (Functor a, Functor b) =&gt; a c -&gt; b c -&gt; b c
p a b = b

-- &gt;&gt;&gt;:t p
-- p :: (Functor a, Functor b) =&gt; a c -&gt; b c -&gt; b c
-- &gt;&gt;&gt;:t p @_ @_
-- p @_ @_ :: (Functor _1, Functor _2) =&gt; _1 c -&gt; _2 c -&gt; _2 c

type family AlwaysUnit a where
  AlwaysUnit a = ()

p1 :: AlwaysUnit a -&gt; a
p1 = undefined
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-5"><a class="header" href="#chapter-5">Chapter 5</a></h1>
<!-- FOURMOLU_DISABLE -->
<pre><code class="language-haskell">{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE GADTs #-} 
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE FlexibleContexts #-}


module Chapter05() where 


import Control.Monad.Trans.Class (MonadTrans)
import Data.Kind(Constraint, Type)
</code></pre>
<h2 id="52-gadts"><a class="header" href="#52-gadts">5.2 GADTs</a></h2>
<pre><code class="language-haskell">data Expr a where
    LitInt :: Int -&gt; Expr Int
    LitBool :: Bool -&gt; Expr Bool
    Add :: Expr Int -&gt; Expr Int -&gt; Expr Int
    Not :: Expr Bool -&gt; Expr Bool
    If :: Expr Bool -&gt; Expr a -&gt; Expr a -&gt; Expr a

evalExpr :: Expr a -&gt; a
evalExpr (LitInt i) = i
evalExpr (LitBool b) = b
evalExpr (Add x y) = evalExpr x + evalExpr y
evalExpr (Not x) = not $ evalExpr x
evalExpr (If b x y ) =
    if evalExpr b
    then evalExpr x
    else evalExpr y

ex1 :: Expr Int
ex1 =  If (LitBool False ) ( LitInt 1) (Add ( LitInt 5) (LitInt 13))

-- &gt;&gt;&gt;evalExpr ex1
-- 18
</code></pre>
<h2 id="53-heterogeneous-lists"><a class="header" href="#53-heterogeneous-lists">5.3 Heterogeneous lists</a></h2>
<pre><code class="language-haskell">data HList (ts :: [Type]) where
    HNil :: HList '[]
    (:#) :: t -&gt; HList ts -&gt; HList (t ': ts)
infixr 5 :#

-- &gt;&gt;&gt;:t HNil
-- HNil :: HList '[]
-- &gt;&gt;&gt;:t True :# HNil
-- True :# HNil :: HList '[Bool]

hHead :: HList (t:ts :: [Type]) -&gt; t
hHead (x :# y) = x

p1 :: HList '[[Char], Bool, Integer, Bool]
p1 = &quot;Hey&quot; :# True :# 3 :# True :# HNil

-- &gt;&gt;&gt;hHead p1
-- &quot;Hey&quot;

hLength :: HList ts -&gt; Int
hLength HNil = 0
hLength (p :# ps) = 1 + hLength ps


-- &gt;&gt;&gt;hLength p1
-- 4

showBool :: HList (t1 : Bool : ts) -&gt; String
showBool (_ :# b :# _) = show b

instance Eq (HList '[]) where
    HNil == HNil = True

instance (Eq t, Eq (HList ts)) =&gt; Eq (HList (t ': ts)) where
    (a :# as) == (b :# bs) = a == b &amp;&amp; as == bs

-- 5.3-i
instance Ord (HList '[]) where
    HNil &lt;= HNil = True

instance (Ord t, Ord (HList ts)) =&gt; Ord (HList (t ': ts)) where
    (a :# as) &lt;= (b :# bs) = a &lt; b || a == b &amp;&amp; as &lt;= bs

p2 :: HList '[[Char], Bool, Integer, Bool]
p2 = &quot;Hou&quot; :# False :# 3 :# True :# HNil


-- &gt;&gt;&gt;p1 &lt;= p2
-- True
</code></pre>
<h2 id="53-ii"><a class="header" href="#53-ii">5.3-ii</a></h2>
<pre><code class="language-haskell">newtype SepHList (ts :: [Type])= SepHList (HList ts)

instance Show (SepHList '[]) where
    show (SepHList HNil) = &quot;&quot;

instance (Show t, Show (SepHList ts)) =&gt; Show (SepHList (t:ts)) where
    show (SepHList as) =
        case as of
            a :# HNil -&gt; show a 
            a :# as -&gt; show a &lt;&gt; &quot;, &quot; &lt;&gt; show (SepHList as)

instance Show (HList '[]) where
    show HNil = &quot;&quot;

instance (Show t, Show (HList ts), Show (SepHList ts)) =&gt; Show (HList (t ': ts)) where
    show as = &quot;[ &quot; &lt;&gt; show (SepHList as) &lt;&gt; &quot; ]&quot;

-- &gt;&gt;&gt;p2
-- [ &quot;Hou&quot;, False, 3, True ]

type family AllEq (ts :: [Type]) :: Constraint where
    AllEq '[] = ()
    AllEq (t ': ts) = (Eq t, AllEq ts)

-- &gt;&gt;&gt;:kind! AllEq '[Int, Bool]
-- AllEq '[Int, Bool] :: Constraint
-- = (Eq Int, (Eq Bool, () :: Constraint))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="53-heterogeneous-lists-1"><a class="header" href="#53-heterogeneous-lists-1">5.3 Heterogeneous lists</a></h2>
<!-- FOURMOLU_DISABLE -->
<pre><code class="language-haskell">{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE UndecidableInstances #-}

module Chapter05_1 () where

import Data.Kind (Constraint, Type)

data HList (ts :: [Type]) where
  HNil :: HList '[]
  (:#) :: t -&gt; HList ts -&gt; HList (t ': ts)
infixr 5 :#

type family All (c :: Type -&gt; Constraint) (ts :: [Type]) :: Constraint where
  All c '[] = ()
  All c (t ': ts) = (c t, All c ts)

data HList' (ts :: [Type]) where
  HNil' :: HList' '[]
  (:#:) :: t -&gt; HList' ts -&gt; HList' (t ': ts)
infixr 5 :#:

instance (All Show ts) =&gt; Show (HList' ts) where
  show HNil' = &quot;&quot;
  show (a :#: HNil') = show a
  show (a :#: as) = show a &lt;&gt; &quot;, &quot; &lt;&gt; show as

f :: HList ts -&gt; HList' ts
f hs = g hs HNil'
 where
  g :: HList ps -&gt; HList' ps' -&gt; HList' ps
  g HNil HNil' = HNil'
  g (a :# as) _ = a :#: g as HNil'
  g HNil _ = HNil'

instance (All Show ts) =&gt; Show (HList ts) where
  show ps = &quot;[ &quot; &lt;&gt; (show . f) ps &lt;&gt; &quot;]&quot;

p2 :: HList '[[Char], Bool, Integer, Bool]
p2 = &quot;Hou&quot; :# False :# 3 :# True :# HNil

-- &gt;&gt;&gt;p2
-- [ &quot;Hou&quot;, False, 3, True]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-6"><a class="header" href="#chapter-6">Chapter 6</a></h1>
<!-- FOURMOLU_DISABLE -->
<pre><code class="language-haskell">{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE UndecidableInstances #-}

module Chapter06 () where

import Data.Void (absurd)
</code></pre>
<h2 id="62-ranks"><a class="header" href="#62-ranks">6.2 Ranks</a></h2>
<pre><code class="language-haskell">-- takes a function that accepts any possible a
applyToFive :: (forall a. a -&gt; a) -&gt; Int
applyToFive f = f 5

p :: Int -&gt; (forall a. (a -&gt; a))
p b = id

p1 :: (a -&gt; b) -&gt; (forall c. c -&gt; a) -&gt; b
p1 a b = (a . b) absurd

type A a = a

type B a r = (forall r. (a -&gt; r) -&gt; r)
</code></pre>
<h2 id="64-the-continuation-monad"><a class="header" href="#64-the-continuation-monad">6.4 The Continuation Monad</a></h2>
<pre><code class="language-haskell">from :: A a -&gt; B a r
from a b = b a

to :: B a r -&gt; A a
to b = b id
</code></pre>
<pre><code class="language-hs">(to . from) x =
    = to (from x)
    = (from x) id
    = (\b -&gt; b x) id
    = id x
    = x

(from . to) x =
    = from (to x)
    = from (x id)
    = \b -&gt; b (x id)
    = \b -&gt; b ((\s -&gt; s (a :: a)) id)
    = \b -&gt; b (a :: a)
</code></pre>
<pre><code class="language-haskell">newtype Cont a = Cont {unCont :: forall r. (a -&gt; r) -&gt; r}

instance Functor Cont where
  fmap f (Cont a) = Cont $ \x -&gt; a $ x . f

--   fmap f (Cont a) = Cont $ \x -&gt; a $ \y -&gt; x $ f y

instance Applicative Cont where
  pure a = Cont $ \x -&gt; x a
  (Cont a) &lt;*&gt; (Cont b) = Cont $ \x -&gt; a $ \y -&gt; b (x . y)

instance Monad Cont where
  return = pure
  (Cont a) &gt;&gt;= f = Cont $ \x -&gt; a (\y -&gt; unCont (f y) x)
</code></pre>
<pre><code class="language-hs">(Cont a) &lt;*&gt; (Cont b) = Cont $ \x -&gt; a $ \y -&gt; b $ \z -&gt; x (y z)
(Cont a) &lt;*&gt; (Cont b) = Cont $ \x -&gt; a $ \y -&gt; b $ \z -&gt; (x . y) z
\z -&gt; x (y z) =
    x . y
</code></pre>
<pre><code class="language-haskell">withVersionNumber :: (Double -&gt; r) -&gt; r
withVersionNumber f = f 1.0

withTimestamp :: (Int -&gt; r) -&gt; r
withTimestamp f = f 1532083362

withOS :: (String -&gt; r) -&gt; r
withOS f = f &quot;linux&quot;

releaseStringCont :: String
releaseStringCont = flip unCont id $ do
  version &lt;- Cont withVersionNumber
  date &lt;- Cont withTimestamp
  os &lt;- Cont withOS
  return $ os ++ &quot;-&quot; ++ show version ++ &quot;-&quot; ++ show date

newtype ContT r m a = ContT {unContT :: (a -&gt; m r) -&gt; m r}

instance (Functor m) =&gt; Functor (ContT r m) where
  fmap f (ContT a) = ContT $ \x -&gt; a $ x . f

instance (Functor m) =&gt; Applicative (ContT r m) where
  pure x = ContT $ \y -&gt; y x
  (ContT a) &lt;*&gt; (ContT b) = ContT $ \x -&gt; a $ \y -&gt; b (x . y)
</code></pre>
<p><a href="https://ro-che.info/articles/2019-06-07-why-use-contt">Why use ContT</a></p>
<pre><code class="language-haskell">instance (Functor m) =&gt; Monad (ContT r m) where
  return = pure
  (ContT a) &gt;&gt;= f = ContT $ \x -&gt; a (\y -&gt; unContT (f y) x)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# OPTIONS_GHC -Wno-unused-imports #-}

module Chapter13 () where

import Data.Data (Proxy)
import GHC.Generics (Generic (..))
</code></pre>
<h2 id="13-generics"><a class="header" href="#13-generics">13 Generics</a></h2>
<h3 id="131-generic-representations"><a class="header" href="#131-generic-representations">13.1 Generic Representations</a></h3>
<p>All data types have a canonical representation as sums of products.
They can be built from <code>Either</code>s of pairs <code>(,)</code>. E.g., for <code>Maybe</code>:</p>
<pre><code class="language-haskell">toCanonical :: Maybe a -&gt; Either () a
toCanonical Nothing = Left ()
toCanonical (Just a) = Right a

fromCanonical :: Either () a -&gt; Maybe a
fromCanonical (Left ()) = Nothing
fromCanonical (Right a) = Just a

-- &gt;&gt;&gt; :kind! Rep Bool
-- Rep Bool :: * -&gt; *
-- = M1
--     D
--     ('MetaData &quot;Bool&quot; &quot;GHC.Types&quot; &quot;ghc-prim&quot; 'False)
--     (M1 C ('MetaCons &quot;False&quot; 'PrefixI 'False) U1
--      :+: M1 C ('MetaCons &quot;True&quot; 'PrefixI 'False) U1)
</code></pre>
<h3 id="132-deriving-structural-polymorphism"><a class="header" href="#132-deriving-structural-polymorphism">13.2 Deriving Structural Polymorphism</a></h3>
<p>Generically derive structural polymorphism:</p>
<ol>
<li>Define a typeclass to act as a carrier .</li>
<li>Provide inductive instances of the class for the generic
constructors.</li>
<li>Finally, write a helper function to map between the Rep and the
desired type.</li>
</ol>
<h3 id="24-type-level-functions"><a class="header" href="#24-type-level-functions">2.4 Type-Level functions</a></h3>
<ul>
<li>Type families must be saturated
<ul>
<li>no currying</li>
</ul>
</li>
</ul>
<!-- INDENT 4 -->
<pre><code class="language-haskell">type family Map (x :: a -&gt; b) (i :: [a]) :: [b] where
  Map f '[] = '[]
  Map f (x ': xs) = f x ': Map f xs

type family Or (x :: Bool) (y :: Bool) :: Bool where
  Or 'True y = 'True
  Or 'False y = y

-- &gt;&gt;&gt;  :t undefined :: Proxy (Map (Or True) '[True, 'False, 'False])
-- The type family `Or' should have 2 arguments, but has been given 1
-- In an expression type signature:
--   Proxy (Map (Or True) '[True, 'False, 'False])
-- In the expression:
--     undefined :: Proxy (Map (Or True) '[True, 'False, 'False])
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-1"><a class="header" href="#chapter-1">Chapter 1</a></h1>
<pre><code class="language-haskell">module C_01_Handles (fileResource, getDataDir, greetingTxt) where

import Control.Exception (Exception (..))
import Control.Exception.Safe qualified as Ex
import Control.Monad.IO.Class (MonadIO (..))
import Control.Monad.Trans.Resource (ReleaseKey, ResourceT, allocate, runResourceT)
import Data.Functor ((&lt;&amp;&gt;))
import GHC.IO.Handle (Handle)
import GHC.IO.IOMode (IOMode (..))
import Relude (print, putStrLn, show)
import System.Directory qualified as Dir
import System.FilePath ((&lt;/&gt;))
import System.IO qualified as IO
import Prelude hiding (print, putStrLn, show)
</code></pre>
<h2 id="0-setup"><a class="header" href="#0-setup">0 Setup</a></h2>
<pre><code class="language-haskell">getDataDir :: IO FilePath
getDataDir = do
  dir &lt;- Dir.getXdgDirectory Dir.XdgData &quot;sockets-and-pipes&quot;
  Dir.createDirectoryIfMissing True dir
  return dir
</code></pre>
<h2 id="12-writing-to-a-file"><a class="header" href="#12-writing-to-a-file">1.2 Writing to a file</a></h2>
<pre><code class="language-haskell">greetingTxt :: IO.FilePath
greetingTxt = &quot;greeting.txt&quot;

writeGreetingFile :: IO ()
writeGreetingFile = do
  dir &lt;- getDataDir
  h &lt;- IO.openFile (dir &lt;/&gt; greetingTxt) WriteMode
  IO.putStrLn (&quot;handle: &quot; &lt;&gt; show h)
  IO.hPutStrLn h &quot;hello&quot;
  IO.hClose h
  IO.putStrLn dir
</code></pre>
<h2 id="14-monadio"><a class="header" href="#14-monadio">1.4 MonadIO</a></h2>
<pre><code class="language-haskell">helloWorld :: (MonadIO m) =&gt; m ()
helloWorld = liftIO (IO.putStrLn &quot;hello, world&quot;)
</code></pre>
<h2 id="15-exercises"><a class="header" href="#15-exercises">1.5 Exercises</a></h2>
<h3 id="ex-1"><a class="header" href="#ex-1">Ex 1</a></h3>
<pre><code class="language-haskell">writeGreetingSafe :: IO ()
writeGreetingSafe = runResourceT @IO do
  dir &lt;- liftIO getDataDir
  (_releaseKey, h) &lt;- fileResource (dir &lt;/&gt; greetingTxt) WriteMode
  liftIO (IO.hPutStrLn h &quot;hello&quot;)
  liftIO (IO.hPutStrLn h &quot;world&quot;)

fileResource :: FilePath -&gt; IOMode -&gt; ResourceT IO (ReleaseKey, Handle)
fileResource p m =
  allocate
    (IO.openFile p m)
    IO.hClose
</code></pre>
<h3 id="ex-2"><a class="header" href="#ex-2">Ex 2</a></h3>
<pre><code class="language-haskell">handlePrintTest :: IO ()
handlePrintTest = runResourceT do
  (_, p1) &lt;- fileResource &quot;hey&quot; WriteMode
  liftIO $ print p1
  liftIO $ IO.hShow p1 &gt;&gt;= print
</code></pre>
<h3 id="ex-3"><a class="header" href="#ex-3">Ex 3</a></h3>
<pre><code class="language-haskell">howManyHandles :: IO ()
howManyHandles = runResourceT @IO do
  hs &lt;- openManyHandles
  liftIO $ putStrLn (&quot;Opened &quot; &lt;&gt; show (length hs) &lt;&gt; &quot; handles&quot;)

openManyHandles :: ResourceT IO [Handle]
openManyHandles = do
  let openManyHandles_ xs =
        do
          x &lt;- fileResourceMaybe
          case x of
            Just x' -&gt; openManyHandles_ (x' : xs)
            Nothing -&gt; return xs
  openManyHandles_ []

fileResourceMaybe :: ResourceT IO (Maybe Handle)
fileResourceMaybe = do
  dir &lt;- liftIO getDataDir
  result &lt;- Ex.tryIO (fileResource (dir &lt;/&gt; &quot;b&quot;) WriteMode &lt;&amp;&gt; snd &lt;&amp;&gt; Just)
  case result of
    Right x -&gt; return x
    Left e -&gt; do
      liftIO $ print (displayException e)
      return Nothing

main :: IO ()
main = howManyHandles
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-2-1"><a class="header" href="#chapter-2-1">Chapter 2</a></h1>
<pre><code class="language-haskell">module C_02_Chunks (repeatUntil) where

import C_01_Handles (fileResource, getDataDir, greetingTxt)
import Control.Monad ()
import Control.Monad.IO.Class (MonadIO (..))
import Control.Monad.Trans.Resource (runResourceT)
import Data.Char (isDigit)
import Data.Text (Text)
import Data.Text qualified as T
import Data.Text.IO qualified as T
import GHC.IO.Handle.FD (stdout)
import GHC.IO.IOMode (IOMode (WriteMode))
import Relude (IOMode (ReadMode))
import System.FilePath ((&lt;/&gt;))
import System.IO qualified as IO
</code></pre>
<h2 id="21-packed-characters"><a class="header" href="#21-packed-characters">2.1 Packed characters</a></h2>
<pre><code class="language-haskell">helloText :: IO ()
helloText = T.hPutStrLn stdout (T.pack &quot;hello, world!&quot;)

helloTextFile :: IO ()
helloTextFile = runResourceT @IO do
  dir &lt;- liftIO getDataDir
  (_, h) &lt;- fileResource (dir &lt;/&gt; greetingTxt) WriteMode
  liftIO do
    T.hPutStrLn h (T.pack &quot;hello&quot;)
    T.hPutStrLn h (T.pack &quot;world&quot;)

-- &gt;&gt;&gt;helloTextFile
</code></pre>
<p>Text is strict. This crashes</p>
<pre><code class="language-haskell">p :: T.Text
p = T.take 10 (T.pack (cycle &quot;abc&quot;))
</code></pre>
<h2 id="22-reading-from-a-file-one-chunk-at-a-time"><a class="header" href="#22-reading-from-a-file-one-chunk-at-a-time">2.2 Reading from a file, one chunk at a time</a></h2>
<pre><code class="language-haskell">printFileContentsUpperCase :: IO ()
printFileContentsUpperCase = runResourceT @IO do
  dir &lt;- liftIO getDataDir
  (_, h) &lt;- fileResource (dir &lt;/&gt; greetingTxt) ReadMode
  liftIO $
    repeatUntilIO (T.hGetChunk h) T.null $
      \chunk -&gt; T.putStr (T.toUpper chunk)

printCapitalizedText :: IO.Handle -&gt; IO ()
printCapitalizedText h = continue
 where
  continue = do
    chunk &lt;- T.hGetChunk h
    unless
      (T.null chunk)
      ( do
          T.putStr (T.toUpper chunk)
          continue
      )

repeatUntilIO ::
  IO chunk -&gt;
  (chunk -&gt; Bool) -&gt;
  (chunk -&gt; IO x) -&gt;
  IO ()
repeatUntilIO getChunk isEnd f = continue
 where
  continue = do
    chunk &lt;- getChunk
    unless
      (isEnd chunk)
      ( do
          _ &lt;- f chunk
          continue
      )
</code></pre>
<h3 id="ex-4"><a class="header" href="#ex-4">Ex 4</a></h3>
<pre><code class="language-haskell">digitsOnly :: Text -&gt; Text
digitsOnly = T.filter isDigit

testDigitsOnly :: Text
testDigitsOnly = digitsOnly (T.pack &quot;ab c123 def4&quot;)
</code></pre>
<blockquote>
<blockquote>
<blockquote>
<p>testDigitsOnly
&quot;1234&quot;</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code class="language-haskell">capitalizeLast :: Text -&gt; Text
capitalizeLast t = T.init t &lt;&gt; T.toUpper (T.takeEnd 1 t)
</code></pre>
<blockquote>
<blockquote>
<blockquote>
<p>capitalizeLast &quot;,&quot;</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>capitalizeLast &quot;a&quot;</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code class="language-haskell">unParen :: Text -&gt; Maybe Text
unParen t
  | T.length t &lt; 2 = Nothing
  | pref == '(' &amp;&amp; suff == ')' = Just body
  | otherwise = Nothing
 where
  pref = T.head t
  suff = T.last t
  body = T.init (T.tail t)
</code></pre>
<blockquote>
<blockquote>
<blockquote>
<p>unParen &quot;&quot;
Nothing</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>unParen &quot;(a)&quot;
Just &quot;a&quot;</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code class="language-haskell">characterCount :: FilePath -&gt; IO Int
characterCount fp = runResourceT @IO do
  dir &lt;- liftIO getDataDir
  (_, h) &lt;- fileResource (dir &lt;/&gt; fp) ReadMode
  liftIO $ continue (T.hGetChunk h) T.null 0
 where
  continue :: IO Text -&gt; (Text -&gt; Bool) -&gt; Int -&gt; IO Int
  continue getChunk isEnd n = do
    chunk &lt;- getChunk
    if isEnd chunk
      then return n
      else continue getChunk isEnd (n + T.length chunk)
</code></pre>
<blockquote>
<blockquote>
<blockquote>
<p>characterCount &quot;greeting.txt&quot;
12</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="ex-6"><a class="header" href="#ex-6">Ex 6</a></h3>
<pre><code class="language-haskell">when :: (Monad m) =&gt; Bool -&gt; m () -&gt; m ()
when cond action = if cond then action else return ()

unless :: (Monad m) =&gt; Bool -&gt; m () -&gt; m ()
unless cond = when (not cond)
</code></pre>
<h3 id="ex-7"><a class="header" href="#ex-7">Ex 7</a></h3>
<pre><code class="language-haskell">repeatUntil :: (Monad m) =&gt; m chunk -&gt; (chunk -&gt; Bool) -&gt; (chunk -&gt; m x) -&gt; m ()
repeatUntil getChunk isEnd f = continue
 where
  continue = do
    chunk &lt;- getChunk
    unless
      (isEnd chunk)
      ( do
          _ &lt;- f chunk
          continue
      )
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-3-1"><a class="header" href="#chapter-3-1">Chapter 3</a></h1>
<pre><code class="language-haskell">module C_03_Bytes (binaryFileResource) where

import Data.Word (Word8)

import C_01_Handles (getDataDir, greetingTxt)
import C_02_Chunks (repeatUntil)
import Control.Monad.IO.Class (MonadIO (..))
import Control.Monad.Trans.Resource (ReleaseKey, ResourceT, allocate, runResourceT)
import Data.ByteString as BS (ByteString, hGetSome, hPut, hPutStr, map, null, pack)
import Data.String (fromString)
import Data.Text (Text)
import Data.Text qualified as T
import Data.Text.Encoding qualified as T
import Data.Text.IO qualified as T
import GHC.IO.Handle.FD (stdout)
import Relude (Handle, IOMode (..), UnicodeException)
import System.FilePath ((&lt;/&gt;))
import System.IO qualified as IO
</code></pre>
<h2 id="31-packed-octets"><a class="header" href="#31-packed-octets">3.1 Packed octets</a></h2>
<pre><code class="language-haskell">exampleBytes :: [Word8]
exampleBytes = [104, 101, 108, 111] :: [Word8]
</code></pre>
<h2 id="32-copying-a-file"><a class="header" href="#32-copying-a-file">3.2 Copying a file</a></h2>
<pre><code class="language-haskell">greeting2Txt :: FilePath
greeting2Txt = &quot;greeting2.txt&quot;

copyGreetingFile :: IO ()
copyGreetingFile = runResourceT @IO do
  dir &lt;- liftIO getDataDir
  (_, h1) &lt;- binaryFileResource (dir &lt;/&gt; greetingTxt) ReadMode
  (_, h2) &lt;- binaryFileResource (dir &lt;/&gt; greeting2Txt) WriteMode
  liftIO $ repeatUntil (BS.hGetSome h1 1024) BS.null (BS.hPutStr h2)

binaryFileResource :: FilePath -&gt; IOMode -&gt; ResourceT IO (ReleaseKey, Handle)
binaryFileResource path mode = allocate (IO.openBinaryFile path mode) IO.hClose
</code></pre>
<h2 id="35-avoiding-system-defaults"><a class="header" href="#35-avoiding-system-defaults">3.5 Avoiding system defaults</a></h2>
<pre><code class="language-haskell">helloHandle :: IO ()
helloHandle = IO.hPutStrLn IO.stdout &quot;Hello, world!&quot;

helloByteString :: IO ()
helloByteString = do
  IO.hSetBinaryMode stdout True
  BS.hPut stdout (BS.pack helloBytes)

helloBytes :: [Word8]
helloBytes =
  [ -- hello
    104
  , 101
  , 108
  , 111
  , -- ,
    32
  , -- world
    119
  , 111
  , 114
  , 108
  , 100
  , 33
  , -- /n
    10
  ]

-- &gt;&gt;&gt;helloByteString

helloUtf8 :: IO ()
helloUtf8 = do
  IO.hSetBinaryMode stdout True
  BS.hPutStr stdout (T.encodeUtf8 (T.pack &quot;hello, world!\n&quot;))

-- &gt;&gt;&gt;helloUtf8
</code></pre>
<h2 id="36-exercises"><a class="header" href="#36-exercises">3.6 Exercises</a></h2>
<h3 id="ex-8"><a class="header" href="#ex-8">Ex 8</a></h3>
<pre><code class="language-haskell">greet :: BS.ByteString -&gt; IO ()
greet nameBS = case T.decodeUtf8' nameBS of
  Left _ -&gt; putStrLn &quot;Invalid byte string&quot;
  Right nameText -&gt; T.putStrLn (T.pack &quot;Hello, &quot; &lt;&gt; nameText)

p1 :: Either UnicodeException Text
p1 = T.decodeUtf8' (fromString &quot;♫&quot;)

-- &gt;&gt;&gt;p1
-- Right &quot;k&quot;
</code></pre>
<h3 id="ex-9"><a class="header" href="#ex-9">Ex 9</a></h3>
<pre><code class="language-haskell">asciiUpper :: BS.ByteString -&gt; BS.ByteString
asciiUpper = BS.map (\x -&gt; if 97 &lt;= x &amp;&amp; x &lt;= 122 then 65 + x - 97 else x)

p2 :: ByteString
p2 = asciiUpper (fromString &quot;Hello!&quot;)

-- &gt;&gt;&gt; p2
-- &quot;HELLO!&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-4-1"><a class="header" href="#chapter-4-1">Chapter 4</a></h1>
<pre><code class="language-haskell">module C_04_Sockets (openAndConnect, resolve) where

import C_02_Chunks (repeatUntil)
import Control.Monad.IO.Class (MonadIO (liftIO))
import Control.Monad.Trans.Resource (
  ReleaseKey,
  ResourceT,
  allocate,
  runResourceT,
 )
import Data.ByteString as BS (null, putStr)
import Data.Foldable (traverse_)
import Data.Text qualified as T
import Data.Text.Encoding qualified as T
import Network.Simple.TCP (Socket)
import Network.Socket (Family (..))
import Network.Socket qualified as S
import Network.Socket.ByteString qualified as S
</code></pre>
<h2 id="41-open-up-and-connect"><a class="header" href="#41-open-up-and-connect">4.1 Open up and connect</a></h2>
<pre><code class="language-haskell">makeFriend :: S.SockAddr -&gt; IO ()
makeFriend address = do
  s &lt;- S.socket S.AF_INET S.Stream S.defaultProtocol
  S.connect s address
  S.sendAll s $
    T.encodeUtf8 $
      T.pack &quot;Hello, will you be my friend?&quot;
  repeatUntil (S.recv s 1024) BS.null BS.putStr
</code></pre>
<h2 id="42-extra-details"><a class="header" href="#42-extra-details">4.2 Extra details</a></h2>
<pre><code class="language-haskell">sec :: Int -&gt; Int
sec t = t * 1000

sec1 :: Int
sec1 = sec 1

makeFriendSafely :: S.SockAddr -&gt; IO ()
makeFriendSafely address = runResourceT @IO do
  (_, s) &lt;-
    allocate
      (S.socket S.AF_INET S.Stream S.defaultProtocol)
      S.close
  liftIO do
    S.setSocketOption s S.UserTimeout sec1
    S.connect s address
    S.sendAll s $
      T.encodeUtf8 $
        T.pack &quot;Hello, will you be my friend?&quot;
    repeatUntil (S.recv s 1024) BS.null BS.putStr
    S.gracefulClose s sec1
</code></pre>
<h2 id="44-address-information"><a class="header" href="#44-address-information">4.4 Address information</a></h2>
<pre><code class="language-haskell">myHints :: S.AddrInfo
myHints = S.defaultHints{S.addrFamily = AF_INET6}

s1 :: IO ()
s1 = traverse_ print =&lt;&lt; S.getAddrInfo Nothing (Just &quot;www.haskell.org&quot;) (Just &quot;http&quot;)

s2 :: IO ()
s2 = traverse_ print =&lt;&lt; S.getAddrInfo (Just S.defaultHints{S.addrSocketType = S.Stream}) (Just &quot;www.haskell.org&quot;) (Just &quot;http&quot;)

findHaskellWebsite :: IO S.AddrInfo
findHaskellWebsite = do
  addrInfos &lt;- S.getAddrInfo (Just S.defaultHints{S.addrSocketType = S.Stream}) (Just &quot;www.haskell.org&quot;) (Just &quot;http&quot;)
  case addrInfos of
    [] -&gt; fail &quot;getAddrInfo returned []&quot;
    x : _ -&gt; return x

makeFriendAddrInfo :: S.AddrInfo -&gt; IO ()
makeFriendAddrInfo addressInfo = runResourceT @IO do
  (_, s) &lt;- allocate (S.openSocket addressInfo) S.close
  liftIO do
    S.setSocketOption s S.UserTimeout sec1
    S.connect s (S.addrAddress addressInfo)
    S.sendAll s $
      T.encodeUtf8 $
        T.pack &quot;Hello, will you be my friend?&quot;
    repeatUntil (S.recv s 1024) BS.null BS.putStr
    S.gracefulClose s sec1

mkFriend :: IO ()
mkFriend = makeFriendSafely (S.SockAddrInet 80 (S.tupleToHostAddress (147, 75, 54, 133)))

-- &gt;&gt;&gt;mkFriend
</code></pre>
<h2 id="45-exercises"><a class="header" href="#45-exercises">4.5 Exercises</a></h2>
<h3 id="ex-10"><a class="header" href="#ex-10">Ex 10</a></h3>
<pre><code class="language-haskell">openAndConnect :: S.AddrInfo -&gt; ResourceT IO (ReleaseKey, Socket)
openAndConnect addressInfo = do
  (r, s) &lt;- allocate (S.openSocket addressInfo) S.close
  liftIO do
    S.setSocketOption s S.UserTimeout 1000
    S.connect s (S.addrAddress addressInfo)
  return (r, s)
</code></pre>
<h3 id="ex-11"><a class="header" href="#ex-11">Ex 11</a></h3>
<pre><code class="language-haskell">findGopherWebsite :: IO S.AddrInfo
findGopherWebsite = do
  addrInfos &lt;- S.getAddrInfo (Just S.defaultHints{S.addrSocketType = S.Stream}) (Just &quot;gopher.floodgap.com&quot;) (Just &quot;gopher&quot;)
  case addrInfos of
    [] -&gt; fail &quot;getAddrInfo returned []&quot;
    x : _ -&gt; return x
</code></pre>
<h3 id="ex-12"><a class="header" href="#ex-12">Ex 12</a></h3>
<pre><code class="language-haskell">resolve :: S.ServiceName -&gt; S.HostName -&gt; IO S.AddrInfo
resolve sname hname = do
  addrInfos &lt;- S.getAddrInfo (Just S.defaultHints{S.addrSocketType = S.Stream}) (Just hname) (Just sname)
  case addrInfos of
    [] -&gt; fail &quot;getAddrInfo returned []&quot;
    x : _ -&gt; return x
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-5-1"><a class="header" href="#chapter-5-1">Chapter 5</a></h1>
<pre><code class="language-haskell">module C_05_HTTP (crlf, helloRequestString, helloResponseString) where

import ASCII (ASCII, fromCharList)
import ASCII qualified as A
import ASCII.Char qualified as A
import ASCII.Superset (FromString)
import C_04_Sockets (openAndConnect, resolve)
import Control.Monad.IO.Class (MonadIO (..))
import Control.Monad.Trans.Resource (runResourceT)
import Data.ByteString qualified as BS
import Network.Simple.TCP (HostPreference (..))
import Network.Simple.TCP qualified as Net
import Relude (putBSLn)
</code></pre>
<h2 id="53-ascii-strings"><a class="header" href="#53-ascii-strings">5.3 ASCII strings</a></h2>
<pre><code class="language-haskell">line :: BS.ByteString -&gt; BS.ByteString
line x = x &lt;&gt; A.lift crlf

crlf :: (FromString superset) =&gt; ASCII superset
crlf = fromCharList [A.CarriageReturn, A.LineFeed]

text :: [BS.ByteString] -&gt; BS.ByteString
text = foldMap line

helloRequestString :: BS.ByteString
helloRequestString =
  text
    [ [A.string|GET /hello.txt HTTP/1.1|]
    , [A.string|Host: www.example.com|]
    , [A.string|Accept-Language: en, mi|]
    , [A.string||]
    ]
</code></pre>
<h2 id="54-http-responses"><a class="header" href="#54-http-responses">5.4 HTTP responses</a></h2>
<pre><code class="language-haskell">helloResponseString :: BS.ByteString
helloResponseString =
  text
    [ [A.string|HTTP/1.1 200 OK|]
    , [A.string|Content-Type: text/plain; charset=us-ascii|]
    , [A.string|Content-Length: 6|]
    , [A.string||]
    ]
    &lt;&gt; [A.string|Hello|]
</code></pre>
<h2 id="55-serving-others"><a class="header" href="#55-serving-others">5.5 Serving others</a></h2>
<pre><code class="language-haskell">p :: (MonadIO m) =&gt; HostPreference -&gt; Net.ServiceName -&gt; ((Net.Socket, Net.SockAddr) -&gt; IO ()) -&gt; m a
p = Net.serve

ourFirstServer :: IO a
ourFirstServer = Net.serve @IO HostAny &quot;8000&quot; \(s, a) -&gt; do
  putStrLn (&quot;New connection from &quot; &lt;&gt; show a)
  Net.send s helloResponseString
</code></pre>
<h2 id="56-exercises"><a class="header" href="#56-exercises">5.6 Exercises</a></h2>
<h3 id="ex-13"><a class="header" href="#ex-13">Ex 13</a></h3>
<pre><code class="language-haskell">repeatUntilNothing :: (Monad m) =&gt; m (Maybe chunk) -&gt; (chunk -&gt; m x) -&gt; m ()
repeatUntilNothing getChunkMaybe f = continue
 where
  continue = do getChunkMaybe &gt;&gt;= maybe (return ()) (\x -&gt; f x &gt;&gt; continue)
</code></pre>
<h3 id="ex-14"><a class="header" href="#ex-14">Ex 14</a></h3>
<pre><code class="language-haskell">requestText :: BS.ByteString
requestText =
  text
    [ [A.string|GET / HTTP/1.1|]
    , [A.string|Host: haskell.org|]
    , [A.string|Connection: close|]
    ]

requestHaskellOrg :: IO ()
requestHaskellOrg = runResourceT @IO do
  addrInfo &lt;- liftIO $ resolve &quot;https&quot; &quot;haskell.org&quot;
  (_, s) &lt;- openAndConnect addrInfo
  Net.send s requestText
  repeatUntilNothing (Net.recv s 1024) (liftIO . putBSLn)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-haskell">module C_06_HTTP_types (
  FieldName (..),
  FieldValue (..),
  HeaderField (..),
  HttpVersion (..),
  MessageBody (..),
  Method (..),
  ReasonPhrase (..),
  Request (..),
  RequestLine (..),
  RequestTarget (..),
  Response (..),
  StatusCode (..),
  StatusLine (..),
  helloRequest,
  helloResponse,
) where

import ASCII qualified as A
import ASCII.Decimal qualified as A (Digit (..))
import Data.ByteString qualified as BS
import Data.ByteString.Lazy (toChunks)
import Data.ByteString.Lazy qualified as LBS

data Request = Request RequestLine [HeaderField] (Maybe MessageBody)
data Response = Response StatusLine [HeaderField] (Maybe MessageBody)
data RequestLine = RequestLine Method RequestTarget HttpVersion
data StatusLine = StatusLine HttpVersion StatusCode ReasonPhrase
data StatusCode = StatusCode A.Digit A.Digit A.Digit
data HeaderField = HeaderField FieldName FieldValue
data HttpVersion = HttpVersion A.Digit A.Digit
newtype Method = Method BS.ByteString
newtype RequestTarget = RequestTarget BS.ByteString
newtype ReasonPhrase = ReasonPhrase BS.ByteString
newtype FieldName = FieldName BS.ByteString
newtype FieldValue = FieldValue BS.ByteString
newtype MessageBody = MessageBody LBS.ByteString
</code></pre>
<p>6.7 Exercises</p>
<p>Ex 16</p>
<pre><code class="language-haskell">helloRequest :: Request
helloRequest = Request start [host, lang] Nothing
 where
  start = RequestLine (Method [A.string|GET|]) (RequestTarget [A.string|/hello.txt|]) (HttpVersion A.Digit1 A.Digit1)
  host = HeaderField (FieldName [A.string|Host|]) (FieldValue [A.string|www.example.com|])
  lang = HeaderField (FieldName [A.string|Accept-Language|]) (FieldValue [A.string|en, mi|])

helloResponse :: Response
helloResponse = Response start [host, lang] (Just $ MessageBody [A.string|Hello|])
 where
  start = StatusLine (HttpVersion A.Digit1 A.Digit1) (StatusCode A.Digit2 A.Digit0 A.Digit0) (ReasonPhrase [A.string|OK|])
  host = HeaderField (FieldName [A.string|Content-Type|]) (FieldValue [A.string|text/plain; charset=us-ascii|])
  lang = HeaderField (FieldName [A.string|Content-Length|]) (FieldValue [A.string|6|])
</code></pre>
<p>Ex 17</p>
<pre><code class="language-haskell">inf :: LBS.ByteString
inf = [A.string|abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefgh|]

p :: [Int]
p = BS.length &lt;$&gt; toChunks inf

-- &gt;&gt;&gt;p
-- [32,64,128,256,512,384]

-- &gt;&gt;&gt;LBS.take 10 inf
-- &quot;abcdefghij&quot;

httpVersion :: HttpVersion
httpVersion = HttpVersion A.Digit1 A.Digit1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-7"><a class="header" href="#chapter-7">Chapter 7</a></h1>
<pre><code class="language-haskell">module C_07_Encoding (
  encodeLineEnd,
  encodeStatusLine,
  encodeResponse,
  encodeRequestLine,
  repeatedlyEncode,
  encodeHeaderField,
  encodeMessageBody,
  optionallyEncode,
  encodeRequest,
) where

import ASCII (DigitStringSuperset (fromDigitList), fromCharList)
import ASCII qualified as A
import ASCII.Char qualified as AC
import C_01_Handles (getDataDir)
import C_05_HTTP (crlf, helloRequestString, helloResponseString)
import C_06_HTTP_types (
  FieldName (FieldName),
  FieldValue (FieldValue),
  HeaderField (HeaderField),
  HttpVersion (..),
  MessageBody (MessageBody),
  Method (Method),
  ReasonPhrase (ReasonPhrase),
  Request (Request),
  RequestLine (RequestLine),
  RequestTarget (RequestTarget),
  Response (Response),
  StatusCode (StatusCode),
  StatusLine (StatusLine),
  helloRequest,
  helloResponse,
 )
import Data.ByteString qualified as BS
import Data.ByteString.Builder qualified as BSB
import Data.Foldable (Foldable (..))
import Data.Text qualified as T
import Data.Text.IO qualified as T
import Data.Text.Lazy qualified as LT
import Data.Text.Lazy.Builder qualified as TB
import Data.Time qualified as Time
import System.FilePath ((&lt;/&gt;))
</code></pre>
<h2 id="71-string-builders"><a class="header" href="#71-string-builders">7.1 String builders</a></h2>
<pre><code class="language-haskell">sayHello :: T.Text -&gt; T.Text
sayHello name = T.pack &quot;Hello, &quot; &lt;&gt; name &lt;&gt; T.pack &quot;!&quot;

-- &gt;&gt;&gt;sayHello $ T.pack &quot;Tim&quot;
-- &quot;Hello, Tim!&quot;

sayHelloWithBuilder :: T.Text -&gt; T.Text
sayHelloWithBuilder name =
  LT.toStrict $
    TB.toLazyText $
      TB.fromString &quot;Hello&quot; &lt;&gt; TB.fromText name &lt;&gt; TB.fromString &quot;!&quot;
</code></pre>
<h2 id="72-measuring-time"><a class="header" href="#72-measuring-time">7.2 Measuring time</a></h2>
<pre><code class="language-haskell">time :: IO () -&gt; IO ()
time action = do
  a &lt;- Time.getCurrentTime
  action
  b &lt;- Time.getCurrentTime
  print (Time.diffUTCTime b a)

concatWithStrict :: Int -&gt; T.Text
concatWithStrict n = fold $ replicate n $ T.pack &quot;a&quot;

concatWithBuilder :: Int -&gt; T.Text
concatWithBuilder n = LT.toStrict $ TB.toLazyText $ fold $ replicate n $ TB.fromString &quot;a&quot;

concatSpeedTest :: Int -&gt; IO ()
concatSpeedTest n = do
  dir &lt;- getDataDir
  time $ T.writeFile (dir &lt;/&gt; &quot;builder.txt&quot;) (concatWithBuilder n)
  time $ T.writeFile (dir &lt;/&gt; &quot;strict.txt&quot;) (concatWithStrict n)

-- &gt;&gt;&gt;concatSpeedTest 10000
</code></pre>
<h2 id="73-request-and-response"><a class="header" href="#73-request-and-response">7.3 Request and response</a></h2>
<pre><code class="language-haskell">encodeRequest :: Request -&gt; BSB.Builder
encodeRequest (Request requestLine headerFields bodyMaybe) =
  encodeRequestLine requestLine
    &lt;&gt; repeatedlyEncode (\x -&gt; encodeHeaderField x &lt;&gt; encodeLineEnd) headerFields
    &lt;&gt; encodeLineEnd
    &lt;&gt; optionallyEncode encodeMessageBody bodyMaybe

encodeResponse :: Response -&gt; BSB.Builder
encodeResponse (Response statusLine headerFields bodyMaybe) =
  encodeStatusLine statusLine
    &lt;&gt; repeatedlyEncode (\x -&gt; encodeHeaderField x &lt;&gt; encodeLineEnd) headerFields
    &lt;&gt; encodeLineEnd
    &lt;&gt; optionallyEncode encodeMessageBody bodyMaybe

encodeLineEnd :: BSB.Builder
encodeLineEnd = A.lift crlf
</code></pre>
<h2 id="74-higher-order-encodings"><a class="header" href="#74-higher-order-encodings">7.4 Higher-order encodings</a></h2>
<pre><code class="language-haskell">optionallyEncode :: (a -&gt; BSB.Builder) -&gt; Maybe a -&gt; BSB.Builder
optionallyEncode = foldMap

repeatedlyEncode :: (a -&gt; BSB.Builder) -&gt; [a] -&gt; BSB.Builder
repeatedlyEncode = foldMap
</code></pre>
<h2 id="75-the-start-line"><a class="header" href="#75-the-start-line">7.5 The start line</a></h2>
<pre><code class="language-haskell">encodeSpace :: BSB.Builder
encodeSpace = A.lift $ fromCharList [AC.Space]

encodeRequestLine :: RequestLine -&gt; BSB.Builder
encodeRequestLine (RequestLine method requestTarget httpVersion) =
  encodeMethod method
    &lt;&gt; encodeSpace
    &lt;&gt; encodeRequestTarget requestTarget
    &lt;&gt; encodeSpace
    &lt;&gt; encodeHttpVersion httpVersion
    &lt;&gt; encodeLineEnd

encodeMethod :: Method -&gt; BSB.Builder
encodeMethod (Method m) = BSB.byteString m

encodeRequestTarget :: RequestTarget -&gt; BSB.Builder
encodeRequestTarget (RequestTarget rt) = BSB.byteString rt

encodeStatusLine :: StatusLine -&gt; BSB.Builder
encodeStatusLine (StatusLine httpVersion statusCode reasonPhrase) =
  encodeHttpVersion httpVersion
    &lt;&gt; encodeSpace
    &lt;&gt; encodeStatusCode statusCode
    &lt;&gt; encodeSpace
    &lt;&gt; encodeReasonPhrase reasonPhrase
    &lt;&gt; encodeLineEnd

encodeStatusCode :: StatusCode -&gt; BSB.Builder
encodeStatusCode (StatusCode c1 c2 c3) = A.lift $ fromDigitList [c1, c2, c3]

encodeReasonPhrase :: ReasonPhrase -&gt; BSB.Builder
encodeReasonPhrase (ReasonPhrase s) = BSB.byteString s

encodeHttpVersion :: HttpVersion -&gt; BSB.Builder
encodeHttpVersion (HttpVersion v1 v2) =
  BSB.byteString [A.string|HTTP/|]
    &lt;&gt; A.digitString v1
    &lt;&gt; A.lift (fromCharList [AC.FullStop])
    &lt;&gt; A.digitString v2
</code></pre>
<h2 id="76-exercises"><a class="header" href="#76-exercises">7.6 Exercises</a></h2>
<pre><code class="language-haskell">encodeHeaderField :: HeaderField -&gt; BSB.Builder
encodeHeaderField (HeaderField (FieldName x) (FieldValue y)) =
  BSB.byteString x
    &lt;&gt; A.lift (fromCharList [AC.Colon])
    &lt;&gt; encodeSpace
    &lt;&gt; BSB.byteString y

encodeMessageBody :: MessageBody -&gt; BSB.Builder
encodeMessageBody (MessageBody s) = BSB.lazyByteString s

req :: BSB.Builder
req = encodeRequest helloRequest

-- &gt;&gt;&gt;req
-- &quot;GET /hello.txt HTTP/1.1\r\nHost: www.example.com\r\nAccept-Language: en, mi\r\n\r\n&quot;

resp :: BSB.Builder
resp = encodeResponse helloResponse

-- &gt;&gt;&gt;resp
-- &quot;HTTP/1.1 200 OK\r\nHost: www.example.com\r\nAccept-Language: en, mi\r\n\r\nHello&quot;

requestEqual :: Bool
requestEqual = BS.toStrict (BSB.toLazyByteString req) == helloRequestString

-- &gt;&gt;&gt;reqEqual
-- True
-- &gt;&gt;&gt;helloRequestString
-- &quot;GET /hello.txt HTTP/1.1\r\nHost: www.example.com\r\nAccept-Language: en, mi\r\n\r\n&quot;
-- &gt;&gt;&gt;req
-- &quot;GET /hello.txt HTTP/1.1\r\nHost: www.example.com\r\nAccept-Language: en, mi\r\n\r\n&quot;

responseEqual :: Bool
responseEqual = BS.toStrict (BSB.toLazyByteString resp) == helloResponseString

-- &gt;&gt;&gt;responseEqual
-- True
-- &gt;&gt;&gt;helloResponseString
-- &quot;HTTP/1.1 200 OK\r\nContent-Type: text/plain; charset=us-ascii\r\nContent-Length: 6\r\n\r\nHello&quot;
-- &gt;&gt;&gt;resp
-- &quot;HTTP/1.1 200 OK\r\nContent-Type: text/plain; charset=us-ascii\r\nContent-Length: 6\r\n\r\nHello&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-8"><a class="header" href="#chapter-8">Chapter 8</a></h1>
<pre><code class="language-haskell">module C_08_Responding (
  contentLength,
  contentType,
  status,
  ok,
  bodyLengthValue,
  contentLengthField,
  sendResponse,
) where

import ASCII qualified as A
import ASCII.Decimal qualified as A
import C_06_HTTP_types (
  FieldName (FieldName),
  FieldValue (FieldValue),
  HeaderField (HeaderField),
  HttpVersion (HttpVersion),
  MessageBody (MessageBody),
  ReasonPhrase (..),
  Response (Response),
  StatusCode (..),
  StatusLine (..),
 )
import C_07_Encoding (encodeLineEnd, encodeResponse, encodeStatusLine)
import Data.ByteString.Builder qualified as BSB
import Data.ByteString.Lazy qualified as LBS
import Data.Word (Word8)
import GHC.Natural (Natural)
import Network.Simple.TCP (HostPreference (HostAny), Socket, serve)
import Network.Simple.TCP qualified as Net
</code></pre>
<h2 id="81-a-measure-of-success"><a class="header" href="#81-a-measure-of-success">8.1 A measure of success</a></h2>
<pre><code class="language-haskell">countHelloAscii :: Natural -&gt; LBS.ByteString
countHelloAscii count =
  BSB.toLazyByteString $
    [A.string|Hello!|]
      &lt;&gt; encodeLineEnd
      &lt;&gt; [A.string|This page has |]
      &lt;&gt; case count of
        0 -&gt; [A.string|never been viewed.|]
        1 -&gt; [A.string|been viewed 1 time.|]
        _ -&gt;
          [A.string|been viewed |]
            &lt;&gt; A.showIntegralDecimal count
            &lt;&gt; [A.string| times.|]

data Status = Status StatusCode ReasonPhrase
</code></pre>
<h2 id="82-response-building-utilities"><a class="header" href="#82-response-building-utilities">8.2 Response-building utilities</a></h2>
<pre><code class="language-haskell">ok :: Status
ok =
  Status
    (StatusCode A.Digit2 A.Digit0 A.Digit0)
    (ReasonPhrase [A.string|OK|])

status :: Status -&gt; StatusLine
status (Status statusCode reasonPhrase) = StatusLine http_1_1 statusCode reasonPhrase

http_1_1 :: HttpVersion
http_1_1 = HttpVersion A.Digit1 A.Digit1

encOk :: LBS.ByteString
encOk = BSB.toLazyByteString (encodeStatusLine (status ok))

-- &gt;&gt;&gt;encOk
-- &quot;HTTP/1.1 200 OK\r\n&quot;

contentType :: FieldName
contentType = FieldName [A.string|Content-Type|]

contentLength :: FieldName
contentLength = FieldName [A.string|Content-Length|]

contentLengthField :: MessageBody -&gt; HeaderField
contentLengthField body = HeaderField contentLength (bodyLengthValue body)

plainAscii :: FieldValue
plainAscii = FieldValue [A.string|text/plain; charset=us-ascii|]

asciiOk :: LBS.ByteString -&gt; Response
asciiOk str = Response (status ok) [typ, len] (Just body)
 where
  typ = HeaderField contentType plainAscii
  len = HeaderField contentLength (bodyLengthValue body)
  body = MessageBody str

-- this is for Content-Length
bodyLengthValue :: MessageBody -&gt; FieldValue
bodyLengthValue (MessageBody x) = FieldValue (A.showIntegralDecimal (LBS.length x))
</code></pre>
<h2 id="83-integers"><a class="header" href="#83-integers">8.3 Integers</a></h2>
<h2 id="84-response-transmission"><a class="header" href="#84-response-transmission">8.4 Response transmission</a></h2>
<pre><code class="language-haskell">sendResponse :: Socket -&gt; Response -&gt; IO ()
sendResponse s r =
  Net.sendLazy s $
    BSB.toLazyByteString (encodeResponse r)

stuckCountingServer :: IO a
stuckCountingServer = serve @IO HostAny &quot;8000&quot; \(s, _) -&gt; do
  let count = 0
  sendResponse s (asciiOk (countHelloAscii count))
</code></pre>
<h2 id="85-exercises"><a class="header" href="#85-exercises">8.5 Exercises</a></h2>
<h3 id="ex-21"><a class="header" href="#ex-21">Ex 21</a></h3>
<pre><code class="language-haskell">-- curl http://localhost:8000 --dump-header -
</code></pre>
<h3 id="ex-22"><a class="header" href="#ex-22">Ex 22</a></h3>
<pre><code class="language-haskell">mid :: Word8 -&gt; Word8 -&gt; Word8
mid x y = fromInteger (div (toInteger x + toInteger y) 2)

-- &gt;&gt;&gt;mid 3 5
-- 4
-- &gt;&gt;&gt;mid 220 250
-- 235
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-9"><a class="header" href="#chapter-9">Chapter 9</a></h1>
<pre><code class="language-haskell">module C_09_Content_types (textOk, countHelloText, countHelloHtml, htmlOk) where

import ASCII qualified as A
import C_06_HTTP_types (
  FieldValue (FieldValue),
  HeaderField (HeaderField),
  MessageBody (MessageBody),
  Request,
  Response (..),
 )
import C_07_Encoding (encodeRequest, encodeResponse)
import C_08_Responding (
  contentLengthField,
  contentType,
  ok,
  sendResponse,
  status,
 )
import Data.Aeson (KeyValue ((.=)), ToJSON (toJSON))
import Data.Aeson qualified as J
import Data.Aeson.Key qualified as J.Key
import Data.Aeson.KeyMap qualified as J.KeyMap
import Data.ByteString qualified as BS
import Data.ByteString.Builder qualified as BSB
import Data.ByteString.Lazy qualified as LBS
import Data.Int (Int64)
import Data.String (IsString (..))
import Data.Text qualified as T
import Data.Text.Lazy qualified as LT
import Data.Text.Lazy.Builder qualified as TL
import Data.Text.Lazy.Builder.Int qualified as TL
import Data.Text.Lazy.Encoding qualified as LT (encodeUtf8)
import GHC.Natural (Natural)
import Network.Simple.TCP (HostPreference (..), serve)
import Text.Blaze.Html (Html, toHtml)
import Text.Blaze.Html.Renderer.Utf8 qualified as BR
import Text.Blaze.Html5 as Html ()
import Text.Blaze.Html5 qualified as HTML
</code></pre>
<h2 id="91-some-common-types"><a class="header" href="#91-some-common-types">9.1 Some common types</a></h2>
<pre><code class="language-haskell">plainUtf8 :: FieldValue
plainUtf8 = FieldValue [A.string|text/plain; charset=utf-8|]

htmlUtf8 :: FieldValue
htmlUtf8 = FieldValue [A.string|text/html; charset=utf-8|]

json :: FieldValue
json = FieldValue [A.string|application/json|]
</code></pre>
<h2 id="92-utf-8"><a class="header" href="#92-utf-8">9.2 UTF-8</a></h2>
<pre><code class="language-haskell">countHelloText :: Natural -&gt; LT.Text
countHelloText count =
  TL.toLazyText $
    TL.fromString &quot;Hello! \9835\r\n&quot;
      &lt;&gt; case count of
        0 -&gt; TL.fromString &quot;This page has never been viewed.&quot;
        1 -&gt; TL.fromString &quot;This page has never been viewed 1 time.&quot;
        _ -&gt; TL.fromString &quot;This page has been viewed &quot; &lt;&gt; TL.decimal count &lt;&gt; TL.fromString &quot; times.&quot;

helloNote :: LT.Text
helloNote = countHelloText 3

textOk :: LT.Text -&gt; Response
textOk str = Response (status ok) [typ, len] (Just body)
 where
  typ = HeaderField contentType plainUtf8
  len = contentLengthField body
  -- should convert text to bytestring
  body = MessageBody (LT.encodeUtf8 str)

stuckCountingServerText :: IO a
stuckCountingServerText = serve @IO HostAny &quot;8000&quot; \(s, _) -&gt; do
  let count = 0
  sendResponse s (textOk (countHelloText count))
</code></pre>
<h2 id="93-html"><a class="header" href="#93-html">9.3 HTML</a></h2>
<pre><code class="language-haskell">countHelloHtml :: Natural -&gt; Html
countHelloHtml count = HTML.docType &lt;&gt; htmlDocument
 where
  htmlDocument =
    HTML.html $
      documentMetadata &lt;&gt; documentBody
  documentMetadata = HTML.head titleHtml
  titleHtml = HTML.title (toHtml &quot;My great web page&quot;)
  documentBody =
    HTML.body $
      greetingHtml &lt;&gt; HTML.hr &lt;&gt; hitCounterHtml
  greetingHtml = HTML.p (toHtml &quot;Hello! \9835&quot;)
  hitCounterHtml = HTML.p $ case count of
    0 -&gt; toHtml &quot;This page has never been viewed.&quot;
    1 -&gt; toHtml &quot;This page has been viewed 1 time.&quot;
    _ -&gt;
      toHtml &quot;This page has been viewed &quot;
        &lt;&gt; toHtml @Natural count
        &lt;&gt; toHtml &quot; times.&quot;

renderHtml' :: Html -&gt; LBS.ByteString
renderHtml' = BR.renderHtml
</code></pre>
<h2 id="94-json"><a class="header" href="#94-json">9.4 JSON</a></h2>
<pre><code class="language-haskell">countHelloJSON1 :: Natural -&gt; J.Value
countHelloJSON1 count = toJSON (J.KeyMap.fromList [greetingJson, hitsJson])
 where
  greetingJson = (J.Key.fromString &quot;greeting&quot;, toJSON &quot;Hello! \9835&quot;)
  hitsJson = (J.Key.fromString &quot;hits&quot;, toJSON (J.KeyMap.fromList [numberJson, messageJson]))
  numberJson = (J.Key.fromString &quot;count&quot;, toJSON count)
  messageJson = (J.Key.fromString &quot;message&quot;, toJSON (countHelloText count))

ch :: J.Value
ch = countHelloJSON1 3

-- &gt;&gt;&gt;ch
-- Object (fromList [(&quot;greeting&quot;,String &quot;Hello! \9835&quot;),(&quot;hits&quot;,Object (fromList [(&quot;count&quot;,Number 3.0),(&quot;message&quot;,String &quot;Hello! \9835\r\nThis page has been viewed 3 times.&quot;)]))])

countHelloJSON :: Natural -&gt; J.Value
countHelloJSON count =
  J.object
    [ fromString &quot;greeting&quot; .= fromString @T.Text &quot;Hello! \9835&quot;
    , fromString &quot;hits&quot;
        .= J.object
          [ fromString &quot;count&quot; .= count
          , fromString &quot;message&quot; .= countHelloText count
          ]
    ]

jsonOk :: J.Value -&gt; Response
jsonOk str = Response (status ok) [typ, len] (Just body)
 where
  typ = HeaderField contentType json
  len = contentLengthField body
  body = MessageBody (J.encode str)
</code></pre>
<h2 id="95-exercises"><a class="header" href="#95-exercises">9.5 Exercises</a></h2>
<pre><code class="language-haskell">htmlOk :: Html -&gt; Response
htmlOk str = Response (status ok) [typ, len] (Just body)
 where
  typ = HeaderField contentType htmlUtf8
  len = contentLengthField body
  body = MessageBody (BR.renderHtml str)

stuckCountingServerHtml :: IO a
stuckCountingServerHtml = serve @IO HostAny &quot;8000&quot; \(s, _) -&gt; do
  let count = 0
  sendResponse s (htmlOk (countHelloHtml count))
</code></pre>
<h3 id="ex-25"><a class="header" href="#ex-25">Ex 25</a></h3>
<pre><code class="language-haskell">class Encode a where
  encode :: a -&gt; BSB.Builder

instance Encode Request where
  encode :: Request -&gt; BSB.Builder
  encode = encodeRequest

instance Encode Response where
  encode :: Response -&gt; BSB.Builder
  encode = encodeResponse

instance Encode Integer where
  encode :: Integer -&gt; BSB.Builder
  encode = BSB.integerDec

instance Encode Int64 where
  encode :: Int64 -&gt; BSB.Builder
  encode = BSB.int64Dec

instance Encode T.Text where
  encode :: T.Text -&gt; BSB.Builder
  encode = BSB.lazyByteString . LT.encodeUtf8 . LT.fromStrict

instance Encode LT.Text where
  encode :: LT.Text -&gt; BSB.Builder
  encode = BSB.lazyByteString . LT.encodeUtf8

instance Encode BS.ByteString where
  encode :: BS.ByteString -&gt; BSB.Builder
  encode = BSB.byteString

instance Encode LBS.ByteString where
  encode :: LBS.ByteString -&gt; BSB.Builder
  encode = BSB.lazyByteString

instance Encode BSB.Builder where
  encode :: BSB.Builder -&gt; BSB.Builder
  encode = id
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-10"><a class="header" href="#chapter-10">Chapter 10</a></h1>
<pre><code class="language-haskell">module C_10_Change () where

import C_08_Responding (sendResponse)
import C_09_Content_types (countHelloHtml, htmlOk, textOk)
import Control.Concurrent.Async as Async (replicateConcurrently_)
import Control.Concurrent.STM (
  TVar,
  atomically,
  modifyTVar',
  newTVar,
  readTVarIO,
  writeTVar,
 )
import Control.Concurrent.STM.TVar (newTVarIO, readTVar)
import Control.Monad (replicateM)
import Control.Monad.STM (STM)
import Data.Text.Lazy qualified as LT
import Data.Time as Time (diffUTCTime, getCurrentTime)
import GHC.Natural (Natural)
import Network.Simple.TCP (HostPreference (..), serve)
import Text.Blaze.Html5 as Html ()
</code></pre>
<h2 id="101-stm"><a class="header" href="#101-stm">10.1 STM</a></h2>
<h2 id="102-increment"><a class="header" href="#102-increment">10.2 Increment</a></h2>
<pre><code class="language-haskell">increment :: TVar Natural -&gt; STM Natural
increment tvar = modifyTVar' tvar (+ 1) &gt;&gt; readTVar tvar
</code></pre>
<h2 id="104-the-counting-server"><a class="header" href="#104-the-counting-server">10.4 The counting server</a></h2>
<pre><code class="language-haskell">countingServer :: IO ()
countingServer = do
  hitCounter &lt;- newTVarIO (0 :: Natural)
  serve @IO HostAny &quot;8000&quot; \(s, _) -&gt; do
    count &lt;- atomically (increment hitCounter)
    sendResponse s (htmlOk (countHelloHtml count))

trySTM :: IO ()
trySTM = do
  x &lt;- newTVarIO &quot;Constantinopole&quot;
  readTVarIO x &gt;&gt;= putStrLn
  atomically (writeTVar x &quot;Istanbul&quot;)
  readTVarIO x &gt;&gt;= putStrLn
</code></pre>
<h2 id="106-exercises"><a class="header" href="#106-exercises">10.6 Exercises</a></h2>
<h3 id="ex-26"><a class="header" href="#ex-26">Ex 26</a></h3>
<pre><code class="language-haskell">incrementNotAtomic :: TVar Natural -&gt; IO Natural
incrementNotAtomic t = do
  count &lt;- readTVarIO t
  atomically $ writeTVar t (count + 1)
  readTVarIO t

testIncrement :: (TVar Natural -&gt; IO a) -&gt; IO Natural
testIncrement inc = do
  x &lt;- atomically (newTVar @Natural 0)
  Async.replicateConcurrently_ 10 (replicateM 1000 (inc x))
  readTVarIO x
</code></pre>
<h3 id="ex-27"><a class="header" href="#ex-27">Ex 27</a></h3>
<pre><code class="language-haskell">timingServer :: IO ()
timingServer = do
  lastTime &lt;- newTVarIO Nothing
  serve @IO HostAny &quot;8000&quot; \(s, _) -&gt; do
    prevTime &lt;- readTVarIO lastTime
    curTime &lt;- Time.getCurrentTime
    atomically $ writeTVar lastTime (Just curTime)
    sendResponse s $
      textOk $
        LT.pack $
          show (Time.diffUTCTime &lt;$&gt; Just curTime &lt;*&gt; prevTime)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="11-streaming"><a class="header" href="#11-streaming">11. Streaming</a></h1>
<pre><code class="language-haskell">module C_11_Streaming () where

import C_01_Handles (getDataDir)
import C_03_Bytes (binaryFileResource)
import C_06_HTTP_types (MessageBody (MessageBody), Response (..))
import C_08_Responding (ok, sendResponse, status)
import Control.Monad.IO.Class (MonadIO (..))
import Control.Monad.Trans.Resource (runResourceT)
import Data.ByteString.Lazy qualified as LBS
import GHC.IO.Handle (Handle)
import GHC.IO.IOMode (IOMode (..))
import Network.Simple.TCP (HostPreference (..), serve)
import System.FilePath ((&lt;/&gt;))
import Text.Blaze.Html5 as Html ()

hContentsResponse :: Handle -&gt; IO Response
hContentsResponse h = do
  fileContent &lt;- liftIO (LBS.hGetContents h)
  let body = Just (MessageBody fileContent)
  return (Response (status ok) [] body)

fileStrict :: IO b
fileStrict = do
  dir &lt;- getDataDir
  serve @IO HostAny &quot;8000&quot; \(s, _) -&gt; runResourceT @IO do
    (_, h) &lt;-
      binaryFileResource (dir &lt;/&gt; &quot;stream.txt&quot;) ReadMode
    r &lt;- liftIO (hContentsResponse h)
    liftIO (sendResponse s r)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="notes"><a class="header" href="#notes">Notes</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
